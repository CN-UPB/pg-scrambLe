from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
    import builtins as __builtin__

    long = int
    unicode = str
elif six.PY2:
    import __builtin__


class yc_project_rw_project__project(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module rw-project - based on the path /project. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration and state for individual projects.  RIFT.ware
applications and projects are expected to augment this list in
order to add configuration for projects that is specific to the
product or application.  As such, this list contains minimal
data defined in this yang module.

When augmenting this element, other yang modules should prefer to
define containers with the same name as the augmenting module.
(Augmenting RIFT.ware modules should prefer to augment without
the rw prefix [for new features], or should prefer to augment the
augmented container of an existing augment, to ease future
adoption and/or standardization.)
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__description' ,)

    _yang_name = 'project'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_dict={'length': [u'1..255']}) , is_leaf=True ,
            yang_name="name" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , is_keyval=True , namespace='http://riftio.com/ns/riftware-1.0/rw-project' ,
            defining_module='rw-project' , yang_type='string' , is_config=True)
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True ,
                                          namespace='http://riftio.com/ns/riftware-1.0/rw-project' ,
                                          defining_module='rw-project' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'project']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /project/name (string)

    YANG Description: Name of the project.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /project/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the project.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=unicode , restriction_dict={'length': [u'1..255']}) ,
                             is_leaf=True , yang_name="name" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                             namespace='http://riftio.com/ns/riftware-1.0/rw-project' , defining_module='rw-project' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..255']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://riftio.com/ns/riftware-1.0/rw-project', defining_module='rw-project', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_dict={'length': [u'1..255']}) , is_leaf=True ,
            yang_name="name" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , is_keyval=True , namespace='http://riftio.com/ns/riftware-1.0/rw-project' ,
            defining_module='rw-project' , yang_type='string' , is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /project/description (string)

    YANG Description: Information about project
    """
        return self.__description

    def _set_description(self , v , load=False):
        """
    Setter method for description, mapped from YANG variable /project/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Information about project
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='http://riftio.com/ns/riftware-1.0/rw-project' , defining_module='rw-project' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://riftio.com/ns/riftware-1.0/rw-project', defining_module='rw-project', yang_type='string', is_config=True)""" ,
            })

        self.__description = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True ,
                                          namespace='http://riftio.com/ns/riftware-1.0/rw-project' ,
                                          defining_module='rw-project' , yang_type='string' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    description = __builtin__.property(_get_description , _set_description)

    _pyangbind_elements = {'name': name , 'description': description , }


class rw_project(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module rw-project - based on the path /rw-project. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This yang module defines project-based tenancy for RIFT.ware.
Authorization for project access is defined in terms of RIFT.ware's
Role-Based Access Control (RBAC) model.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__project' ,)

    _yang_name = 'rw-project'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__project = YANGDynClass(
            base=YANGListType("name" , yc_project_rw_project__project , yang_name="project" , parent=self ,
                              is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='name' , extensions=None) , is_container='list' , yang_name="project" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='http://riftio.com/ns/riftware-1.0/rw-project' , defining_module='rw-project' ,
            yang_type='list' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return []

    def _get_project(self):
        """
    Getter method for project, mapped from YANG variable /project (list)

    YANG Description: Configuration and state for individual projects.  RIFT.ware
applications and projects are expected to augment this list in
order to add configuration for projects that is specific to the
product or application.  As such, this list contains minimal
data defined in this yang module.

When augmenting this element, other yang modules should prefer to
define containers with the same name as the augmenting module.
(Augmenting RIFT.ware modules should prefer to augment without
the rw prefix [for new features], or should prefer to augment the
augmented container of an existing augment, to ease future
adoption and/or standardization.)
    """
        return self.__project

    def _set_project(self , v , load=False):
        """
    Setter method for project, mapped from YANG variable /project (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_project is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_project() directly.

    YANG Description: Configuration and state for individual projects.  RIFT.ware
applications and projects are expected to augment this list in
order to add configuration for projects that is specific to the
product or application.  As such, this list contains minimal
data defined in this yang module.

When augmenting this element, other yang modules should prefer to
define containers with the same name as the augmenting module.
(Augmenting RIFT.ware modules should prefer to augment without
the rw prefix [for new features], or should prefer to augment the
augmented container of an existing augment, to ease future
adoption and/or standardization.)
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" , yc_project_rw_project__project , yang_name="project" ,
                                                   parent=self , is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
                             is_container='list' , yang_name="project" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='http://riftio.com/ns/riftware-1.0/rw-project' , defining_module='rw-project' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """project must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_project_rw_project__project, yang_name="project", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="project", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://riftio.com/ns/riftware-1.0/rw-project', defining_module='rw-project', yang_type='list', is_config=True)""" ,
            })

        self.__project = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_project(self):
        self.__project = YANGDynClass(
            base=YANGListType("name" , yc_project_rw_project__project , yang_name="project" , parent=self ,
                              is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='name' , extensions=None) , is_container='list' , yang_name="project" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='http://riftio.com/ns/riftware-1.0/rw-project' , defining_module='rw-project' ,
            yang_type='list' , is_config=True)

    project = __builtin__.property(_get_project , _set_project)

    _pyangbind_elements = {'project': project , }


class mano_types(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mano-types - based on the path /mano-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class yc_script_vnfd__vnfd_catalog_vnfd_vnf_configuration_script(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/script. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__script_type' ,)

    _yang_name = 'script'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                   restriction_arg={u'rift': {}} , ) , is_leaf=True ,
                                          yang_name="script-type" , parent=self ,
                                          choice=(u'config-method' , u'script') , path_helper=self._path_helper ,
                                          extmethods=self._extmethods , register_paths=True ,
                                          namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                          yang_type='enumeration' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vnf-configuration' , u'script']

    def _get_script_type(self):
        """
    Getter method for script_type, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/script/script_type (enumeration)

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
        return self.__script_type

    def _set_script_type(self , v , load=False):
        """
    Setter method for script_type, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/script/script_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script_type() directly.

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'rift': {}} , ) , is_leaf=True ,
                             yang_name="script-type" , parent=self , choice=(u'config-method' , u'script') ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """script_type must be of a type compatible with enumeration""" ,
                'defined-type': "vnfd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__script_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_script_type(self):
        self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                   restriction_arg={u'rift': {}} , ) , is_leaf=True ,
                                          yang_name="script-type" , parent=self ,
                                          choice=(u'config-method' , u'script') , path_helper=self._path_helper ,
                                          extmethods=self._extmethods , register_paths=True ,
                                          namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                          yang_type='enumeration' , is_config=True)

    script_type = __builtin__.property(_get_script_type , _set_script_type)

    __choices__ = {u'config-method': {u'script': [u'script_type']}}
    _pyangbind_elements = {'script_type': script_type , }


class yc_relation_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju_vca_relationships_relation(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/juju/vca-relationships/relation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of relations between VCA componets.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__requires' , '__provides' ,)

    _yang_name = 'relation'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__requires = YANGDynClass(base=unicode , is_leaf=True , yang_name="requires" , parent=self ,
                                       choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                       extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='string' , is_config=True)
        self.__provides = YANGDynClass(base=unicode , is_leaf=True , yang_name="provides" , parent=self ,
                                       choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                       extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vnf-configuration' , u'juju' , u'vca-relationships' , u'relation']

    def _get_requires(self):
        """
    Getter method for requires, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/vca_relationships/relation/requires (string)

    YANG Description: Name of the required relation.
    """
        return self.__requires

    def _set_requires(self , v , load=False):
        """
    Setter method for requires, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/vca_relationships/relation/requires (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_requires is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_requires() directly.

    YANG Description: Name of the required relation.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="requires" , parent=self ,
                             choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """requires must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="requires", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__requires = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_requires(self):
        self.__requires = YANGDynClass(base=unicode , is_leaf=True , yang_name="requires" , parent=self ,
                                       choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                       extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='string' , is_config=True)

    def _get_provides(self):
        """
    Getter method for provides, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/vca_relationships/relation/provides (string)

    YANG Description: Name of the provided relation.
    """
        return self.__provides

    def _set_provides(self , v , load=False):
        """
    Setter method for provides, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/vca_relationships/relation/provides (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provides is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provides() directly.

    YANG Description: Name of the provided relation.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="provides" , parent=self ,
                             choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """provides must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="provides", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__provides = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_provides(self):
        self.__provides = YANGDynClass(base=unicode , is_leaf=True , yang_name="provides" , parent=self ,
                                       choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                       extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='string' , is_config=True)

    requires = __builtin__.property(_get_requires , _set_requires)
    provides = __builtin__.property(_get_provides , _set_provides)

    __choices__ = {u'config-method': {u'juju': [u'requires' , u'provides']}}
    _pyangbind_elements = {'requires': requires , 'provides': provides , }


class yc_vca_relationships_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju_vca_relationships(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/juju/vca-relationships. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__relation' ,)

    _yang_name = 'vca-relationships'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__relation = YANGDynClass(base=YANGListType("requires provides" ,
                                                         yc_relation_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju_vca_relationships_relation ,
                                                         yang_name="relation" , parent=self , is_container='list' ,
                                                         user_ordered=False , path_helper=self._path_helper ,
                                                         yang_keys='requires provides' , extensions=None ,
                                                         choice=(u'config-method' , u'juju')) , is_container='list' ,
                                       yang_name="relation" , parent=self , choice=(u'config-method' , u'juju') ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , extensions=None ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='list' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vnf-configuration' , u'juju' , u'vca-relationships']

    def _get_relation(self):
        """
    Getter method for relation, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/vca_relationships/relation (list)

    YANG Description: List of relations between VCA componets.
    """
        return self.__relation

    def _set_relation(self , v , load=False):
        """
    Setter method for relation, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/vca_relationships/relation (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relation() directly.

    YANG Description: List of relations between VCA componets.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("requires provides" ,
                                                   yc_relation_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju_vca_relationships_relation ,
                                                   yang_name="relation" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='requires provides' , extensions=None ,
                                                   choice=(u'config-method' , u'juju')) , is_container='list' ,
                             yang_name="relation" , parent=self , choice=(u'config-method' , u'juju') ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """relation must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("requires provides",yc_relation_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju_vca_relationships_relation, yang_name="relation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='requires provides', extensions=None, choice=(u'config-method', u'juju')), is_container='list', yang_name="relation", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__relation = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_relation(self):
        self.__relation = YANGDynClass(base=YANGListType("requires provides" ,
                                                         yc_relation_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju_vca_relationships_relation ,
                                                         yang_name="relation" , parent=self , is_container='list' ,
                                                         user_ordered=False , path_helper=self._path_helper ,
                                                         yang_keys='requires provides' , extensions=None ,
                                                         choice=(u'config-method' , u'juju')) , is_container='list' ,
                                       yang_name="relation" , parent=self , choice=(u'config-method' , u'juju') ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , extensions=None ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='list' , is_config=True)

    relation = __builtin__.property(_get_relation , _set_relation)

    __choices__ = {u'config-method': {u'juju': [u'relation']}}
    _pyangbind_elements = {'relation': relation , }


class yc_juju_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/juju. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__charm' , '__proxy' , '__vca_relationships' ,)

    _yang_name = 'juju'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vca_relationships = YANGDynClass(
            base=yc_vca_relationships_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju_vca_relationships ,
            is_container='container' , yang_name="vca-relationships" , parent=self ,
            choice=(u'config-method' , u'juju') , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='container' , is_config=True)
        self.__charm = YANGDynClass(base=unicode , is_leaf=True , yang_name="charm" , parent=self ,
                                    choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                    extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)
        self.__proxy = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="proxy" ,
                                    parent=self , choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                    extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='boolean' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vnf-configuration' , u'juju']

    def _get_charm(self):
        """
    Getter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/charm (string)

    YANG Description: Juju charm to use with the VNF or VDU.
    """
        return self.__charm

    def _set_charm(self , v , load=False):
        """
    Setter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/charm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_charm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_charm() directly.

    YANG Description: Juju charm to use with the VNF or VDU.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="charm" , parent=self ,
                             choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """charm must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__charm = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_charm(self):
        self.__charm = YANGDynClass(base=unicode , is_leaf=True , yang_name="charm" , parent=self ,
                                    choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                    extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)

    def _get_proxy(self):
        """
    Getter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/proxy (boolean)

    YANG Description: Is this a proxy charm?
    """
        return self.__proxy

    def _set_proxy(self , v , load=False):
        """
    Setter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/proxy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy() directly.

    YANG Description: Is this a proxy charm?
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="proxy" ,
                             parent=self , choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """proxy must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__proxy = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_proxy(self):
        self.__proxy = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="proxy" ,
                                    parent=self , choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                    extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='boolean' , is_config=True)

    def _get_vca_relationships(self):
        """
    Getter method for vca_relationships, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/vca_relationships (container)
    """
        return self.__vca_relationships

    def _set_vca_relationships(self , v , load=False):
        """
    Setter method for vca_relationships, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju/vca_relationships (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vca_relationships is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vca_relationships() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=yc_vca_relationships_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju_vca_relationships ,
                             is_container='container' , yang_name="vca-relationships" , parent=self ,
                             choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vca_relationships must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_vca_relationships_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju_vca_relationships, is_container='container', yang_name="vca-relationships", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__vca_relationships = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vca_relationships(self):
        self.__vca_relationships = YANGDynClass(
            base=yc_vca_relationships_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju_vca_relationships ,
            is_container='container' , yang_name="vca-relationships" , parent=self ,
            choice=(u'config-method' , u'juju') , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='container' , is_config=True)

    charm = __builtin__.property(_get_charm , _set_charm)
    proxy = __builtin__.property(_get_proxy , _set_proxy)
    vca_relationships = __builtin__.property(_get_vca_relationships , _set_vca_relationships)

    __choices__ = {u'config-method': {u'juju': [u'charm' , u'proxy' , u'vca_relationships']}}
    _pyangbind_elements = {'charm': charm , 'proxy': proxy , 'vca_relationships': vca_relationships , }


class yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the config primitive.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__name' , '__data_type' , '__mandatory' , '__default_value' , '__parameter_pool' ,
    '__read_only' , '__hidden' ,)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__default_value = YANGDynClass(base=unicode , is_leaf=True , yang_name="default-value" , parent=self ,
                                            path_helper=self._path_helper , extmethods=self._extmethods ,
                                            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                            defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__read_only = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                        yang_name="read-only" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='boolean' , is_config=True)
        self.__mandatory = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                        yang_name="mandatory" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='boolean' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                                  u'STRING': {}} , ) , is_leaf=True ,
                                        yang_name="data-type" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='manotypes:parameter-data-type' , is_config=True)
        self.__parameter_pool = YANGDynClass(base=unicode , is_leaf=True , yang_name="parameter-pool" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__hidden = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="hidden" ,
                                     parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                     register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                     defining_module='vnfd' , yang_type='boolean' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vnf-configuration' , u'config-primitive' , u'parameter']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_data_type(self):
        """
    Getter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the name.
    """
        return self.__data_type

    def _set_data_type(self , v , load=False):
        """
    Setter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the name.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                           u'STRING': {}} , ) , is_leaf=True ,
                             yang_name="data-type" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='manotypes:parameter-data-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""" ,
                'defined-type': "manotypes:parameter-data-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)""" ,
            })

        self.__data_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_data_type(self):
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                                  u'STRING': {}} , ) , is_leaf=True ,
                                        yang_name="data-type" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='manotypes:parameter-data-type' , is_config=True)

    def _get_mandatory(self):
        """
    Getter method for mandatory, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/mandatory (boolean)

    YANG Description: Is this field mandatory
    """
        return self.__mandatory

    def _set_mandatory(self , v , load=False):
        """
    Setter method for mandatory, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mandatory() directly.

    YANG Description: Is this field mandatory
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="mandatory" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """mandatory must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__mandatory = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_mandatory(self):
        self.__mandatory = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                        yang_name="mandatory" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='boolean' , is_config=True)

    def _get_default_value(self):
        """
    Getter method for default_value, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/default_value (string)

    YANG Description: The default value for this field
    """
        return self.__default_value

    def _set_default_value(self , v , load=False):
        """
    Setter method for default_value, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/default_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_value() directly.

    YANG Description: The default value for this field
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="default-value" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """default_value must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__default_value = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_default_value(self):
        self.__default_value = YANGDynClass(base=unicode , is_leaf=True , yang_name="default-value" , parent=self ,
                                            path_helper=self._path_helper , extmethods=self._extmethods ,
                                            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                            defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_parameter_pool(self):
        """
    Getter method for parameter_pool, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/parameter_pool (string)

    YANG Description: NSD parameter pool name to use for this parameter
    """
        return self.__parameter_pool

    def _set_parameter_pool(self , v , load=False):
        """
    Setter method for parameter_pool, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/parameter_pool (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter_pool() directly.

    YANG Description: NSD parameter pool name to use for this parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="parameter-pool" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """parameter_pool must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__parameter_pool = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_parameter_pool(self):
        self.__parameter_pool = YANGDynClass(base=unicode , is_leaf=True , yang_name="parameter-pool" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_read_only(self):
        """
    Getter method for read_only, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/read_only (boolean)

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
        return self.__read_only

    def _set_read_only(self , v , load=False):
        """
    Setter method for read_only, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/read_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_read_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_read_only() directly.

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="read-only" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """read_only must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__read_only = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_read_only(self):
        self.__read_only = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                        yang_name="read-only" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='boolean' , is_config=True)

    def _get_hidden(self):
        """
    Getter method for hidden, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/hidden (boolean)

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
        return self.__hidden

    def _set_hidden(self , v , load=False):
        """
    Setter method for hidden, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter/hidden (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hidden is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hidden() directly.

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="hidden" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """hidden must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__hidden = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_hidden(self):
        self.__hidden = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="hidden" ,
                                     parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                     register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                     defining_module='vnfd' , yang_type='boolean' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    data_type = __builtin__.property(_get_data_type , _set_data_type)
    mandatory = __builtin__.property(_get_mandatory , _set_mandatory)
    default_value = __builtin__.property(_get_default_value , _set_default_value)
    parameter_pool = __builtin__.property(_get_parameter_pool , _set_parameter_pool)
    read_only = __builtin__.property(_get_read_only , _set_read_only)
    hidden = __builtin__.property(_get_hidden , _set_hidden)

    _pyangbind_elements = {'name': name , 'data_type': data_type , 'mandatory': mandatory ,
                           'default_value': default_value , 'parameter_pool': parameter_pool , 'read_only': read_only ,
                           'hidden': hidden , }


class yc_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__parameter' , '__user_defined_script' ,)

    _yang_name = 'config-primitive'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__user_defined_script = YANGDynClass(base=unicode , is_leaf=True , yang_name="user-defined-script" ,
                                                  parent=self , path_helper=self._path_helper ,
                                                  extmethods=self._extmethods , register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                  defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__parameter = YANGDynClass(base=YANGListType("name" ,
                                                          yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive_parameter ,
                                                          yang_name="parameter" , parent=self , is_container='list' ,
                                                          user_ordered=False , path_helper=self._path_helper ,
                                                          yang_keys='name' , extensions=None) , is_container='list' ,
                                        yang_name="parameter" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True , extensions=None ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='list' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vnf-configuration' , u'config-primitive']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/name (string)

    YANG Description: Name of the config primitive.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the config primitive.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter (list)

    YANG Description: List of parameters to the config primitive.
    """
        return self.__parameter

    def _set_parameter(self , v , load=False):
        """
    Setter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the config primitive.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" ,
                                                   yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive_parameter ,
                                                   yang_name="parameter" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="parameter" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__parameter = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("name" ,
                                                          yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive_parameter ,
                                                          yang_name="parameter" , parent=self , is_container='list' ,
                                                          user_ordered=False , path_helper=self._path_helper ,
                                                          yang_keys='name' , extensions=None) , is_container='list' ,
                                        yang_name="parameter" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True , extensions=None ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='list' , is_config=True)

    def _get_user_defined_script(self):
        """
    Getter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/user_defined_script (string)

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
        return self.__user_defined_script

    def _set_user_defined_script(self , v , load=False):
        """
    Setter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="user-defined-script" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """user_defined_script must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__user_defined_script = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_user_defined_script(self):
        self.__user_defined_script = YANGDynClass(base=unicode , is_leaf=True , yang_name="user-defined-script" ,
                                                  parent=self , path_helper=self._path_helper ,
                                                  extmethods=self._extmethods , register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                  defining_module='vnfd' , yang_type='string' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    parameter = __builtin__.property(_get_parameter , _set_parameter)
    user_defined_script = __builtin__.property(_get_user_defined_script , _set_user_defined_script)

    _pyangbind_elements = {'name': name , 'parameter': parameter , 'user_defined_script': user_defined_script , }


class yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/initial-config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the configuration primitive.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__data_type' , '__value' ,)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__value = YANGDynClass(base=unicode , is_leaf=True , yang_name="value" , parent=self ,
                                    choice=(u'primitive-type' , u'primitive-definition') ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   choice=(u'primitive-type' , u'primitive-definition') ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                                  u'STRING': {}} , ) , is_leaf=True ,
                                        yang_name="data-type" , parent=self ,
                                        choice=(u'primitive-type' , u'primitive-definition') ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                        defining_module='vnfd' , yang_type='manotypes:parameter-data-type' ,
                                        is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vnf-configuration' , u'initial-config-primitive' , u'parameter']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             choice=(u'primitive-type' , u'primitive-definition') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   choice=(u'primitive-type' , u'primitive-definition') ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_data_type(self):
        """
    Getter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the value.
    """
        return self.__data_type

    def _set_data_type(self , v , load=False):
        """
    Setter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the value.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                           u'STRING': {}} , ) , is_leaf=True ,
                             yang_name="data-type" , parent=self ,
                             choice=(u'primitive-type' , u'primitive-definition') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='manotypes:parameter-data-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""" ,
                'defined-type': "manotypes:parameter-data-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)""" ,
            })

        self.__data_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_data_type(self):
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                                  u'STRING': {}} , ) , is_leaf=True ,
                                        yang_name="data-type" , parent=self ,
                                        choice=(u'primitive-type' , u'primitive-definition') ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                        defining_module='vnfd' , yang_type='manotypes:parameter-data-type' ,
                                        is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/parameter/value (string)

    YANG Description: Value associated with the name.
    """
        return self.__value

    def _set_value(self , v , load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value associated with the name.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="value" , parent=self ,
                             choice=(u'primitive-type' , u'primitive-definition') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__value = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=unicode , is_leaf=True , yang_name="value" , parent=self ,
                                    choice=(u'primitive-type' , u'primitive-definition') ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    data_type = __builtin__.property(_get_data_type , _set_data_type)
    value = __builtin__.property(_get_value , _set_value)

    __choices__ = {u'primitive-type': {u'primitive-definition': [u'name' , u'data_type' , u'value']}}
    _pyangbind_elements = {'name': name , 'data_type': data_type , 'value': value , }


class yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/initial-config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Initial set of configuration primitives.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__seq' , '__name' , '__parameter' , '__user_defined_script' ,)

    _yang_name = 'initial-config-primitive'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__user_defined_script = YANGDynClass(base=unicode , is_leaf=True , yang_name="user-defined-script" ,
                                                  parent=self , choice=(u'primitive-type' , u'primitive-definition') ,
                                                  path_helper=self._path_helper , extmethods=self._extmethods ,
                                                  register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                  defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__parameter = YANGDynClass(base=YANGListType("name" ,
                                                          yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive_parameter ,
                                                          yang_name="parameter" , parent=self , is_container='list' ,
                                                          user_ordered=False , path_helper=self._path_helper ,
                                                          yang_keys='name' , extensions=None , choice=False) ,
                                        is_container='list' , yang_name="parameter" , parent=self ,
                                        choice=(u'primitive-type' , u'primitive-definition') ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , extensions=None ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='list' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   choice=(u'primitive-type' , u'primitive-definition') ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)
        self.__seq = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="seq" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , is_keyval=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vnf-configuration' , u'initial-config-primitive']

    def _get_seq(self):
        """
    Getter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
        return self.__seq

    def _set_seq(self , v , load=False):
        """
    Setter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="seq" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """seq must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__seq = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_seq(self):
        self.__seq = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="seq" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , is_keyval=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/name (string)

    YANG Description: Name of the configuration primitive.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             choice=(u'primitive-type' , u'primitive-definition') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   choice=(u'primitive-type' , u'primitive-definition') ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/parameter (list)

    YANG Description: List of parameters to the configuration primitive.
    """
        return self.__parameter

    def _set_parameter(self , v , load=False):
        """
    Setter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the configuration primitive.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" ,
                                                   yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive_parameter ,
                                                   yang_name="parameter" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None , choice=False) ,
                             is_container='list' , yang_name="parameter" , parent=self ,
                             choice=(u'primitive-type' , u'primitive-definition') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__parameter = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("name" ,
                                                          yc_parameter_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive_parameter ,
                                                          yang_name="parameter" , parent=self , is_container='list' ,
                                                          user_ordered=False , path_helper=self._path_helper ,
                                                          yang_keys='name' , extensions=None , choice=False) ,
                                        is_container='list' , yang_name="parameter" , parent=self ,
                                        choice=(u'primitive-type' , u'primitive-definition') ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , extensions=None ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='list' , is_config=True)

    def _get_user_defined_script(self):
        """
    Getter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
        return self.__user_defined_script

    def _set_user_defined_script(self , v , load=False):
        """
    Setter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="user-defined-script" , parent=self ,
                             choice=(u'primitive-type' , u'primitive-definition') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """user_defined_script must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__user_defined_script = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_user_defined_script(self):
        self.__user_defined_script = YANGDynClass(base=unicode , is_leaf=True , yang_name="user-defined-script" ,
                                                  parent=self , choice=(u'primitive-type' , u'primitive-definition') ,
                                                  path_helper=self._path_helper , extmethods=self._extmethods ,
                                                  register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                  defining_module='vnfd' , yang_type='string' , is_config=True)

    seq = __builtin__.property(_get_seq , _set_seq)
    name = __builtin__.property(_get_name , _set_name)
    parameter = __builtin__.property(_get_parameter , _set_parameter)
    user_defined_script = __builtin__.property(_get_user_defined_script , _set_user_defined_script)

    __choices__ = {u'primitive-type': {u'primitive-definition': [u'name' , u'parameter' , u'user_defined_script']}}
    _pyangbind_elements = {'seq': seq , 'name': name , 'parameter': parameter ,
                           'user_defined_script': user_defined_script , }


class yc_metrics_vnfd__vnfd_catalog_vnfd_vnf_configuration_metrics(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration/metrics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VCA related metrics
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' ,)

    _yang_name = 'metrics'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vnf-configuration' , u'metrics']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/metrics/name (string)

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/metrics/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)

    _pyangbind_elements = {'name': name , }


class yc_vnf_configuration_vnfd__vnfd_catalog_vnfd_vnf_configuration(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vnf-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__script' , '__juju' , '__config_primitive' , '__initial_config_primitive' ,
    '__metrics' ,)

    _yang_name = 'vnf-configuration'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju ,
                                   is_container='container' , yang_name="juju" , parent=self ,
                                   choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                   extmethods=self._extmethods , register_paths=True , extensions=None ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='container' , is_config=True)
        self.__config_primitive = YANGDynClass(
            base=YANGListType("name" , yc_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive ,
                              yang_name="config-primitive" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="config-primitive" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq" ,
                                                                         yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive ,
                                                                         yang_name="initial-config-primitive" ,
                                                                         parent=self , is_container='list' ,
                                                                         user_ordered=False ,
                                                                         path_helper=self._path_helper ,
                                                                         yang_keys='seq' , extensions=None) ,
                                                       is_container='list' , yang_name="initial-config-primitive" ,
                                                       parent=self , path_helper=self._path_helper ,
                                                       extmethods=self._extmethods , register_paths=True ,
                                                       extensions=None ,
                                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                       defining_module='vnfd' , yang_type='list' , is_config=True)
        self.__metrics = YANGDynClass(
            base=YANGListType("name" , yc_metrics_vnfd__vnfd_catalog_vnfd_vnf_configuration_metrics ,
                              yang_name="metrics" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="metrics" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__script = YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_vnf_configuration_script ,
                                     is_container='container' , yang_name="script" , parent=self ,
                                     choice=(u'config-method' , u'script') , path_helper=self._path_helper ,
                                     extmethods=self._extmethods , register_paths=True , extensions=None ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                     yang_type='container' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vnf-configuration']

    def _get_script(self):
        """
    Getter method for script, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/script (container)
    """
        return self.__script

    def _set_script(self , v , load=False):
        """
    Setter method for script, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/script (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_script_vnfd__vnfd_catalog_vnfd_vnf_configuration_script ,
                             is_container='container' , yang_name="script" , parent=self ,
                             choice=(u'config-method' , u'script') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """script must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_vnf_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__script = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_script(self):
        self.__script = YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_vnf_configuration_script ,
                                     is_container='container' , yang_name="script" , parent=self ,
                                     choice=(u'config-method' , u'script') , path_helper=self._path_helper ,
                                     extmethods=self._extmethods , register_paths=True , extensions=None ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                     yang_type='container' , is_config=True)

    def _get_juju(self):
        """
    Getter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju (container)
    """
        return self.__juju

    def _set_juju(self , v , load=False):
        """
    Setter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/juju (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_juju_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju ,
                             is_container='container' , yang_name="juju" , parent=self ,
                             choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """juju must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__juju = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_juju(self):
        self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vnf_configuration_juju ,
                                   is_container='container' , yang_name="juju" , parent=self ,
                                   choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                   extmethods=self._extmethods , register_paths=True , extensions=None ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='container' , is_config=True)

    def _get_config_primitive(self):
        """
    Getter method for config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive (list)

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
        return self.__config_primitive

    def _set_config_primitive(self , v , load=False):
        """
    Setter method for config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_primitive() directly.

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" ,
                                                   yc_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive ,
                                                   yang_name="config-primitive" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="config-primitive" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """config_primitive must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__config_primitive = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_config_primitive(self):
        self.__config_primitive = YANGDynClass(
            base=YANGListType("name" , yc_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_config_primitive ,
                              yang_name="config-primitive" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="config-primitive" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    def _get_initial_config_primitive(self):
        """
    Getter method for initial_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive (list)

    YANG Description: Initial set of configuration primitives.
    """
        return self.__initial_config_primitive

    def _set_initial_config_primitive(self , v , load=False):
        """
    Setter method for initial_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/initial_config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_initial_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_initial_config_primitive() directly.

    YANG Description: Initial set of configuration primitives.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("seq" ,
                                                   yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive ,
                                                   yang_name="initial-config-primitive" , parent=self ,
                                                   is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='seq' , extensions=None) ,
                             is_container='list' , yang_name="initial-config-primitive" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """initial_config_primitive must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__initial_config_primitive = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_initial_config_primitive(self):
        self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq" ,
                                                                         yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vnf_configuration_initial_config_primitive ,
                                                                         yang_name="initial-config-primitive" ,
                                                                         parent=self , is_container='list' ,
                                                                         user_ordered=False ,
                                                                         path_helper=self._path_helper ,
                                                                         yang_keys='seq' , extensions=None) ,
                                                       is_container='list' , yang_name="initial-config-primitive" ,
                                                       parent=self , path_helper=self._path_helper ,
                                                       extmethods=self._extmethods , register_paths=True ,
                                                       extensions=None ,
                                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                       defining_module='vnfd' , yang_type='list' , is_config=True)

    def _get_metrics(self):
        """
    Getter method for metrics, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/metrics (list)

    YANG Description: List of VCA related metrics
    """
        return self.__metrics

    def _set_metrics(self , v , load=False):
        """
    Setter method for metrics, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration/metrics (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metrics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metrics() directly.

    YANG Description: List of VCA related metrics
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=YANGListType("name" , yc_metrics_vnfd__vnfd_catalog_vnfd_vnf_configuration_metrics ,
                                               yang_name="metrics" , parent=self , is_container='list' ,
                                               user_ordered=False , path_helper=self._path_helper , yang_keys='name' ,
                                               extensions=None) , is_container='list' , yang_name="metrics" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """metrics must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_vnf_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__metrics = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_metrics(self):
        self.__metrics = YANGDynClass(
            base=YANGListType("name" , yc_metrics_vnfd__vnfd_catalog_vnfd_vnf_configuration_metrics ,
                              yang_name="metrics" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="metrics" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    script = __builtin__.property(_get_script , _set_script)
    juju = __builtin__.property(_get_juju , _set_juju)
    config_primitive = __builtin__.property(_get_config_primitive , _set_config_primitive)
    initial_config_primitive = __builtin__.property(_get_initial_config_primitive , _set_initial_config_primitive)
    metrics = __builtin__.property(_get_metrics , _set_metrics)

    __choices__ = {u'config-method': {u'juju': [u'juju'] , u'script': [u'script']}}
    _pyangbind_elements = {'script': script , 'juju': juju , 'config_primitive': config_primitive ,
                           'initial_config_primitive': initial_config_primitive , 'metrics': metrics , }


class yc_dashboard_params_vnfd__vnfd_catalog_vnfd_mgmt_interface_dashboard_params(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/mgmt-interface/dashboard-params. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters for the VNF dashboard
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__path' , '__https' , '__port' ,)

    _yang_name = 'dashboard-params'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__path = YANGDynClass(base=unicode , is_leaf=True , yang_name="path" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)
        self.__port = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
            restriction_dict={'range': [u'0..65535']}) , is_leaf=True , yang_name="port" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='inet:port-number' , is_config=True)
        self.__https = YANGDynClass(base=YANGBool , is_leaf=True , yang_name="https" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='boolean' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'mgmt-interface' , u'dashboard-params']

    def _get_path(self):
        """
    Getter method for path, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/dashboard_params/path (string)

    YANG Description: The HTTP path for the dashboard
    """
        return self.__path

    def _set_path(self , v , load=False):
        """
    Setter method for path, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/dashboard_params/path (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path() directly.

    YANG Description: The HTTP path for the dashboard
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="path" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """path must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__path = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_path(self):
        self.__path = YANGDynClass(base=unicode , is_leaf=True , yang_name="path" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)

    def _get_https(self):
        """
    Getter method for https, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/dashboard_params/https (boolean)

    YANG Description: Pick HTTPS instead of HTTP , Default is false
    """
        return self.__https

    def _set_https(self , v , load=False):
        """
    Setter method for https, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/dashboard_params/https (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_https is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_https() directly.

    YANG Description: Pick HTTPS instead of HTTP , Default is false
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , is_leaf=True , yang_name="https" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """https must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="https", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__https = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_https(self):
        self.__https = YANGDynClass(base=YANGBool , is_leaf=True , yang_name="https" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='boolean' , is_config=True)

    def _get_port(self):
        """
    Getter method for port, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/dashboard_params/port (inet:port-number)

    YANG Description: The HTTP port for the dashboard
    """
        return self.__port

    def _set_port(self , v , load=False):
        """
    Setter method for port, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/dashboard_params/port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: The HTTP port for the dashboard
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(
                base_type=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
                restriction_dict={'range': [u'0..65535']}) , is_leaf=True , yang_name="port" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='inet:port-number' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """port must be of a type compatible with inet:port-number""" ,
                'defined-type': "inet:port-number" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='inet:port-number', is_config=True)""" ,
            })

        self.__port = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_port(self):
        self.__port = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
            restriction_dict={'range': [u'0..65535']}) , is_leaf=True , yang_name="port" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='inet:port-number' , is_config=True)

    path = __builtin__.property(_get_path , _set_path)
    https = __builtin__.property(_get_https , _set_https)
    port = __builtin__.property(_get_port , _set_port)

    _pyangbind_elements = {'path': path , 'https': https , 'port': port , }


class yc_mgmt_interface_vnfd__vnfd_catalog_vnfd_mgmt_interface(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/mgmt-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface over which the VNF is managed.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__ip_address' , '__vdu_id' , '__cp' , '__port' , '__dashboard_params' ,)

    _yang_name = 'mgmt-interface'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__dashboard_params = YANGDynClass(
            base=yc_dashboard_params_vnfd__vnfd_catalog_vnfd_mgmt_interface_dashboard_params ,
            is_container='container' , yang_name="dashboard-params" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)
        self.__cp = YANGDynClass(base=unicode , is_leaf=True , yang_name="cp" , parent=self ,
                                 choice=(u'endpoint-type' , u'cp') , path_helper=self._path_helper ,
                                 extmethods=self._extmethods , register_paths=True ,
                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                 yang_type='leafref' , is_config=True)
        self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                               RestrictedClassType(base_type=unicode , restriction_dict={
                                                   'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                         is_leaf=True , yang_name="ip-address" , parent=self ,
                                         choice=(u'endpoint-type' , u'ip') , path_helper=self._path_helper ,
                                         extmethods=self._extmethods , register_paths=True ,
                                         namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                         yang_type='inet:ip-address' , is_config=True)
        self.__port = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
            restriction_dict={'range': [u'0..65535']}) , is_leaf=True , yang_name="port" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='inet:port-number' , is_config=True)
        self.__vdu_id = YANGDynClass(base=unicode , is_leaf=True , yang_name="vdu-id" , parent=self ,
                                     choice=(u'endpoint-type' , u'vdu-id') , path_helper=self._path_helper ,
                                     extmethods=self._extmethods , register_paths=True ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                     yang_type='leafref' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'mgmt-interface']

    def _get_ip_address(self):
        """
    Getter method for ip_address, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/ip_address (inet:ip-address)
    """
        return self.__ip_address

    def _set_ip_address(self , v , load=False):
        """
    Setter method for ip_address, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=[RestrictedClassType(base_type=unicode , restriction_dict={
                'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                       RestrictedClassType(base_type=unicode , restriction_dict={
                                           'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                             is_leaf=True , yang_name="ip-address" , parent=self , choice=(u'endpoint-type' , u'ip') ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='inet:ip-address' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ip_address must be of a type compatible with inet:ip-address""" ,
                'defined-type': "inet:ip-address" ,
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, choice=(u'endpoint-type', u'ip'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)""" ,
            })

        self.__ip_address = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ip_address(self):
        self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                               RestrictedClassType(base_type=unicode , restriction_dict={
                                                   'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                         is_leaf=True , yang_name="ip-address" , parent=self ,
                                         choice=(u'endpoint-type' , u'ip') , path_helper=self._path_helper ,
                                         extmethods=self._extmethods , register_paths=True ,
                                         namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                         yang_type='inet:ip-address' , is_config=True)

    def _get_vdu_id(self):
        """
    Getter method for vdu_id, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/vdu_id (leafref)
    """
        return self.__vdu_id

    def _set_vdu_id(self , v , load=False):
        """
    Setter method for vdu_id, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/vdu_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_id() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vdu-id" , parent=self ,
                             choice=(u'endpoint-type' , u'vdu-id') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vdu_id must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vdu-id", parent=self, choice=(u'endpoint-type', u'vdu-id'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vdu_id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vdu_id(self):
        self.__vdu_id = YANGDynClass(base=unicode , is_leaf=True , yang_name="vdu-id" , parent=self ,
                                     choice=(u'endpoint-type' , u'vdu-id') , path_helper=self._path_helper ,
                                     extmethods=self._extmethods , register_paths=True ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                     yang_type='leafref' , is_config=True)

    def _get_cp(self):
        """
    Getter method for cp, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/cp (leafref)
    """
        return self.__cp

    def _set_cp(self , v , load=False):
        """
    Setter method for cp, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/cp (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cp() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="cp" , parent=self ,
                             choice=(u'endpoint-type' , u'cp') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """cp must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cp", parent=self, choice=(u'endpoint-type', u'cp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__cp = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_cp(self):
        self.__cp = YANGDynClass(base=unicode , is_leaf=True , yang_name="cp" , parent=self ,
                                 choice=(u'endpoint-type' , u'cp') , path_helper=self._path_helper ,
                                 extmethods=self._extmethods , register_paths=True ,
                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                 yang_type='leafref' , is_config=True)

    def _get_port(self):
        """
    Getter method for port, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/port (inet:port-number)

    YANG Description: Port for the management interface.
    """
        return self.__port

    def _set_port(self , v , load=False):
        """
    Setter method for port, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: Port for the management interface.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(
                base_type=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
                restriction_dict={'range': [u'0..65535']}) , is_leaf=True , yang_name="port" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='inet:port-number' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """port must be of a type compatible with inet:port-number""" ,
                'defined-type': "inet:port-number" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='inet:port-number', is_config=True)""" ,
            })

        self.__port = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_port(self):
        self.__port = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
            restriction_dict={'range': [u'0..65535']}) , is_leaf=True , yang_name="port" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='inet:port-number' , is_config=True)

    def _get_dashboard_params(self):
        """
    Getter method for dashboard_params, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/dashboard_params (container)

    YANG Description: Parameters for the VNF dashboard
    """
        return self.__dashboard_params

    def _set_dashboard_params(self , v , load=False):
        """
    Setter method for dashboard_params, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface/dashboard_params (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dashboard_params is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dashboard_params() directly.

    YANG Description: Parameters for the VNF dashboard
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_dashboard_params_vnfd__vnfd_catalog_vnfd_mgmt_interface_dashboard_params ,
                             is_container='container' , yang_name="dashboard-params" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """dashboard_params must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_dashboard_params_vnfd__vnfd_catalog_vnfd_mgmt_interface_dashboard_params, is_container='container', yang_name="dashboard-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__dashboard_params = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_dashboard_params(self):
        self.__dashboard_params = YANGDynClass(
            base=yc_dashboard_params_vnfd__vnfd_catalog_vnfd_mgmt_interface_dashboard_params ,
            is_container='container' , yang_name="dashboard-params" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)

    ip_address = __builtin__.property(_get_ip_address , _set_ip_address)
    vdu_id = __builtin__.property(_get_vdu_id , _set_vdu_id)
    cp = __builtin__.property(_get_cp , _set_cp)
    port = __builtin__.property(_get_port , _set_port)
    dashboard_params = __builtin__.property(_get_dashboard_params , _set_dashboard_params)

    __choices__ = {u'endpoint-type': {u'ip': [u'ip_address'] , u'cp': [u'cp'] , u'vdu-id': [u'vdu_id']}}
    _pyangbind_elements = {'ip_address': ip_address , 'vdu_id': vdu_id , 'cp': cp , 'port': port ,
                           'dashboard_params': dashboard_params , }


class yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_internal_vld_internal_connection_point(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/internal-vld/internal-connection-point. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of internal connection points in this VLD
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__id_ref' , '__ip_address' ,)

    _yang_name = 'internal-connection-point'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="id-ref" , parent=self ,
                                     path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                     is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                     defining_module='vnfd' , yang_type='leafref' , is_config=True)
        self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                               RestrictedClassType(base_type=unicode , restriction_dict={
                                                   'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                         is_leaf=True , yang_name="ip-address" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='inet:ip-address' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'internal-vld' , u'internal-connection-point']

    def _get_id_ref(self):
        """
    Getter method for id_ref, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/internal_connection_point/id_ref (leafref)

    YANG Description: Reference to the internal connection point id
    """
        return self.__id_ref

    def _set_id_ref(self , v , load=False):
        """
    Setter method for id_ref, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/internal_connection_point/id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id_ref() directly.

    YANG Description: Reference to the internal connection point id
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="id-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """id_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__id_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_id_ref(self):
        self.__id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="id-ref" , parent=self ,
                                     path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                     is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                     defining_module='vnfd' , yang_type='leafref' , is_config=True)

    def _get_ip_address(self):
        """
    Getter method for ip_address, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/internal_connection_point/ip_address (inet:ip-address)

    YANG Description: IP address of the internal connection point
    """
        return self.__ip_address

    def _set_ip_address(self , v , load=False):
        """
    Setter method for ip_address, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/internal_connection_point/ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.

    YANG Description: IP address of the internal connection point
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=[RestrictedClassType(base_type=unicode , restriction_dict={
                'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                       RestrictedClassType(base_type=unicode , restriction_dict={
                                           'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                             is_leaf=True , yang_name="ip-address" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='inet:ip-address' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ip_address must be of a type compatible with inet:ip-address""" ,
                'defined-type': "inet:ip-address" ,
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)""" ,
            })

        self.__ip_address = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ip_address(self):
        self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                               RestrictedClassType(base_type=unicode , restriction_dict={
                                                   'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                         is_leaf=True , yang_name="ip-address" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='inet:ip-address' , is_config=True)

    id_ref = __builtin__.property(_get_id_ref , _set_id_ref)
    ip_address = __builtin__.property(_get_ip_address , _set_ip_address)

    _pyangbind_elements = {'id_ref': id_ref , 'ip_address': ip_address , }


class yc_provider_network_vnfd__vnfd_catalog_vnfd_internal_vld_provider_network(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/internal-vld/provider-network. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the provider network.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__physical_network' , '__segmentation_id' ,)

    _yang_name = 'provider-network'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__segmentation_id = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="segmentation_id" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)
        self.__physical_network = YANGDynClass(base=unicode , is_leaf=True , yang_name="physical-network" ,
                                               parent=self , path_helper=self._path_helper ,
                                               extmethods=self._extmethods , register_paths=True ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                               defining_module='vnfd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'internal-vld' , u'provider-network']

    def _get_physical_network(self):
        """
    Getter method for physical_network, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/provider_network/physical_network (string)

    YANG Description: Name of the physical network on which the provider
network is built.
    """
        return self.__physical_network

    def _set_physical_network(self , v , load=False):
        """
    Setter method for physical_network, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/provider_network/physical_network (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_network() directly.

    YANG Description: Name of the physical network on which the provider
network is built.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="physical-network" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """physical_network must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="physical-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__physical_network = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_physical_network(self):
        self.__physical_network = YANGDynClass(base=unicode , is_leaf=True , yang_name="physical-network" ,
                                               parent=self , path_helper=self._path_helper ,
                                               extmethods=self._extmethods , register_paths=True ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                               defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_segmentation_id(self):
        """
    Getter method for segmentation_id, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/provider_network/segmentation_id (uint32)

    YANG Description: ID of segregated virtual networks
    """
        return self.__segmentation_id

    def _set_segmentation_id(self , v , load=False):
        """
    Setter method for segmentation_id, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/provider_network/segmentation_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_segmentation_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_segmentation_id() directly.

    YANG Description: ID of segregated virtual networks
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , is_leaf=True , yang_name="segmentation_id" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """segmentation_id must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""" ,
            })

        self.__segmentation_id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_segmentation_id(self):
        self.__segmentation_id = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="segmentation_id" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)

    physical_network = __builtin__.property(_get_physical_network , _set_physical_network)
    segmentation_id = __builtin__.property(_get_segmentation_id , _set_segmentation_id)

    _pyangbind_elements = {'physical_network': physical_network , 'segmentation_id': segmentation_id , }


class yc_internal_vld_vnfd__vnfd_catalog_vnfd_internal_vld(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/internal-vld. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Internal Virtual Link Descriptors (VLD).
The internal VLD describes the basic topology of
the connectivity such as E-LAN, E-Line, E-Tree.
between internal VNF components of the system.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__id' , '__name' , '__short_name' , '__description' , '__type' ,
                 '__root_bandwidth' , '__leaf_bandwidth' , '__internal_connection_point' , '__provider_network' ,
                 '__vim_network_name' , '__ip_profile_ref' ,)

    _yang_name = 'internal-vld'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__leaf_bandwidth = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="leaf-bandwidth" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)
        self.__internal_connection_point = YANGDynClass(base=YANGListType("id_ref" ,
                                                                          yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_internal_vld_internal_connection_point ,
                                                                          yang_name="internal-connection-point" ,
                                                                          parent=self , is_container='list' ,
                                                                          user_ordered=False ,
                                                                          path_helper=self._path_helper ,
                                                                          yang_keys='id-ref' , extensions=None) ,
                                                        is_container='list' , yang_name="internal-connection-point" ,
                                                        parent=self , path_helper=self._path_helper ,
                                                        extmethods=self._extmethods , register_paths=True ,
                                                        extensions=None ,
                                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                        defining_module='vnfd' , yang_type='list' , is_config=True)
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__short_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__root_bandwidth = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="root-bandwidth" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)
        self.__provider_network = YANGDynClass(
            base=yc_provider_network_vnfd__vnfd_catalog_vnfd_internal_vld_provider_network , is_container='container' ,
            yang_name="provider-network" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='container' , is_config=True)
        self.__ip_profile_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="ip-profile-ref" , parent=self ,
                                             choice=(u'init-params' , u'vim-network-profile') ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__vim_network_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="vim-network-name" ,
                                               parent=self , choice=(u'init-params' , u'vim-network-ref') ,
                                               path_helper=self._path_helper , extmethods=self._extmethods ,
                                               register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                               defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                            restriction_arg={u'ELAN': {} , u'ELINE': {}} , ) ,
                                   is_leaf=True , yang_name="type" , parent=self , path_helper=self._path_helper ,
                                   extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='manotypes:virtual-link-type' , is_config=True)
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                 defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'internal-vld']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/id (string)

    YANG Description: Identifier for the VLD
    """
        return self.__id

    def _set_id(self , v , load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the VLD
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                 defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/name (string)

    YANG Description: Name of the internal VLD
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the internal VLD
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)

    def _get_short_name(self):
        """
    Getter method for short_name, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/short_name (string)

    YANG Description: Short name to appear as label in the UI
    """
        return self.__short_name

    def _set_short_name(self , v , load=False):
        """
    Setter method for short_name, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.

    YANG Description: Short name to appear as label in the UI
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """short_name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__short_name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_short_name(self):
        self.__short_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/description (string)
    """
        return self.__description

    def _set_description(self , v , load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__description = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_type(self):
        """
    Getter method for type, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/type (manotypes:virtual-link-type)
    """
        return self.__type

    def _set_type(self , v , load=False):
        """
    Setter method for type, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/type (manotypes:virtual-link-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'ELAN': {} , u'ELINE': {}} , ) ,
                             is_leaf=True , yang_name="type" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='manotypes:virtual-link-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """type must be of a type compatible with manotypes:virtual-link-type""" ,
                'defined-type': "manotypes:virtual-link-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ELAN': {}, u'ELINE': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='manotypes:virtual-link-type', is_config=True)""" ,
            })

        self.__type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                            restriction_arg={u'ELAN': {} , u'ELINE': {}} , ) ,
                                   is_leaf=True , yang_name="type" , parent=self , path_helper=self._path_helper ,
                                   extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='manotypes:virtual-link-type' , is_config=True)

    def _get_root_bandwidth(self):
        """
    Getter method for root_bandwidth, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/root_bandwidth (uint64)

    YANG Description: For ELAN this is the aggregate bandwidth.
    """
        return self.__root_bandwidth

    def _set_root_bandwidth(self , v , load=False):
        """
    Setter method for root_bandwidth, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/root_bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root_bandwidth() directly.

    YANG Description: For ELAN this is the aggregate bandwidth.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="root-bandwidth" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """root_bandwidth must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__root_bandwidth = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_root_bandwidth(self):
        self.__root_bandwidth = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="root-bandwidth" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

    def _get_leaf_bandwidth(self):
        """
    Getter method for leaf_bandwidth, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/leaf_bandwidth (uint64)

    YANG Description: For ELAN this is the bandwidth of branches.
    """
        return self.__leaf_bandwidth

    def _set_leaf_bandwidth(self , v , load=False):
        """
    Setter method for leaf_bandwidth, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/leaf_bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leaf_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leaf_bandwidth() directly.

    YANG Description: For ELAN this is the bandwidth of branches.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="leaf-bandwidth" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """leaf_bandwidth must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="leaf-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__leaf_bandwidth = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_leaf_bandwidth(self):
        self.__leaf_bandwidth = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="leaf-bandwidth" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

    def _get_internal_connection_point(self):
        """
    Getter method for internal_connection_point, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/internal_connection_point (list)

    YANG Description: List of internal connection points in this VLD
    """
        return self.__internal_connection_point

    def _set_internal_connection_point(self , v , load=False):
        """
    Setter method for internal_connection_point, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/internal_connection_point (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_internal_connection_point is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_internal_connection_point() directly.

    YANG Description: List of internal connection points in this VLD
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("id_ref" ,
                                                   yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_internal_vld_internal_connection_point ,
                                                   yang_name="internal-connection-point" , parent=self ,
                                                   is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='id-ref' ,
                                                   extensions=None) , is_container='list' ,
                             yang_name="internal-connection-point" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """internal_connection_point must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("id_ref",yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_internal_vld_internal_connection_point, yang_name="internal-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id-ref', extensions=None), is_container='list', yang_name="internal-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__internal_connection_point = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_internal_connection_point(self):
        self.__internal_connection_point = YANGDynClass(base=YANGListType("id_ref" ,
                                                                          yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_internal_vld_internal_connection_point ,
                                                                          yang_name="internal-connection-point" ,
                                                                          parent=self , is_container='list' ,
                                                                          user_ordered=False ,
                                                                          path_helper=self._path_helper ,
                                                                          yang_keys='id-ref' , extensions=None) ,
                                                        is_container='list' , yang_name="internal-connection-point" ,
                                                        parent=self , path_helper=self._path_helper ,
                                                        extmethods=self._extmethods , register_paths=True ,
                                                        extensions=None ,
                                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                        defining_module='vnfd' , yang_type='list' , is_config=True)

    def _get_provider_network(self):
        """
    Getter method for provider_network, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/provider_network (container)

    YANG Description: Container for the provider network.
    """
        return self.__provider_network

    def _set_provider_network(self , v , load=False):
        """
    Setter method for provider_network, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/provider_network (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provider_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provider_network() directly.

    YANG Description: Container for the provider network.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_provider_network_vnfd__vnfd_catalog_vnfd_internal_vld_provider_network ,
                             is_container='container' , yang_name="provider-network" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """provider_network must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_provider_network_vnfd__vnfd_catalog_vnfd_internal_vld_provider_network, is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__provider_network = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_provider_network(self):
        self.__provider_network = YANGDynClass(
            base=yc_provider_network_vnfd__vnfd_catalog_vnfd_internal_vld_provider_network , is_container='container' ,
            yang_name="provider-network" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='container' , is_config=True)

    def _get_vim_network_name(self):
        """
    Getter method for vim_network_name, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/vim_network_name (string)

    YANG Description: Name of network in VIM account. This is used to indicate
 pre-provisioned network name in cloud account.
    """
        return self.__vim_network_name

    def _set_vim_network_name(self , v , load=False):
        """
    Setter method for vim_network_name, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/vim_network_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vim_network_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vim_network_name() directly.

    YANG Description: Name of network in VIM account. This is used to indicate
 pre-provisioned network name in cloud account.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vim-network-name" , parent=self ,
                             choice=(u'init-params' , u'vim-network-ref') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vim_network_name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vim-network-name", parent=self, choice=(u'init-params', u'vim-network-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__vim_network_name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vim_network_name(self):
        self.__vim_network_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="vim-network-name" ,
                                               parent=self , choice=(u'init-params' , u'vim-network-ref') ,
                                               path_helper=self._path_helper , extmethods=self._extmethods ,
                                               register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                               defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_ip_profile_ref(self):
        """
    Getter method for ip_profile_ref, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/ip_profile_ref (string)

    YANG Description: Named reference to IP-profile object
    """
        return self.__ip_profile_ref

    def _set_ip_profile_ref(self , v , load=False):
        """
    Setter method for ip_profile_ref, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld/ip_profile_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_profile_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_profile_ref() directly.

    YANG Description: Named reference to IP-profile object
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="ip-profile-ref" , parent=self ,
                             choice=(u'init-params' , u'vim-network-profile') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ip_profile_ref must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="ip-profile-ref", parent=self, choice=(u'init-params', u'vim-network-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__ip_profile_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ip_profile_ref(self):
        self.__ip_profile_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="ip-profile-ref" , parent=self ,
                                             choice=(u'init-params' , u'vim-network-profile') ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='string' , is_config=True)

    id = __builtin__.property(_get_id , _set_id)
    name = __builtin__.property(_get_name , _set_name)
    short_name = __builtin__.property(_get_short_name , _set_short_name)
    description = __builtin__.property(_get_description , _set_description)
    type = __builtin__.property(_get_type , _set_type)
    root_bandwidth = __builtin__.property(_get_root_bandwidth , _set_root_bandwidth)
    leaf_bandwidth = __builtin__.property(_get_leaf_bandwidth , _set_leaf_bandwidth)
    internal_connection_point = __builtin__.property(_get_internal_connection_point , _set_internal_connection_point)
    provider_network = __builtin__.property(_get_provider_network , _set_provider_network)
    vim_network_name = __builtin__.property(_get_vim_network_name , _set_vim_network_name)
    ip_profile_ref = __builtin__.property(_get_ip_profile_ref , _set_ip_profile_ref)

    __choices__ = {
        u'init-params': {u'vim-network-profile': [u'ip_profile_ref'] , u'vim-network-ref': [u'vim_network_name']}}
    _pyangbind_elements = {'id': id , 'name': name , 'short_name': short_name , 'description': description ,
                           'type': type , 'root_bandwidth': root_bandwidth , 'leaf_bandwidth': leaf_bandwidth ,
                           'internal_connection_point': internal_connection_point ,
                           'provider_network': provider_network , 'vim_network_name': vim_network_name ,
                           'ip_profile_ref': ip_profile_ref , }


class yc_dns_server_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dns_server(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/ip-profiles/ip-profile-params/dns-server. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__address' ,)

    _yang_name = 'dns-server'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                            RestrictedClassType(base_type=unicode , restriction_dict={
                                                'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                      is_leaf=True , yang_name="address" , parent=self , path_helper=self._path_helper ,
                                      extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                      yang_type='inet:ip-address' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'ip-profiles' , u'ip-profile-params' , u'dns-server']

    def _get_address(self):
        """
    Getter method for address, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dns_server/address (inet:ip-address)

    YANG Description: List of DNS Servers associated with IP Profile
    """
        return self.__address

    def _set_address(self , v , load=False):
        """
    Setter method for address, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dns_server/address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: List of DNS Servers associated with IP Profile
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=[RestrictedClassType(base_type=unicode , restriction_dict={
                'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                       RestrictedClassType(base_type=unicode , restriction_dict={
                                           'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                             is_leaf=True , yang_name="address" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='inet:ip-address' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """address must be of a type compatible with inet:ip-address""" ,
                'defined-type': "inet:ip-address" ,
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)""" ,
            })

        self.__address = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_address(self):
        self.__address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                            RestrictedClassType(base_type=unicode , restriction_dict={
                                                'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                      is_leaf=True , yang_name="address" , parent=self , path_helper=self._path_helper ,
                                      extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                      yang_type='inet:ip-address' , is_config=True)

    address = __builtin__.property(_get_address , _set_address)

    _pyangbind_elements = {'address': address , }


class yc_dhcp_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dhcp_params(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/ip-profiles/ip-profile-params/dhcp-params. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__enabled' , '__start_address' , '__count' ,)

    _yang_name = 'dhcp-params'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__start_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                                  RestrictedClassType(base_type=unicode , restriction_dict={
                                                      'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                            is_leaf=True , yang_name="start-address" , parent=self ,
                                            path_helper=self._path_helper , extmethods=self._extmethods ,
                                            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                            defining_module='vnfd' , yang_type='inet:ip-address' , is_config=True)
        self.__count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)
        self.__enabled = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="enabled" ,
                                      parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                      defining_module='vnfd' , yang_type='boolean' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'ip-profiles' , u'ip-profile-params' , u'dhcp-params']

    def _get_enabled(self):
        """
    Getter method for enabled, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dhcp_params/enabled (boolean)

    YANG Description: This flag indicates if DHCP is enabled or not
    """
        return self.__enabled

    def _set_enabled(self , v , load=False):
        """
    Setter method for enabled, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dhcp_params/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This flag indicates if DHCP is enabled or not
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="enabled" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """enabled must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__enabled = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_enabled(self):
        self.__enabled = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="enabled" ,
                                      parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                      defining_module='vnfd' , yang_type='boolean' , is_config=True)

    def _get_start_address(self):
        """
    Getter method for start_address, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dhcp_params/start_address (inet:ip-address)

    YANG Description: Start IP address of the IP-Address range associated with DHCP domain
    """
        return self.__start_address

    def _set_start_address(self , v , load=False):
        """
    Setter method for start_address, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dhcp_params/start_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_address() directly.

    YANG Description: Start IP address of the IP-Address range associated with DHCP domain
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=[RestrictedClassType(base_type=unicode , restriction_dict={
                'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                       RestrictedClassType(base_type=unicode , restriction_dict={
                                           'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                             is_leaf=True , yang_name="start-address" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='inet:ip-address' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """start_address must be of a type compatible with inet:ip-address""" ,
                'defined-type': "inet:ip-address" ,
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)""" ,
            })

        self.__start_address = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_start_address(self):
        self.__start_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                                  RestrictedClassType(base_type=unicode , restriction_dict={
                                                      'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                            is_leaf=True , yang_name="start-address" , parent=self ,
                                            path_helper=self._path_helper , extmethods=self._extmethods ,
                                            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                            defining_module='vnfd' , yang_type='inet:ip-address' , is_config=True)

    def _get_count(self):
        """
    Getter method for count, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dhcp_params/count (uint32)

    YANG Description: Size of the DHCP pool associated with DHCP domain
    """
        return self.__count

    def _set_count(self , v , load=False):
        """
    Setter method for count, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dhcp_params/count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.

    YANG Description: Size of the DHCP pool associated with DHCP domain
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , is_leaf=True , yang_name="count" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """count must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""" ,
            })

        self.__count = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_count(self):
        self.__count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)

    enabled = __builtin__.property(_get_enabled , _set_enabled)
    start_address = __builtin__.property(_get_start_address , _set_start_address)
    count = __builtin__.property(_get_count , _set_count)

    _pyangbind_elements = {'enabled': enabled , 'start_address': start_address , 'count': count , }


class yc_ip_profile_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/ip-profiles/ip-profile-params. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__ip_version' , '__subnet_address' , '__gateway_address' , '__security_group' ,
    '__dns_server' , '__dhcp_params' , '__subnet_prefix_pool' ,)

    _yang_name = 'ip-profile-params'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__dhcp_params = YANGDynClass(
            base=yc_dhcp_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dhcp_params ,
            is_container='container' , yang_name="dhcp-params" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)
        self.__dns_server = YANGDynClass(base=YANGListType("address" ,
                                                           yc_dns_server_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dns_server ,
                                                           yang_name="dns-server" , parent=self , is_container='list' ,
                                                           user_ordered=False , path_helper=self._path_helper ,
                                                           yang_keys='address' , extensions=None) ,
                                         is_container='list' , yang_name="dns-server" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , extensions=None ,
                                         namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                         yang_type='list' , is_config=True)
        self.__gateway_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                                    RestrictedClassType(base_type=unicode , restriction_dict={
                                                        'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                              is_leaf=True , yang_name="gateway-address" , parent=self ,
                                              path_helper=self._path_helper , extmethods=self._extmethods ,
                                              register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                              defining_module='vnfd' , yang_type='inet:ip-address' , is_config=True)
        self.__subnet_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}) ,
                                                   RestrictedClassType(base_type=unicode , restriction_dict={
                                                       'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}) , ] ,
                                             is_leaf=True , yang_name="subnet-address" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='inet:ip-prefix' , is_config=True)
        self.__subnet_prefix_pool = YANGDynClass(base=unicode , is_leaf=True , yang_name="subnet-prefix-pool" ,
                                                 parent=self , path_helper=self._path_helper ,
                                                 extmethods=self._extmethods , register_paths=True ,
                                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                 defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__security_group = YANGDynClass(base=unicode , is_leaf=True , yang_name="security-group" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                  restriction_arg={u'unknown': {'value': 0} ,
                                                                                   u'ipv4': {'value': 1} ,
                                                                                   u'ipv6': {'value': 2}} , ) ,
                                         default=unicode("ipv4") , is_leaf=True , yang_name="ip-version" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='inet:ip-version' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'ip-profiles' , u'ip-profile-params']

    def _get_ip_version(self):
        """
    Getter method for ip_version, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/ip_version (inet:ip-version)
    """
        return self.__ip_version

    def _set_ip_version(self , v , load=False):
        """
    Setter method for ip_version, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/ip_version (inet:ip-version)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_version() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'unknown': {'value': 0} ,
                                                                           u'ipv4': {'value': 1} ,
                                                                           u'ipv6': {'value': 2}} , ) ,
                             default=unicode("ipv4") , is_leaf=True , yang_name="ip-version" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='inet:ip-version' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ip_version must be of a type compatible with inet:ip-version""" ,
                'defined-type': "inet:ip-version" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {'value': 0}, u'ipv4': {'value': 1}, u'ipv6': {'value': 2}},), default=unicode("ipv4"), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='inet:ip-version', is_config=True)""" ,
            })

        self.__ip_version = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ip_version(self):
        self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                  restriction_arg={u'unknown': {'value': 0} ,
                                                                                   u'ipv4': {'value': 1} ,
                                                                                   u'ipv6': {'value': 2}} , ) ,
                                         default=unicode("ipv4") , is_leaf=True , yang_name="ip-version" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='inet:ip-version' , is_config=True)

    def _get_subnet_address(self):
        """
    Getter method for subnet_address, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/subnet_address (inet:ip-prefix)

    YANG Description: Subnet IP prefix associated with IP Profile
    """
        return self.__subnet_address

    def _set_subnet_address(self , v , load=False):
        """
    Setter method for subnet_address, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/subnet_address (inet:ip-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subnet_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subnet_address() directly.

    YANG Description: Subnet IP prefix associated with IP Profile
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=[RestrictedClassType(base_type=unicode , restriction_dict={
                'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}) ,
                                       RestrictedClassType(base_type=unicode , restriction_dict={
                                           'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}) , ] ,
                             is_leaf=True , yang_name="subnet-address" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='inet:ip-prefix' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """subnet_address must be of a type compatible with inet:ip-prefix""" ,
                'defined-type': "inet:ip-prefix" ,
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='inet:ip-prefix', is_config=True)""" ,
            })

        self.__subnet_address = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_subnet_address(self):
        self.__subnet_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}) ,
                                                   RestrictedClassType(base_type=unicode , restriction_dict={
                                                       'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}) , ] ,
                                             is_leaf=True , yang_name="subnet-address" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='inet:ip-prefix' , is_config=True)

    def _get_gateway_address(self):
        """
    Getter method for gateway_address, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/gateway_address (inet:ip-address)

    YANG Description: IP Address of the default gateway associated with IP Profile
    """
        return self.__gateway_address

    def _set_gateway_address(self , v , load=False):
        """
    Setter method for gateway_address, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/gateway_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway_address() directly.

    YANG Description: IP Address of the default gateway associated with IP Profile
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=[RestrictedClassType(base_type=unicode , restriction_dict={
                'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                       RestrictedClassType(base_type=unicode , restriction_dict={
                                           'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                             is_leaf=True , yang_name="gateway-address" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='inet:ip-address' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """gateway_address must be of a type compatible with inet:ip-address""" ,
                'defined-type': "inet:ip-address" ,
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='inet:ip-address', is_config=True)""" ,
            })

        self.__gateway_address = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_gateway_address(self):
        self.__gateway_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                                    RestrictedClassType(base_type=unicode , restriction_dict={
                                                        'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                              is_leaf=True , yang_name="gateway-address" , parent=self ,
                                              path_helper=self._path_helper , extmethods=self._extmethods ,
                                              register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                              defining_module='vnfd' , yang_type='inet:ip-address' , is_config=True)

    def _get_security_group(self):
        """
    Getter method for security_group, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/security_group (string)

    YANG Description: Name of the security group
    """
        return self.__security_group

    def _set_security_group(self , v , load=False):
        """
    Setter method for security_group, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/security_group (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security_group() directly.

    YANG Description: Name of the security group
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="security-group" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """security_group must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="security-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__security_group = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_security_group(self):
        self.__security_group = YANGDynClass(base=unicode , is_leaf=True , yang_name="security-group" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_dns_server(self):
        """
    Getter method for dns_server, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dns_server (list)
    """
        return self.__dns_server

    def _set_dns_server(self , v , load=False):
        """
    Setter method for dns_server, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dns_server (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns_server() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("address" ,
                                                   yc_dns_server_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dns_server ,
                                                   yang_name="dns-server" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='address' , extensions=None) , is_container='list' ,
                             yang_name="dns-server" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """dns_server must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("address",yc_dns_server_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__dns_server = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_dns_server(self):
        self.__dns_server = YANGDynClass(base=YANGListType("address" ,
                                                           yc_dns_server_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dns_server ,
                                                           yang_name="dns-server" , parent=self , is_container='list' ,
                                                           user_ordered=False , path_helper=self._path_helper ,
                                                           yang_keys='address' , extensions=None) ,
                                         is_container='list' , yang_name="dns-server" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , extensions=None ,
                                         namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                         yang_type='list' , is_config=True)

    def _get_dhcp_params(self):
        """
    Getter method for dhcp_params, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dhcp_params (container)
    """
        return self.__dhcp_params

    def _set_dhcp_params(self , v , load=False):
        """
    Setter method for dhcp_params, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/dhcp_params (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_params is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_params() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_dhcp_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dhcp_params ,
                             is_container='container' , yang_name="dhcp-params" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """dhcp_params must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_dhcp_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__dhcp_params = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_dhcp_params(self):
        self.__dhcp_params = YANGDynClass(
            base=yc_dhcp_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params_dhcp_params ,
            is_container='container' , yang_name="dhcp-params" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)

    def _get_subnet_prefix_pool(self):
        """
    Getter method for subnet_prefix_pool, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/subnet_prefix_pool (string)

    YANG Description: VIM Specific reference to pre-created subnet prefix
    """
        return self.__subnet_prefix_pool

    def _set_subnet_prefix_pool(self , v , load=False):
        """
    Setter method for subnet_prefix_pool, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params/subnet_prefix_pool (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subnet_prefix_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subnet_prefix_pool() directly.

    YANG Description: VIM Specific reference to pre-created subnet prefix
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="subnet-prefix-pool" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """subnet_prefix_pool must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="subnet-prefix-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__subnet_prefix_pool = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_subnet_prefix_pool(self):
        self.__subnet_prefix_pool = YANGDynClass(base=unicode , is_leaf=True , yang_name="subnet-prefix-pool" ,
                                                 parent=self , path_helper=self._path_helper ,
                                                 extmethods=self._extmethods , register_paths=True ,
                                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                 defining_module='vnfd' , yang_type='string' , is_config=True)

    ip_version = __builtin__.property(_get_ip_version , _set_ip_version)
    subnet_address = __builtin__.property(_get_subnet_address , _set_subnet_address)
    gateway_address = __builtin__.property(_get_gateway_address , _set_gateway_address)
    security_group = __builtin__.property(_get_security_group , _set_security_group)
    dns_server = __builtin__.property(_get_dns_server , _set_dns_server)
    dhcp_params = __builtin__.property(_get_dhcp_params , _set_dhcp_params)
    subnet_prefix_pool = __builtin__.property(_get_subnet_prefix_pool , _set_subnet_prefix_pool)

    _pyangbind_elements = {'ip_version': ip_version , 'subnet_address': subnet_address ,
                           'gateway_address': gateway_address , 'security_group': security_group ,
                           'dns_server': dns_server , 'dhcp_params': dhcp_params ,
                           'subnet_prefix_pool': subnet_prefix_pool , }


class yc_ip_profiles_vnfd__vnfd_catalog_vnfd_ip_profiles(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/ip-profiles. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of IP Profiles.
  IP Profile describes the IP characteristics for the Virtual-Link
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__description' , '__ip_profile_params' ,)

    _yang_name = 'ip-profiles'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__ip_profile_params = YANGDynClass(
            base=yc_ip_profile_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params , is_container='container' ,
            yang_name="ip-profile-params" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='container' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'ip-profiles']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/name (string)

    YANG Description: Name of the IP-Profile
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the IP-Profile
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/description (string)

    YANG Description: Description for IP profile
    """
        return self.__description

    def _set_description(self , v , load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description for IP profile
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__description = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_ip_profile_params(self):
        """
    Getter method for ip_profile_params, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params (container)
    """
        return self.__ip_profile_params

    def _set_ip_profile_params(self , v , load=False):
        """
    Setter method for ip_profile_params, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles/ip_profile_params (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_profile_params is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_profile_params() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_ip_profile_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params ,
                             is_container='container' , yang_name="ip-profile-params" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ip_profile_params must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_ip_profile_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params, is_container='container', yang_name="ip-profile-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__ip_profile_params = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ip_profile_params(self):
        self.__ip_profile_params = YANGDynClass(
            base=yc_ip_profile_params_vnfd__vnfd_catalog_vnfd_ip_profiles_ip_profile_params , is_container='container' ,
            yang_name="ip-profile-params" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='container' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    description = __builtin__.property(_get_description , _set_description)
    ip_profile_params = __builtin__.property(_get_ip_profile_params , _set_ip_profile_params)

    _pyangbind_elements = {'name': name , 'description': description , 'ip_profile_params': ip_profile_params , }


class yc_connection_point_vnfd__vnfd_catalog_vnfd_connection_point(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/connection-point. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List for external connection points. Each VNF has one
or more external connection points that connect the VNF
to other VNFs or to external networks. Each VNF exposes
connection points to the orchestrator, which can construct
network services by connecting the connection points
between different VNFs. The NFVO will use VLDs and VNFFGs
at the network service level to construct network services.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__name' , '__id' , '__short_name' , '__type' , '__port_security_enabled' ,
    '__internal_vld_ref' ,)

    _yang_name = 'connection-point'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__short_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__internal_vld_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="internal-vld-ref" ,
                                               parent=self , path_helper=self._path_helper ,
                                               extmethods=self._extmethods , register_paths=True ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                               defining_module='vnfd' , yang_type='leafref' , is_config=True)
        self.__port_security_enabled = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True ,
                                                    yang_name="port-security-enabled" , parent=self ,
                                                    path_helper=self._path_helper , extmethods=self._extmethods ,
                                                    register_paths=True ,
                                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                    defining_module='vnfd' , yang_type='boolean' , is_config=True)
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                            restriction_arg={u'VPORT': {}} , ) , is_leaf=True ,
                                   yang_name="type" , parent=self , path_helper=self._path_helper ,
                                   extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='manotypes:connection-point-type' , is_config=True)
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                 yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'connection-point']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/name (string)

    YANG Description: Name of the connection point
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the connection point
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/id (string)

    YANG Description: Identifier for the internal connection points
    """
        return self.__id

    def _set_id(self , v , load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the internal connection points
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                 yang_type='string' , is_config=True)

    def _get_short_name(self):
        """
    Getter method for short_name, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/short_name (string)

    YANG Description: Short name to appear as label in the UI
    """
        return self.__short_name

    def _set_short_name(self , v , load=False):
        """
    Setter method for short_name, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.

    YANG Description: Short name to appear as label in the UI
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """short_name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__short_name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_short_name(self):
        self.__short_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_type(self):
        """
    Getter method for type, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/type (manotypes:connection-point-type)

    YANG Description: Type of the connection point.
    """
        return self.__type

    def _set_type(self , v , load=False):
        """
    Setter method for type, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/type (manotypes:connection-point-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the connection point.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'VPORT': {}} , ) , is_leaf=True ,
                             yang_name="type" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='manotypes:connection-point-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """type must be of a type compatible with manotypes:connection-point-type""" ,
                'defined-type': "manotypes:connection-point-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'VPORT': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='manotypes:connection-point-type', is_config=True)""" ,
            })

        self.__type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                            restriction_arg={u'VPORT': {}} , ) , is_leaf=True ,
                                   yang_name="type" , parent=self , path_helper=self._path_helper ,
                                   extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='manotypes:connection-point-type' , is_config=True)

    def _get_port_security_enabled(self):
        """
    Getter method for port_security_enabled, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/port_security_enabled (boolean)

    YANG Description: Enables the port security for the port.
    """
        return self.__port_security_enabled

    def _set_port_security_enabled(self , v , load=False):
        """
    Setter method for port_security_enabled, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/port_security_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_security_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_security_enabled() directly.

    YANG Description: Enables the port security for the port.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("true") , is_leaf=True ,
                             yang_name="port-security-enabled" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """port_security_enabled must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="port-security-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__port_security_enabled = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_port_security_enabled(self):
        self.__port_security_enabled = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True ,
                                                    yang_name="port-security-enabled" , parent=self ,
                                                    path_helper=self._path_helper , extmethods=self._extmethods ,
                                                    register_paths=True ,
                                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                    defining_module='vnfd' , yang_type='boolean' , is_config=True)

    def _get_internal_vld_ref(self):
        """
    Getter method for internal_vld_ref, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/internal_vld_ref (leafref)

    YANG Description: Reference to an internal VLD of the VNF. This field is
optional. It allows exposing an internal VLD through a
connection point. When building a NS, this VNF CP might be
connected to a NS VLD, then both VLDs (the i-VLD of the VNF and the
VLD of the NS) will become the same network and the IP profile will
be the one configured at NS level.
    """
        return self.__internal_vld_ref

    def _set_internal_vld_ref(self , v , load=False):
        """
    Setter method for internal_vld_ref, mapped from YANG variable /vnfd_catalog/vnfd/connection_point/internal_vld_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_internal_vld_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_internal_vld_ref() directly.

    YANG Description: Reference to an internal VLD of the VNF. This field is
optional. It allows exposing an internal VLD through a
connection point. When building a NS, this VNF CP might be
connected to a NS VLD, then both VLDs (the i-VLD of the VNF and the
VLD of the NS) will become the same network and the IP profile will
be the one configured at NS level.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="internal-vld-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """internal_vld_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="internal-vld-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__internal_vld_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_internal_vld_ref(self):
        self.__internal_vld_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="internal-vld-ref" ,
                                               parent=self , path_helper=self._path_helper ,
                                               extmethods=self._extmethods , register_paths=True ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                               defining_module='vnfd' , yang_type='leafref' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    id = __builtin__.property(_get_id , _set_id)
    short_name = __builtin__.property(_get_short_name , _set_short_name)
    type = __builtin__.property(_get_type , _set_type)
    port_security_enabled = __builtin__.property(_get_port_security_enabled , _set_port_security_enabled)
    internal_vld_ref = __builtin__.property(_get_internal_vld_ref , _set_internal_vld_ref)

    _pyangbind_elements = {'name': name , 'id': id , 'short_name': short_name , 'type': type ,
                           'port_security_enabled': port_security_enabled , 'internal_vld_ref': internal_vld_ref , }


class yc_vm_flavor_vnfd__vnfd_catalog_vnfd_vdu_vm_flavor(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vm-flavor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__vcpu_count' , '__memory_mb' , '__storage_gb' ,)

    _yang_name = 'vm-flavor'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__memory_mb = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="memory-mb" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)
        self.__vcpu_count = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
            is_leaf=True , yang_name="vcpu-count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint16' , is_config=True)
        self.__storage_gb = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="storage-gb" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'vm-flavor']

    def _get_vcpu_count(self):
        """
    Getter method for vcpu_count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vm_flavor/vcpu_count (uint16)

    YANG Description: Number of VCPUs for the VM.
    """
        return self.__vcpu_count

    def _set_vcpu_count(self , v , load=False):
        """
    Setter method for vcpu_count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vm_flavor/vcpu_count (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vcpu_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vcpu_count() directly.

    YANG Description: Number of VCPUs for the VM.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} ,
                                                          int_size=16) , is_leaf=True , yang_name="vcpu-count" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint16' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vcpu_count must be of a type compatible with uint16""" ,
                'defined-type': "uint16" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="vcpu-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint16', is_config=True)""" ,
            })

        self.__vcpu_count = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vcpu_count(self):
        self.__vcpu_count = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
            is_leaf=True , yang_name="vcpu-count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint16' , is_config=True)

    def _get_memory_mb(self):
        """
    Getter method for memory_mb, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vm_flavor/memory_mb (uint64)

    YANG Description: Amount of memory in MB.
    """
        return self.__memory_mb

    def _set_memory_mb(self , v , load=False):
        """
    Setter method for memory_mb, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vm_flavor/memory_mb (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory_mb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory_mb() directly.

    YANG Description: Amount of memory in MB.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="memory-mb" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """memory_mb must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="memory-mb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__memory_mb = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_memory_mb(self):
        self.__memory_mb = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="memory-mb" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

    def _get_storage_gb(self):
        """
    Getter method for storage_gb, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vm_flavor/storage_gb (uint64)

    YANG Description: Amount of disk space in GB.
    """
        return self.__storage_gb

    def _set_storage_gb(self , v , load=False):
        """
    Setter method for storage_gb, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vm_flavor/storage_gb (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_storage_gb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_storage_gb() directly.

    YANG Description: Amount of disk space in GB.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="storage-gb" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """storage_gb must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="storage-gb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__storage_gb = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_storage_gb(self):
        self.__storage_gb = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="storage-gb" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

    vcpu_count = __builtin__.property(_get_vcpu_count , _set_vcpu_count)
    memory_mb = __builtin__.property(_get_memory_mb , _set_memory_mb)
    storage_gb = __builtin__.property(_get_storage_gb , _set_storage_gb)

    _pyangbind_elements = {'vcpu_count': vcpu_count , 'memory_mb': memory_mb , 'storage_gb': storage_gb , }


class yc_pcie_device_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_pcie_device(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa/pcie-device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of pcie passthrough devices.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__device_id' , '__count' ,)

    _yang_name = 'pcie-device'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="count" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)
        self.__device_id = YANGDynClass(base=unicode , is_leaf=True , yang_name="device-id" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , is_keyval=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'guest-epa' , u'pcie-device']

    def _get_device_id(self):
        """
    Getter method for device_id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/pcie_device/device_id (string)

    YANG Description: Device identifier.
    """
        return self.__device_id

    def _set_device_id(self , v , load=False):
        """
    Setter method for device_id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/pcie_device/device_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_id() directly.

    YANG Description: Device identifier.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="device-id" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """device_id must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="device-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__device_id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_device_id(self):
        self.__device_id = YANGDynClass(base=unicode , is_leaf=True , yang_name="device-id" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , is_keyval=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='string' , is_config=True)

    def _get_count(self):
        """
    Getter method for count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/pcie_device/count (uint64)

    YANG Description: Number of devices to attach to the VM.
    """
        return self.__count

    def _set_count(self , v , load=False):
        """
    Setter method for count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/pcie_device/count (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.

    YANG Description: Number of devices to attach to the VM.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="count" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """count must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__count = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_count(self):
        self.__count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="count" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

    device_id = __builtin__.property(_get_device_id , _set_device_id)
    count = __builtin__.property(_get_count , _set_count)

    _pyangbind_elements = {'device_id': device_id , 'count': count , }


class yc_vcpu_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_vcpu(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa/numa-node-policy/node/vcpu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VCPUs to allocate on
this NUMA node.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__id' ,)

    _yang_name = 'vcpu'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="id" , parent=self ,
            choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint64' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'guest-epa' , u'numa-node-policy' , u'node' , u'vcpu']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/vcpu/id (uint64)

    YANG Description: List of VCPUs ids to allocate on
this NUMA node
    """
        return self.__id

    def _set_id(self , v , load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/vcpu/id (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: List of VCPUs ids to allocate on
this NUMA node
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="id" , parent=self ,
                             choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="id", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="id" , parent=self ,
            choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint64' , is_config=True)

    id = __builtin__.property(_get_id , _set_id)

    __choices__ = {u'numa-policy': {u'numa-aware': [u'id']}}
    _pyangbind_elements = {'id': id , }


class yc_paired_thread_ids_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads_paired_thread_ids(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa/numa-node-policy/node/paired-threads/paired-thread-ids. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of thread pairs to use in case of paired-thread NUMA
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__thread_a' , '__thread_b' ,)

    _yang_name = 'paired-thread-ids'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__thread_a = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="thread-a" , parent=self , choice=(u'om-numa-type' , u'paired-threads') ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , is_keyval=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint8' ,
            is_config=True)
        self.__thread_b = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="thread-b" , parent=self , choice=(u'om-numa-type' , u'paired-threads') ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint8' ,
            is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'guest-epa' , u'numa-node-policy' , u'node' ,
                    u'paired-threads' , u'paired-thread-ids']

    def _get_thread_a(self):
        """
    Getter method for thread_a, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads/paired_thread_ids/thread_a (uint8)
    """
        return self.__thread_a

    def _set_thread_a(self , v , load=False):
        """
    Setter method for thread_a, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads/paired_thread_ids/thread_a (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_thread_a is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_thread_a() directly.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} ,
                                                          int_size=8) , is_leaf=True , yang_name="thread-a" ,
                             parent=self , choice=(u'om-numa-type' , u'paired-threads') ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint8' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """thread_a must be of a type compatible with uint8""" ,
                'defined-type': "uint8" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="thread-a", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)""" ,
            })

        self.__thread_a = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_thread_a(self):
        self.__thread_a = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="thread-a" , parent=self , choice=(u'om-numa-type' , u'paired-threads') ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , is_keyval=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint8' ,
            is_config=True)

    def _get_thread_b(self):
        """
    Getter method for thread_b, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads/paired_thread_ids/thread_b (uint8)
    """
        return self.__thread_b

    def _set_thread_b(self , v , load=False):
        """
    Setter method for thread_b, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads/paired_thread_ids/thread_b (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_thread_b is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_thread_b() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} ,
                                                          int_size=8) , is_leaf=True , yang_name="thread-b" ,
                             parent=self , choice=(u'om-numa-type' , u'paired-threads') ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint8' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """thread_b must be of a type compatible with uint8""" ,
                'defined-type': "uint8" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="thread-b", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)""" ,
            })

        self.__thread_b = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_thread_b(self):
        self.__thread_b = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="thread-b" , parent=self , choice=(u'om-numa-type' , u'paired-threads') ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint8' ,
            is_config=True)

    thread_a = __builtin__.property(_get_thread_a , _set_thread_a)
    thread_b = __builtin__.property(_get_thread_b , _set_thread_b)

    __choices__ = {u'om-numa-type': {u'paired-threads': [u'thread_a' , u'thread_b']}}
    _pyangbind_elements = {'thread_a': thread_a , 'thread_b': thread_b , }


class yc_paired_threads_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa/numa-node-policy/node/paired-threads. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__num_paired_threads' , '__paired_thread_ids' ,)

    _yang_name = 'paired-threads'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__num_paired_threads = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="num-paired-threads" , parent=self , choice=(u'om-numa-type' , u'paired-threads') ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint8' ,
            is_config=True)
        self.__paired_thread_ids = YANGDynClass(base=YANGListType("thread_a" ,
                                                                  yc_paired_thread_ids_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads_paired_thread_ids ,
                                                                  yang_name="paired-thread-ids" , parent=self ,
                                                                  is_container='list' , user_ordered=False ,
                                                                  path_helper=self._path_helper , yang_keys='thread-a' ,
                                                                  extensions=None ,
                                                                  choice=(u'om-numa-type' , u'paired-threads')) ,
                                                is_container='list' , yang_name="paired-thread-ids" , parent=self ,
                                                choice=(u'om-numa-type' , u'paired-threads') ,
                                                path_helper=self._path_helper , extmethods=self._extmethods ,
                                                register_paths=True , extensions=None ,
                                                namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                defining_module='vnfd' , yang_type='list' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'guest-epa' , u'numa-node-policy' , u'node' ,
                    u'paired-threads']

    def _get_num_paired_threads(self):
        """
    Getter method for num_paired_threads, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads/num_paired_threads (uint8)
    """
        return self.__num_paired_threads

    def _set_num_paired_threads(self , v , load=False):
        """
    Setter method for num_paired_threads, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads/num_paired_threads (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_paired_threads is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_paired_threads() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} ,
                                                          int_size=8) , is_leaf=True , yang_name="num-paired-threads" ,
                             parent=self , choice=(u'om-numa-type' , u'paired-threads') ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint8' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """num_paired_threads must be of a type compatible with uint8""" ,
                'defined-type': "uint8" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-paired-threads", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)""" ,
            })

        self.__num_paired_threads = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_num_paired_threads(self):
        self.__num_paired_threads = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="num-paired-threads" , parent=self , choice=(u'om-numa-type' , u'paired-threads') ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint8' ,
            is_config=True)

    def _get_paired_thread_ids(self):
        """
    Getter method for paired_thread_ids, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads/paired_thread_ids (list)

    YANG Description: List of thread pairs to use in case of paired-thread NUMA
    """
        return self.__paired_thread_ids

    def _set_paired_thread_ids(self , v , load=False):
        """
    Setter method for paired_thread_ids, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads/paired_thread_ids (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_paired_thread_ids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_paired_thread_ids() directly.

    YANG Description: List of thread pairs to use in case of paired-thread NUMA
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("thread_a" ,
                                                   yc_paired_thread_ids_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads_paired_thread_ids ,
                                                   yang_name="paired-thread-ids" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='thread-a' , extensions=None ,
                                                   choice=(u'om-numa-type' , u'paired-threads')) , is_container='list' ,
                             yang_name="paired-thread-ids" , parent=self ,
                             choice=(u'om-numa-type' , u'paired-threads') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """paired_thread_ids must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("thread_a",yc_paired_thread_ids_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads_paired_thread_ids, yang_name="paired-thread-ids", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='thread-a', extensions=None, choice=(u'om-numa-type', u'paired-threads')), is_container='list', yang_name="paired-thread-ids", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__paired_thread_ids = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_paired_thread_ids(self):
        self.__paired_thread_ids = YANGDynClass(base=YANGListType("thread_a" ,
                                                                  yc_paired_thread_ids_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads_paired_thread_ids ,
                                                                  yang_name="paired-thread-ids" , parent=self ,
                                                                  is_container='list' , user_ordered=False ,
                                                                  path_helper=self._path_helper , yang_keys='thread-a' ,
                                                                  extensions=None ,
                                                                  choice=(u'om-numa-type' , u'paired-threads')) ,
                                                is_container='list' , yang_name="paired-thread-ids" , parent=self ,
                                                choice=(u'om-numa-type' , u'paired-threads') ,
                                                path_helper=self._path_helper , extmethods=self._extmethods ,
                                                register_paths=True , extensions=None ,
                                                namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                defining_module='vnfd' , yang_type='list' , is_config=True)

    num_paired_threads = __builtin__.property(_get_num_paired_threads , _set_num_paired_threads)
    paired_thread_ids = __builtin__.property(_get_paired_thread_ids , _set_paired_thread_ids)

    __choices__ = {u'om-numa-type': {u'paired-threads': [u'num_paired_threads' , u'paired_thread_ids']}}
    _pyangbind_elements = {'num_paired_threads': num_paired_threads , 'paired_thread_ids': paired_thread_ids , }


class yc_node_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa/numa-node-policy/node. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__id' , '__vcpu' , '__memory_mb' , '__num_cores' , '__paired_threads' ,
    '__num_threads' ,)

    _yang_name = 'node'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__num_threads = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="num-threads" , parent=self , choice=(u'om-numa-type' , u'threads') ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint8' ,
            is_config=True)
        self.__vcpu = YANGDynClass(
            base=YANGListType("id" , yc_vcpu_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_vcpu ,
                              yang_name="vcpu" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='id' , extensions=None ,
                              choice=(u'numa-policy' , u'numa-aware')) , is_container='list' , yang_name="vcpu" ,
            parent=self , choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__num_cores = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="num-cores" , parent=self , choice=(u'om-numa-type' , u'cores') ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint8' ,
            is_config=True)
        self.__memory_mb = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="memory-mb" , parent=self ,
            choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='uint64' , is_config=True)
        self.__paired_threads = YANGDynClass(
            base=yc_paired_threads_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads ,
            is_container='container' , yang_name="paired-threads" , parent=self ,
            choice=(u'om-numa-type' , u'paired-threads') , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='container' , is_config=True)
        self.__id = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="id" , parent=self ,
            choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint64' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'guest-epa' , u'numa-node-policy' , u'node']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/id (uint64)

    YANG Description: NUMA node identification. Typically
it's 0 or 1
    """
        return self.__id

    def _set_id(self , v , load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/id (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: NUMA node identification. Typically
it's 0 or 1
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="id" , parent=self ,
                             choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="id", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="id" , parent=self ,
            choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint64' , is_config=True)

    def _get_vcpu(self):
        """
    Getter method for vcpu, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/vcpu (list)

    YANG Description: List of VCPUs to allocate on
this NUMA node.
    """
        return self.__vcpu

    def _set_vcpu(self , v , load=False):
        """
    Setter method for vcpu, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/vcpu (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vcpu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vcpu() directly.

    YANG Description: List of VCPUs to allocate on
this NUMA node.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("id" ,
                                                   yc_vcpu_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_vcpu ,
                                                   yang_name="vcpu" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper , yang_keys='id' ,
                                                   extensions=None , choice=(u'numa-policy' , u'numa-aware')) ,
                             is_container='list' , yang_name="vcpu" , parent=self ,
                             choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vcpu must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_vcpu_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_vcpu, yang_name="vcpu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=(u'numa-policy', u'numa-aware')), is_container='list', yang_name="vcpu", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__vcpu = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vcpu(self):
        self.__vcpu = YANGDynClass(
            base=YANGListType("id" , yc_vcpu_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_vcpu ,
                              yang_name="vcpu" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='id' , extensions=None ,
                              choice=(u'numa-policy' , u'numa-aware')) , is_container='list' , yang_name="vcpu" ,
            parent=self , choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    def _get_memory_mb(self):
        """
    Getter method for memory_mb, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/memory_mb (uint64)

    YANG Description: Memory size expressed in MB
for this NUMA node.
    """
        return self.__memory_mb

    def _set_memory_mb(self , v , load=False):
        """
    Setter method for memory_mb, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/memory_mb (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory_mb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory_mb() directly.

    YANG Description: Memory size expressed in MB
for this NUMA node.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="memory-mb" ,
                             parent=self , choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """memory_mb must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="memory-mb", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__memory_mb = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_memory_mb(self):
        self.__memory_mb = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="memory-mb" , parent=self ,
            choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='uint64' , is_config=True)

    def _get_num_cores(self):
        """
    Getter method for num_cores, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/num_cores (uint8)
    """
        return self.__num_cores

    def _set_num_cores(self , v , load=False):
        """
    Setter method for num_cores, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/num_cores (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_cores is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_cores() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} ,
                                                          int_size=8) , is_leaf=True , yang_name="num-cores" ,
                             parent=self , choice=(u'om-numa-type' , u'cores') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint8' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """num_cores must be of a type compatible with uint8""" ,
                'defined-type': "uint8" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-cores", parent=self, choice=(u'om-numa-type', u'cores'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)""" ,
            })

        self.__num_cores = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_num_cores(self):
        self.__num_cores = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="num-cores" , parent=self , choice=(u'om-numa-type' , u'cores') ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint8' ,
            is_config=True)

    def _get_paired_threads(self):
        """
    Getter method for paired_threads, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads (container)
    """
        return self.__paired_threads

    def _set_paired_threads(self , v , load=False):
        """
    Setter method for paired_threads, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/paired_threads (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_paired_threads is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_paired_threads() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=yc_paired_threads_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads ,
                             is_container='container' , yang_name="paired-threads" , parent=self ,
                             choice=(u'om-numa-type' , u'paired-threads') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """paired_threads must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_paired_threads_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads, is_container='container', yang_name="paired-threads", parent=self, choice=(u'om-numa-type', u'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__paired_threads = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_paired_threads(self):
        self.__paired_threads = YANGDynClass(
            base=yc_paired_threads_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node_paired_threads ,
            is_container='container' , yang_name="paired-threads" , parent=self ,
            choice=(u'om-numa-type' , u'paired-threads') , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='container' , is_config=True)

    def _get_num_threads(self):
        """
    Getter method for num_threads, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/num_threads (uint8)
    """
        return self.__num_threads

    def _set_num_threads(self , v , load=False):
        """
    Setter method for num_threads, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node/num_threads (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_threads is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_threads() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} ,
                                                          int_size=8) , is_leaf=True , yang_name="num-threads" ,
                             parent=self , choice=(u'om-numa-type' , u'threads') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint8' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """num_threads must be of a type compatible with uint8""" ,
                'defined-type': "uint8" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-threads", parent=self, choice=(u'om-numa-type', u'threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)""" ,
            })

        self.__num_threads = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_num_threads(self):
        self.__num_threads = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="num-threads" , parent=self , choice=(u'om-numa-type' , u'threads') ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint8' ,
            is_config=True)

    id = __builtin__.property(_get_id , _set_id)
    vcpu = __builtin__.property(_get_vcpu , _set_vcpu)
    memory_mb = __builtin__.property(_get_memory_mb , _set_memory_mb)
    num_cores = __builtin__.property(_get_num_cores , _set_num_cores)
    paired_threads = __builtin__.property(_get_paired_threads , _set_paired_threads)
    num_threads = __builtin__.property(_get_num_threads , _set_num_threads)

    __choices__ = {u'om-numa-type': {u'cores': [u'num_cores'] , u'threads': [u'num_threads'] ,
                                     u'paired-threads': [u'paired_threads']} ,
                   u'numa-policy': {u'numa-aware': [u'id' , u'vcpu' , u'memory_mb']}}
    _pyangbind_elements = {'id': id , 'vcpu': vcpu , 'memory_mb': memory_mb , 'num_cores': num_cores ,
                           'paired_threads': paired_threads , 'num_threads': num_threads , }


class yc_numa_node_policy_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa/numa-node-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This policy defines NUMA topology of the
guest. Specifically identifies if the guest
should be run on a host with one NUMA
node or multiple NUMA nodes. As an example
a guest might need 8 VCPUs and 4 GB of
memory. However, it might need the VCPUs
and memory distributed across multiple
NUMA nodes. In this scenario, NUMA node
1 could run with 6 VCPUs and 3GB, and
NUMA node 2 could run with 2 VCPUs and
1GB.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__node_cnt' , '__mem_policy' , '__node' ,)

    _yang_name = 'numa-node-policy'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__node = YANGDynClass(
            base=YANGListType("id" , yc_node_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node ,
                              yang_name="node" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='id' , extensions=None ,
                              choice=(u'numa-policy' , u'numa-aware')) , is_container='list' , yang_name="node" ,
            parent=self , choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__node_cnt = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
            is_leaf=True , yang_name="node-cnt" , parent=self , choice=(u'numa-policy' , u'numa-aware') ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint16' ,
            is_config=True)
        self.__mem_policy = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                  restriction_arg={u'STRICT': {} ,
                                                                                   u'PREFERRED': {}} , ) ,
                                         is_leaf=True , yang_name="mem-policy" , parent=self ,
                                         choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper ,
                                         extmethods=self._extmethods , register_paths=True ,
                                         namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                         yang_type='enumeration' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'guest-epa' , u'numa-node-policy']

    def _get_node_cnt(self):
        """
    Getter method for node_cnt, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node_cnt (uint16)

    YANG Description: The number of NUMA nodes to expose to the VM.
    """
        return self.__node_cnt

    def _set_node_cnt(self , v , load=False):
        """
    Setter method for node_cnt, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node_cnt (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node_cnt() directly.

    YANG Description: The number of NUMA nodes to expose to the VM.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} ,
                                                          int_size=16) , is_leaf=True , yang_name="node-cnt" ,
                             parent=self , choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint16' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """node_cnt must be of a type compatible with uint16""" ,
                'defined-type': "uint16" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="node-cnt", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint16', is_config=True)""" ,
            })

        self.__node_cnt = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_node_cnt(self):
        self.__node_cnt = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
            is_leaf=True , yang_name="node-cnt" , parent=self , choice=(u'numa-policy' , u'numa-aware') ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint16' ,
            is_config=True)

    def _get_mem_policy(self):
        """
    Getter method for mem_policy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/mem_policy (enumeration)

    YANG Description: This policy specifies how the memory should
be allocated in a multi-node scenario.
STRICT    : The memory must be allocated
            strictly from the memory attached
            to the NUMA node.
PREFERRED : The memory should be allocated
            preferentially from the memory
            attached to the NUMA node
    """
        return self.__mem_policy

    def _set_mem_policy(self , v , load=False):
        """
    Setter method for mem_policy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/mem_policy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mem_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mem_policy() directly.

    YANG Description: This policy specifies how the memory should
be allocated in a multi-node scenario.
STRICT    : The memory must be allocated
            strictly from the memory attached
            to the NUMA node.
PREFERRED : The memory should be allocated
            preferentially from the memory
            attached to the NUMA node
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'STRICT': {} , u'PREFERRED': {}} , ) ,
                             is_leaf=True , yang_name="mem-policy" , parent=self ,
                             choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """mem_policy must be of a type compatible with enumeration""" ,
                'defined-type': "vnfd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'STRICT': {}, u'PREFERRED': {}},), is_leaf=True, yang_name="mem-policy", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__mem_policy = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_mem_policy(self):
        self.__mem_policy = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                  restriction_arg={u'STRICT': {} ,
                                                                                   u'PREFERRED': {}} , ) ,
                                         is_leaf=True , yang_name="mem-policy" , parent=self ,
                                         choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper ,
                                         extmethods=self._extmethods , register_paths=True ,
                                         namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                         yang_type='enumeration' , is_config=True)

    def _get_node(self):
        """
    Getter method for node, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node (list)
    """
        return self.__node

    def _set_node(self , v , load=False):
        """
    Setter method for node, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy/node (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("id" ,
                                                   yc_node_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node ,
                                                   yang_name="node" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper , yang_keys='id' ,
                                                   extensions=None , choice=(u'numa-policy' , u'numa-aware')) ,
                             is_container='list' , yang_name="node" , parent=self ,
                             choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """node must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_node_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=(u'numa-policy', u'numa-aware')), is_container='list', yang_name="node", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__node = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_node(self):
        self.__node = YANGDynClass(
            base=YANGListType("id" , yc_node_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy_node ,
                              yang_name="node" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='id' , extensions=None ,
                              choice=(u'numa-policy' , u'numa-aware')) , is_container='list' , yang_name="node" ,
            parent=self , choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    node_cnt = __builtin__.property(_get_node_cnt , _set_node_cnt)
    mem_policy = __builtin__.property(_get_mem_policy , _set_mem_policy)
    node = __builtin__.property(_get_node , _set_node)

    __choices__ = {u'numa-policy': {u'numa-aware': [u'node_cnt' , u'mem_policy' , u'node']}}
    _pyangbind_elements = {'node_cnt': node_cnt , 'mem_policy': mem_policy , 'node': node , }


class yc_guest_epa_vnfd__vnfd_catalog_vnfd_vdu_guest_epa(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/guest-epa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__trusted_execution' , '__mempage_size' , '__cpu_pinning_policy' ,
                 '__cpu_thread_pinning_policy' , '__pcie_device' , '__numa_unaware' , '__numa_node_policy' ,)

    _yang_name = 'guest-epa'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__cpu_thread_pinning_policy = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'PREFER': {} , u'AVOID': {} , u'ISOLATE': {} ,
                                                      u'SEPARATE': {}} , ) , is_leaf=True ,
            yang_name="cpu-thread-pinning-policy" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='enumeration' , is_config=True)
        self.__numa_unaware = YANGDynClass(base=YANGBool , is_leaf=True , yang_name="numa-unaware" , parent=self ,
                                           choice=(u'numa-policy' , u'numa-unaware') , path_helper=self._path_helper ,
                                           extmethods=self._extmethods , register_paths=True ,
                                           namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                           yang_type='empty' , is_config=True)
        self.__pcie_device = YANGDynClass(
            base=YANGListType("device_id" , yc_pcie_device_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_pcie_device ,
                              yang_name="pcie-device" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='device-id' , extensions=None) ,
            is_container='list' , yang_name="pcie-device" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__mempage_size = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                    restriction_arg={u'LARGE': {} , u'SMALL': {} ,
                                                                                     u'SIZE_1GB': {} , u'SIZE_2MB': {} ,
                                                                                     u'PREFER_LARGE': {}} , ) ,
                                           is_leaf=True , yang_name="mempage-size" , parent=self ,
                                           path_helper=self._path_helper , extmethods=self._extmethods ,
                                           register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                           defining_module='vnfd' , yang_type='enumeration' , is_config=True)
        self.__trusted_execution = YANGDynClass(base=YANGBool , is_leaf=True , yang_name="trusted-execution" ,
                                                parent=self , path_helper=self._path_helper ,
                                                extmethods=self._extmethods , register_paths=True ,
                                                namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                defining_module='vnfd' , yang_type='boolean' , is_config=True)
        self.__numa_node_policy = YANGDynClass(
            base=yc_numa_node_policy_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy , is_container='container' ,
            yang_name="numa-node-policy" , parent=self , choice=(u'numa-policy' , u'numa-aware') ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)
        self.__cpu_pinning_policy = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'SHARED': {} , u'DEDICATED': {} , u'ANY': {}} , ) ,
            default=unicode("ANY") , is_leaf=True , yang_name="cpu-pinning-policy" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='enumeration' ,
            is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'guest-epa']

    def _get_trusted_execution(self):
        """
    Getter method for trusted_execution, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/trusted_execution (boolean)

    YANG Description: This VM should be allocated from trusted pool
    """
        return self.__trusted_execution

    def _set_trusted_execution(self , v , load=False):
        """
    Setter method for trusted_execution, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/trusted_execution (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trusted_execution is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trusted_execution() directly.

    YANG Description: This VM should be allocated from trusted pool
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , is_leaf=True , yang_name="trusted-execution" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """trusted_execution must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trusted-execution", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__trusted_execution = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_trusted_execution(self):
        self.__trusted_execution = YANGDynClass(base=YANGBool , is_leaf=True , yang_name="trusted-execution" ,
                                                parent=self , path_helper=self._path_helper ,
                                                extmethods=self._extmethods , register_paths=True ,
                                                namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                defining_module='vnfd' , yang_type='boolean' , is_config=True)

    def _get_mempage_size(self):
        """
    Getter method for mempage_size, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/mempage_size (enumeration)

    YANG Description: Memory page allocation size. If a VM requires
hugepages, it should choose LARGE or SIZE_2MB
or SIZE_1GB. If the VM prefers hugepages it
should choose PREFER_LARGE.
LARGE        : Require hugepages (either 2MB or 1GB)
SMALL        : Doesn't require hugepages
SIZE_2MB     : Requires 2MB hugepages
SIZE_1GB     : Requires 1GB hugepages
PREFER_LARGE : Application prefers hugepages
    """
        return self.__mempage_size

    def _set_mempage_size(self , v , load=False):
        """
    Setter method for mempage_size, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/mempage_size (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mempage_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mempage_size() directly.

    YANG Description: Memory page allocation size. If a VM requires
hugepages, it should choose LARGE or SIZE_2MB
or SIZE_1GB. If the VM prefers hugepages it
should choose PREFER_LARGE.
LARGE        : Require hugepages (either 2MB or 1GB)
SMALL        : Doesn't require hugepages
SIZE_2MB     : Requires 2MB hugepages
SIZE_1GB     : Requires 1GB hugepages
PREFER_LARGE : Application prefers hugepages
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'LARGE': {} , u'SMALL': {} ,
                                                                           u'SIZE_1GB': {} , u'SIZE_2MB': {} ,
                                                                           u'PREFER_LARGE': {}} , ) , is_leaf=True ,
                             yang_name="mempage-size" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """mempage_size must be of a type compatible with enumeration""" ,
                'defined-type': "vnfd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'LARGE': {}, u'SMALL': {}, u'SIZE_1GB': {}, u'SIZE_2MB': {}, u'PREFER_LARGE': {}},), is_leaf=True, yang_name="mempage-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__mempage_size = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_mempage_size(self):
        self.__mempage_size = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                    restriction_arg={u'LARGE': {} , u'SMALL': {} ,
                                                                                     u'SIZE_1GB': {} , u'SIZE_2MB': {} ,
                                                                                     u'PREFER_LARGE': {}} , ) ,
                                           is_leaf=True , yang_name="mempage-size" , parent=self ,
                                           path_helper=self._path_helper , extmethods=self._extmethods ,
                                           register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                           defining_module='vnfd' , yang_type='enumeration' , is_config=True)

    def _get_cpu_pinning_policy(self):
        """
    Getter method for cpu_pinning_policy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/cpu_pinning_policy (enumeration)

    YANG Description: CPU pinning policy describes association
between virtual CPUs in guest and the
physical CPUs in the host.
DEDICATED : Virtual CPUs are pinned to
            physical CPUs
SHARED    : Multiple VMs may share the
            same physical CPUs.
ANY       : Any policy is acceptable for the VM
    """
        return self.__cpu_pinning_policy

    def _set_cpu_pinning_policy(self , v , load=False):
        """
    Setter method for cpu_pinning_policy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/cpu_pinning_policy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_pinning_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_pinning_policy() directly.

    YANG Description: CPU pinning policy describes association
between virtual CPUs in guest and the
physical CPUs in the host.
DEDICATED : Virtual CPUs are pinned to
            physical CPUs
SHARED    : Multiple VMs may share the
            same physical CPUs.
ANY       : Any policy is acceptable for the VM
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'SHARED': {} , u'DEDICATED': {} ,
                                                                           u'ANY': {}} , ) , default=unicode("ANY") ,
                             is_leaf=True , yang_name="cpu-pinning-policy" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """cpu_pinning_policy must be of a type compatible with enumeration""" ,
                'defined-type': "vnfd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'SHARED': {}, u'DEDICATED': {}, u'ANY': {}},), default=unicode("ANY"), is_leaf=True, yang_name="cpu-pinning-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__cpu_pinning_policy = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_cpu_pinning_policy(self):
        self.__cpu_pinning_policy = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'SHARED': {} , u'DEDICATED': {} , u'ANY': {}} , ) ,
            default=unicode("ANY") , is_leaf=True , yang_name="cpu-pinning-policy" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='enumeration' ,
            is_config=True)

    def _get_cpu_thread_pinning_policy(self):
        """
    Getter method for cpu_thread_pinning_policy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/cpu_thread_pinning_policy (enumeration)

    YANG Description: CPU thread pinning policy describes how to
place the guest CPUs when the host supports
hyper threads:
AVOID   : Avoids placing a guest on a host
          with threads.
SEPARATE: Places vCPUs on separate cores,
          and avoids placing two vCPUs on
          two threads of same core.
ISOLATE : Places each vCPU on a different core,
          and places no vCPUs from a different
          guest on the same core.
PREFER  : Attempts to place vCPUs on threads
          of the same core.
    """
        return self.__cpu_thread_pinning_policy

    def _set_cpu_thread_pinning_policy(self , v , load=False):
        """
    Setter method for cpu_thread_pinning_policy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/cpu_thread_pinning_policy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_thread_pinning_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_thread_pinning_policy() directly.

    YANG Description: CPU thread pinning policy describes how to
place the guest CPUs when the host supports
hyper threads:
AVOID   : Avoids placing a guest on a host
          with threads.
SEPARATE: Places vCPUs on separate cores,
          and avoids placing two vCPUs on
          two threads of same core.
ISOLATE : Places each vCPU on a different core,
          and places no vCPUs from a different
          guest on the same core.
PREFER  : Attempts to place vCPUs on threads
          of the same core.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'PREFER': {} , u'AVOID': {} ,
                                                                           u'ISOLATE': {} , u'SEPARATE': {}} , ) ,
                             is_leaf=True , yang_name="cpu-thread-pinning-policy" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """cpu_thread_pinning_policy must be of a type compatible with enumeration""" ,
                'defined-type': "vnfd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'PREFER': {}, u'AVOID': {}, u'ISOLATE': {}, u'SEPARATE': {}},), is_leaf=True, yang_name="cpu-thread-pinning-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__cpu_thread_pinning_policy = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_cpu_thread_pinning_policy(self):
        self.__cpu_thread_pinning_policy = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'PREFER': {} , u'AVOID': {} , u'ISOLATE': {} ,
                                                      u'SEPARATE': {}} , ) , is_leaf=True ,
            yang_name="cpu-thread-pinning-policy" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='enumeration' , is_config=True)

    def _get_pcie_device(self):
        """
    Getter method for pcie_device, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/pcie_device (list)

    YANG Description: List of pcie passthrough devices.
    """
        return self.__pcie_device

    def _set_pcie_device(self , v , load=False):
        """
    Setter method for pcie_device, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/pcie_device (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pcie_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pcie_device() directly.

    YANG Description: List of pcie passthrough devices.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("device_id" ,
                                                   yc_pcie_device_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_pcie_device ,
                                                   yang_name="pcie-device" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='device-id' , extensions=None) , is_container='list' ,
                             yang_name="pcie-device" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """pcie_device must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("device_id",yc_pcie_device_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_pcie_device, yang_name="pcie-device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='device-id', extensions=None), is_container='list', yang_name="pcie-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__pcie_device = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_pcie_device(self):
        self.__pcie_device = YANGDynClass(
            base=YANGListType("device_id" , yc_pcie_device_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_pcie_device ,
                              yang_name="pcie-device" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='device-id' , extensions=None) ,
            is_container='list' , yang_name="pcie-device" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    def _get_numa_unaware(self):
        """
    Getter method for numa_unaware, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_unaware (empty)
    """
        return self.__numa_unaware

    def _set_numa_unaware(self , v , load=False):
        """
    Setter method for numa_unaware, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_unaware (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numa_unaware is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numa_unaware() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , is_leaf=True , yang_name="numa-unaware" , parent=self ,
                             choice=(u'numa-policy' , u'numa-unaware') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='empty' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """numa_unaware must be of a type compatible with empty""" ,
                'defined-type': "empty" ,
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="numa-unaware", parent=self, choice=(u'numa-policy', u'numa-unaware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='empty', is_config=True)""" ,
            })

        self.__numa_unaware = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_numa_unaware(self):
        self.__numa_unaware = YANGDynClass(base=YANGBool , is_leaf=True , yang_name="numa-unaware" , parent=self ,
                                           choice=(u'numa-policy' , u'numa-unaware') , path_helper=self._path_helper ,
                                           extmethods=self._extmethods , register_paths=True ,
                                           namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                           yang_type='empty' , is_config=True)

    def _get_numa_node_policy(self):
        """
    Getter method for numa_node_policy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy (container)

    YANG Description: This policy defines NUMA topology of the
guest. Specifically identifies if the guest
should be run on a host with one NUMA
node or multiple NUMA nodes. As an example
a guest might need 8 VCPUs and 4 GB of
memory. However, it might need the VCPUs
and memory distributed across multiple
NUMA nodes. In this scenario, NUMA node
1 could run with 6 VCPUs and 3GB, and
NUMA node 2 could run with 2 VCPUs and
1GB.
    """
        return self.__numa_node_policy

    def _set_numa_node_policy(self , v , load=False):
        """
    Setter method for numa_node_policy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa/numa_node_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numa_node_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numa_node_policy() directly.

    YANG Description: This policy defines NUMA topology of the
guest. Specifically identifies if the guest
should be run on a host with one NUMA
node or multiple NUMA nodes. As an example
a guest might need 8 VCPUs and 4 GB of
memory. However, it might need the VCPUs
and memory distributed across multiple
NUMA nodes. In this scenario, NUMA node
1 could run with 6 VCPUs and 3GB, and
NUMA node 2 could run with 2 VCPUs and
1GB.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_numa_node_policy_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy ,
                             is_container='container' , yang_name="numa-node-policy" , parent=self ,
                             choice=(u'numa-policy' , u'numa-aware') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """numa_node_policy must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_numa_node_policy_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy, is_container='container', yang_name="numa-node-policy", parent=self, choice=(u'numa-policy', u'numa-aware'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__numa_node_policy = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_numa_node_policy(self):
        self.__numa_node_policy = YANGDynClass(
            base=yc_numa_node_policy_vnfd__vnfd_catalog_vnfd_vdu_guest_epa_numa_node_policy , is_container='container' ,
            yang_name="numa-node-policy" , parent=self , choice=(u'numa-policy' , u'numa-aware') ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)

    trusted_execution = __builtin__.property(_get_trusted_execution , _set_trusted_execution)
    mempage_size = __builtin__.property(_get_mempage_size , _set_mempage_size)
    cpu_pinning_policy = __builtin__.property(_get_cpu_pinning_policy , _set_cpu_pinning_policy)
    cpu_thread_pinning_policy = __builtin__.property(_get_cpu_thread_pinning_policy , _set_cpu_thread_pinning_policy)
    pcie_device = __builtin__.property(_get_pcie_device , _set_pcie_device)
    numa_unaware = __builtin__.property(_get_numa_unaware , _set_numa_unaware)
    numa_node_policy = __builtin__.property(_get_numa_node_policy , _set_numa_node_policy)

    __choices__ = {u'numa-policy': {u'numa-unaware': [u'numa_unaware'] , u'numa-aware': [u'numa_node_policy']}}
    _pyangbind_elements = {'trusted_execution': trusted_execution , 'mempage_size': mempage_size ,
                           'cpu_pinning_policy': cpu_pinning_policy ,
                           'cpu_thread_pinning_policy': cpu_thread_pinning_policy , 'pcie_device': pcie_device ,
                           'numa_unaware': numa_unaware , 'numa_node_policy': numa_node_policy , }


class yc_vswitch_epa_vnfd__vnfd_catalog_vnfd_vdu_vswitch_epa(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vswitch-epa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__ovs_acceleration' , '__ovs_offload' ,)

    _yang_name = 'vswitch-epa'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__ovs_acceleration = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'DISABLED': {} , u'MANDATORY': {} , u'PREFERRED': {}} , ) ,
            is_leaf=True , yang_name="ovs-acceleration" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='enumeration' , is_config=True)
        self.__ovs_offload = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                   restriction_arg={u'DISABLED': {} , u'MANDATORY': {} ,
                                                                                    u'PREFERRED': {}} , ) ,
                                          is_leaf=True , yang_name="ovs-offload" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='enumeration' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'vswitch-epa']

    def _get_ovs_acceleration(self):
        """
    Getter method for ovs_acceleration, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vswitch_epa/ovs_acceleration (enumeration)

    YANG Description: Specifies Open vSwitch acceleration mode.
MANDATORY: OVS acceleration is required
PREFERRED: OVS acceleration is preferred
    """
        return self.__ovs_acceleration

    def _set_ovs_acceleration(self , v , load=False):
        """
    Setter method for ovs_acceleration, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vswitch_epa/ovs_acceleration (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ovs_acceleration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ovs_acceleration() directly.

    YANG Description: Specifies Open vSwitch acceleration mode.
MANDATORY: OVS acceleration is required
PREFERRED: OVS acceleration is preferred
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'DISABLED': {} , u'MANDATORY': {} ,
                                                                           u'PREFERRED': {}} , ) , is_leaf=True ,
                             yang_name="ovs-acceleration" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ovs_acceleration must be of a type compatible with enumeration""" ,
                'defined-type': "vnfd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MANDATORY': {}, u'PREFERRED': {}},), is_leaf=True, yang_name="ovs-acceleration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__ovs_acceleration = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ovs_acceleration(self):
        self.__ovs_acceleration = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'DISABLED': {} , u'MANDATORY': {} , u'PREFERRED': {}} , ) ,
            is_leaf=True , yang_name="ovs-acceleration" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='enumeration' , is_config=True)

    def _get_ovs_offload(self):
        """
    Getter method for ovs_offload, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vswitch_epa/ovs_offload (enumeration)

    YANG Description: Specifies Open vSwitch hardware offload mode.
MANDATORY: OVS offload is required
PREFERRED: OVS offload is preferred
    """
        return self.__ovs_offload

    def _set_ovs_offload(self , v , load=False):
        """
    Setter method for ovs_offload, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vswitch_epa/ovs_offload (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ovs_offload is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ovs_offload() directly.

    YANG Description: Specifies Open vSwitch hardware offload mode.
MANDATORY: OVS offload is required
PREFERRED: OVS offload is preferred
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'DISABLED': {} , u'MANDATORY': {} ,
                                                                           u'PREFERRED': {}} , ) , is_leaf=True ,
                             yang_name="ovs-offload" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ovs_offload must be of a type compatible with enumeration""" ,
                'defined-type': "vnfd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'DISABLED': {}, u'MANDATORY': {}, u'PREFERRED': {}},), is_leaf=True, yang_name="ovs-offload", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__ovs_offload = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ovs_offload(self):
        self.__ovs_offload = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                   restriction_arg={u'DISABLED': {} , u'MANDATORY': {} ,
                                                                                    u'PREFERRED': {}} , ) ,
                                          is_leaf=True , yang_name="ovs-offload" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='enumeration' , is_config=True)

    ovs_acceleration = __builtin__.property(_get_ovs_acceleration , _set_ovs_acceleration)
    ovs_offload = __builtin__.property(_get_ovs_offload , _set_ovs_offload)

    _pyangbind_elements = {'ovs_acceleration': ovs_acceleration , 'ovs_offload': ovs_offload , }


class yc_hypervisor_epa_vnfd__vnfd_catalog_vnfd_vdu_hypervisor_epa(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/hypervisor-epa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__type' , '__version' ,)

    _yang_name = 'hypervisor-epa'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__version = YANGDynClass(base=unicode , is_leaf=True , yang_name="version" , parent=self ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                      defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                            restriction_arg={u'REQUIRE_KVM': {} ,
                                                                             u'PREFER_KVM': {}} , ) , is_leaf=True ,
                                   yang_name="type" , parent=self , path_helper=self._path_helper ,
                                   extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='enumeration' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'hypervisor-epa']

    def _get_type(self):
        """
    Getter method for type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/hypervisor_epa/type (enumeration)

    YANG Description: Specifies the type of hypervisor.
KVM: KVM
XEN: XEN
    """
        return self.__type

    def _set_type(self , v , load=False):
        """
    Setter method for type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/hypervisor_epa/type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the type of hypervisor.
KVM: KVM
XEN: XEN
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'REQUIRE_KVM': {} , u'PREFER_KVM': {}} , ) ,
                             is_leaf=True , yang_name="type" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """type must be of a type compatible with enumeration""" ,
                'defined-type': "vnfd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'REQUIRE_KVM': {}, u'PREFER_KVM': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                            restriction_arg={u'REQUIRE_KVM': {} ,
                                                                             u'PREFER_KVM': {}} , ) , is_leaf=True ,
                                   yang_name="type" , parent=self , path_helper=self._path_helper ,
                                   extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='enumeration' , is_config=True)

    def _get_version(self):
        """
    Getter method for version, mapped from YANG variable /vnfd_catalog/vnfd/vdu/hypervisor_epa/version (string)
    """
        return self.__version

    def _set_version(self , v , load=False):
        """
    Setter method for version, mapped from YANG variable /vnfd_catalog/vnfd/vdu/hypervisor_epa/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="version" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """version must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__version = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(base=unicode , is_leaf=True , yang_name="version" , parent=self ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                      defining_module='vnfd' , yang_type='string' , is_config=True)

    type = __builtin__.property(_get_type , _set_type)
    version = __builtin__.property(_get_version , _set_version)

    _pyangbind_elements = {'type': type , 'version': version , }


class yc_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_cpu_feature(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/host-epa/cpu-feature. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of CPU features.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__feature' ,)

    _yang_name = 'cpu-feature'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__feature = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                               restriction_arg={u'PREFER_SEP': {} , u'REQUIRE_SEP': {} ,
                                                                                u'REQUIRE_ERMS': {} ,
                                                                                u'PREFER_TSC': {} , u'PREFER_FMA': {} ,
                                                                                u'PREFER_MONITOR': {} ,
                                                                                u'PREFER_PDCM': {} ,
                                                                                u'PREFER_FXSR': {} ,
                                                                                u'PREFER_SSE4_2': {} ,
                                                                                u'REQUIRE_PNI': {} ,
                                                                                u'REQUIRE_SSE4_2': {} ,
                                                                                u'PREFER_SMX': {} , u'REQUIRE_SMX': {} ,
                                                                                u'PREFER_DDIO': {} ,
                                                                                u'REQUIRE_MPX': {} ,
                                                                                u'REQUIRE_FXSR': {} ,
                                                                                u'PREFER_MOVBE': {} ,
                                                                                u'REQUIRE_TM': {} , u'PREFER_PGE': {} ,
                                                                                u'REQUIRE_PSE': {} , u'REQUIRE_DE': {} ,
                                                                                u'PREFER_HLE': {} ,
                                                                                u'REQUIRE_XTPR': {} ,
                                                                                u'REQUIRE_DTES64': {} ,
                                                                                u'REQUIRE_BMI1': {} ,
                                                                                u'REQUIRE_BMI2': {} ,
                                                                                u'REQUIRE_PCID': {} ,
                                                                                u'REQUIRE_PDCM': {} ,
                                                                                u'REQUIRE_CLFLUSH': {} ,
                                                                                u'REQUIRE_SSE2': {} ,
                                                                                u'PREFER_MTRR': {} , u'PREFER_AVX': {} ,
                                                                                u'REQUIRE_SS': {} , u'PREFER_F16C': {} ,
                                                                                u'REQUIRE_DTS': {} ,
                                                                                u'REQUIRE_PCLMULQDQ': {} ,
                                                                                u'REQUIRE_MTRR': {} ,
                                                                                u'PREFER_SMAP': {} , u'PREFER_MPX': {} ,
                                                                                u'REQUIRE_TSC': {} , u'PREFER_VMX': {} ,
                                                                                u'REQUIRE_SMEP': {} ,
                                                                                u'PREFER_AES': {} ,
                                                                                u'PREFER_RDTSCP': {} ,
                                                                                u'PREFER_CID': {} , u'REQUIRE_CID': {} ,
                                                                                u'PREFER_VME': {} ,
                                                                                u'REQUIRE_SSSE3': {} ,
                                                                                u'PREFER_CAT': {} , u'REQUIRE_CAT': {} ,
                                                                                u'PREFER_TM2': {} , u'PREFER_CMOV': {} ,
                                                                                u'PREFER_PAE': {} ,
                                                                                u'PREFER_CLFLUSH': {} ,
                                                                                u'PREFER_RTM': {} , u'REQUIRE_MMX': {} ,
                                                                                u'PREFER_PAT': {} ,
                                                                                u'PREFER_INVPCID': {} ,
                                                                                u'REQUIRE_RTM': {} ,
                                                                                u'PREFER_TSC_DEADLINE_TIMER': {} ,
                                                                                u'PREFER_POPCNT': {} ,
                                                                                u'REQUIRE_TM2': {} ,
                                                                                u'REQUIRE_CX16': {} ,
                                                                                u'REQUIRE_TSC_DEADLINE_TIMER': {} ,
                                                                                u'REQUIRE_APIC': {} ,
                                                                                u'PREFER_PNI': {} ,
                                                                                u'REQUIRE_DS_CPL': {} ,
                                                                                u'REQUIRE_SSE4_1': {} ,
                                                                                u'PREFER_FSGSBASE': {} ,
                                                                                u'PREFER_SSSE3': {} ,
                                                                                u'REQUIRE_PSE36': {} ,
                                                                                u'PREFER_ADX': {} , u'PREFER_CX8': {} ,
                                                                                u'PREFER_ERMS': {} , u'PREFER_HT': {} ,
                                                                                u'PREFER_SSE2': {} ,
                                                                                u'PREFER_AVX2': {} ,
                                                                                u'REQUIRE_PGE': {} ,
                                                                                u'REQUIRE_HLE': {} ,
                                                                                u'PREFER_BMI2': {} ,
                                                                                u'PREFER_BMI1': {} ,
                                                                                u'PREFER_PCLMULQDQ': {} ,
                                                                                u'PREFER_CX16': {} ,
                                                                                u'REQUIRE_POPCNT': {} ,
                                                                                u'PREFER_EST': {} , u'REQUIRE_FMA': {} ,
                                                                                u'REQUIRE_EST': {} ,
                                                                                u'PREFER_DTES64': {} ,
                                                                                u'PREFER_APIC': {} ,
                                                                                u'REQUIRE_ADX': {} ,
                                                                                u'REQUIRE_FSGSBASE': {} ,
                                                                                u'PREFER_XSAVE': {} ,
                                                                                u'REQUIRE_IA64': {} ,
                                                                                u'PREFER_DCA': {} , u'PREFER_SMEP': {} ,
                                                                                u'PREFER_SSE4_1': {} ,
                                                                                u'REQUIRE_RDTSCP': {} ,
                                                                                u'REQUIRE_DDIO': {} ,
                                                                                u'PREFER_ACPI': {} ,
                                                                                u'REQUIRE_AES': {} , u'REQUIRE_HT': {} ,
                                                                                u'PREFER_MMX': {} ,
                                                                                u'REQUIRE_MOVBE': {} ,
                                                                                u'REQUIRE_INVPCID': {} ,
                                                                                u'PREFER_PSE': {} ,
                                                                                u'PREFER_DS_CPL': {} ,
                                                                                u'REQUIRE_CX8': {} ,
                                                                                u'REQUIRE_AVX': {} ,
                                                                                u'PREFER_PCID': {} ,
                                                                                u'PREFER_IA64': {} ,
                                                                                u'REQUIRE_X2APIC': {} ,
                                                                                u'PREFER_TM': {} , u'REQUIRE_SMAP': {} ,
                                                                                u'REQUIRE_MONITOR': {} ,
                                                                                u'PREFER_RDSEED': {} ,
                                                                                u'REQUIRE_CMOV': {} ,
                                                                                u'PREFER_X2APIC': {} ,
                                                                                u'REQUIRE_DCA': {} ,
                                                                                u'REQUIRE_XSAVE': {} ,
                                                                                u'REQUIRE_AVX2': {} , u'PREFER_SS': {} ,
                                                                                u'REQUIRE_VME': {} ,
                                                                                u'REQUIRE_ACPI': {} ,
                                                                                u'REQUIRE_PBE': {} , u'PREFER_MSR': {} ,
                                                                                u'REQUIRE_VMX': {} , u'PREFER_CMT': {} ,
                                                                                u'REQUIRE_CMT': {} ,
                                                                                u'PREFER_PSE36': {} ,
                                                                                u'REQUIRE_RDSEED': {} ,
                                                                                u'PREFER_XTPR': {} ,
                                                                                u'REQUIRE_RDRAND': {} ,
                                                                                u'REQUIRE_MCE': {} ,
                                                                                u'REQUIRE_MCA': {} ,
                                                                                u'REQUIRE_F16C': {} , u'PREFER_DE': {} ,
                                                                                u'PREFER_DTS': {} , u'REQUIRE_PAT': {} ,
                                                                                u'PREFER_SSE': {} , u'REQUIRE_SSE': {} ,
                                                                                u'REQUIRE_MSR': {} ,
                                                                                u'PREFER_RDRAND': {} ,
                                                                                u'PREFER_MCA': {} , u'PREFER_MCE': {} ,
                                                                                u'REQUIRE_PAE': {} ,
                                                                                u'PREFER_PBE': {}} , ) , is_leaf=True ,
                                      yang_name="feature" , parent=self , path_helper=self._path_helper ,
                                      extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                      yang_type='cpu-feature-type' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'host-epa' , u'cpu-feature']

    def _get_feature(self):
        """
    Getter method for feature, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_feature/feature (cpu-feature-type)

    YANG Description: CPU feature.
    """
        return self.__feature

    def _set_feature(self , v , load=False):
        """
    Setter method for feature, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_feature/feature (cpu-feature-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_feature is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_feature() directly.

    YANG Description: CPU feature.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'PREFER_SEP': {} , u'REQUIRE_SEP': {} ,
                                                                           u'REQUIRE_ERMS': {} , u'PREFER_TSC': {} ,
                                                                           u'PREFER_FMA': {} , u'PREFER_MONITOR': {} ,
                                                                           u'PREFER_PDCM': {} , u'PREFER_FXSR': {} ,
                                                                           u'PREFER_SSE4_2': {} , u'REQUIRE_PNI': {} ,
                                                                           u'REQUIRE_SSE4_2': {} , u'PREFER_SMX': {} ,
                                                                           u'REQUIRE_SMX': {} , u'PREFER_DDIO': {} ,
                                                                           u'REQUIRE_MPX': {} , u'REQUIRE_FXSR': {} ,
                                                                           u'PREFER_MOVBE': {} , u'REQUIRE_TM': {} ,
                                                                           u'PREFER_PGE': {} , u'REQUIRE_PSE': {} ,
                                                                           u'REQUIRE_DE': {} , u'PREFER_HLE': {} ,
                                                                           u'REQUIRE_XTPR': {} , u'REQUIRE_DTES64': {} ,
                                                                           u'REQUIRE_BMI1': {} , u'REQUIRE_BMI2': {} ,
                                                                           u'REQUIRE_PCID': {} , u'REQUIRE_PDCM': {} ,
                                                                           u'REQUIRE_CLFLUSH': {} ,
                                                                           u'REQUIRE_SSE2': {} , u'PREFER_MTRR': {} ,
                                                                           u'PREFER_AVX': {} , u'REQUIRE_SS': {} ,
                                                                           u'PREFER_F16C': {} , u'REQUIRE_DTS': {} ,
                                                                           u'REQUIRE_PCLMULQDQ': {} ,
                                                                           u'REQUIRE_MTRR': {} , u'PREFER_SMAP': {} ,
                                                                           u'PREFER_MPX': {} , u'REQUIRE_TSC': {} ,
                                                                           u'PREFER_VMX': {} , u'REQUIRE_SMEP': {} ,
                                                                           u'PREFER_AES': {} , u'PREFER_RDTSCP': {} ,
                                                                           u'PREFER_CID': {} , u'REQUIRE_CID': {} ,
                                                                           u'PREFER_VME': {} , u'REQUIRE_SSSE3': {} ,
                                                                           u'PREFER_CAT': {} , u'REQUIRE_CAT': {} ,
                                                                           u'PREFER_TM2': {} , u'PREFER_CMOV': {} ,
                                                                           u'PREFER_PAE': {} , u'PREFER_CLFLUSH': {} ,
                                                                           u'PREFER_RTM': {} , u'REQUIRE_MMX': {} ,
                                                                           u'PREFER_PAT': {} , u'PREFER_INVPCID': {} ,
                                                                           u'REQUIRE_RTM': {} ,
                                                                           u'PREFER_TSC_DEADLINE_TIMER': {} ,
                                                                           u'PREFER_POPCNT': {} , u'REQUIRE_TM2': {} ,
                                                                           u'REQUIRE_CX16': {} ,
                                                                           u'REQUIRE_TSC_DEADLINE_TIMER': {} ,
                                                                           u'REQUIRE_APIC': {} , u'PREFER_PNI': {} ,
                                                                           u'REQUIRE_DS_CPL': {} ,
                                                                           u'REQUIRE_SSE4_1': {} ,
                                                                           u'PREFER_FSGSBASE': {} ,
                                                                           u'PREFER_SSSE3': {} , u'REQUIRE_PSE36': {} ,
                                                                           u'PREFER_ADX': {} , u'PREFER_CX8': {} ,
                                                                           u'PREFER_ERMS': {} , u'PREFER_HT': {} ,
                                                                           u'PREFER_SSE2': {} , u'PREFER_AVX2': {} ,
                                                                           u'REQUIRE_PGE': {} , u'REQUIRE_HLE': {} ,
                                                                           u'PREFER_BMI2': {} , u'PREFER_BMI1': {} ,
                                                                           u'PREFER_PCLMULQDQ': {} ,
                                                                           u'PREFER_CX16': {} , u'REQUIRE_POPCNT': {} ,
                                                                           u'PREFER_EST': {} , u'REQUIRE_FMA': {} ,
                                                                           u'REQUIRE_EST': {} , u'PREFER_DTES64': {} ,
                                                                           u'PREFER_APIC': {} , u'REQUIRE_ADX': {} ,
                                                                           u'REQUIRE_FSGSBASE': {} ,
                                                                           u'PREFER_XSAVE': {} , u'REQUIRE_IA64': {} ,
                                                                           u'PREFER_DCA': {} , u'PREFER_SMEP': {} ,
                                                                           u'PREFER_SSE4_1': {} ,
                                                                           u'REQUIRE_RDTSCP': {} , u'REQUIRE_DDIO': {} ,
                                                                           u'PREFER_ACPI': {} , u'REQUIRE_AES': {} ,
                                                                           u'REQUIRE_HT': {} , u'PREFER_MMX': {} ,
                                                                           u'REQUIRE_MOVBE': {} ,
                                                                           u'REQUIRE_INVPCID': {} , u'PREFER_PSE': {} ,
                                                                           u'PREFER_DS_CPL': {} , u'REQUIRE_CX8': {} ,
                                                                           u'REQUIRE_AVX': {} , u'PREFER_PCID': {} ,
                                                                           u'PREFER_IA64': {} , u'REQUIRE_X2APIC': {} ,
                                                                           u'PREFER_TM': {} , u'REQUIRE_SMAP': {} ,
                                                                           u'REQUIRE_MONITOR': {} ,
                                                                           u'PREFER_RDSEED': {} , u'REQUIRE_CMOV': {} ,
                                                                           u'PREFER_X2APIC': {} , u'REQUIRE_DCA': {} ,
                                                                           u'REQUIRE_XSAVE': {} , u'REQUIRE_AVX2': {} ,
                                                                           u'PREFER_SS': {} , u'REQUIRE_VME': {} ,
                                                                           u'REQUIRE_ACPI': {} , u'REQUIRE_PBE': {} ,
                                                                           u'PREFER_MSR': {} , u'REQUIRE_VMX': {} ,
                                                                           u'PREFER_CMT': {} , u'REQUIRE_CMT': {} ,
                                                                           u'PREFER_PSE36': {} , u'REQUIRE_RDSEED': {} ,
                                                                           u'PREFER_XTPR': {} , u'REQUIRE_RDRAND': {} ,
                                                                           u'REQUIRE_MCE': {} , u'REQUIRE_MCA': {} ,
                                                                           u'REQUIRE_F16C': {} , u'PREFER_DE': {} ,
                                                                           u'PREFER_DTS': {} , u'REQUIRE_PAT': {} ,
                                                                           u'PREFER_SSE': {} , u'REQUIRE_SSE': {} ,
                                                                           u'REQUIRE_MSR': {} , u'PREFER_RDRAND': {} ,
                                                                           u'PREFER_MCA': {} , u'PREFER_MCE': {} ,
                                                                           u'REQUIRE_PAE': {} , u'PREFER_PBE': {}} , ) ,
                             is_leaf=True , yang_name="feature" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='cpu-feature-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """feature must be of a type compatible with cpu-feature-type""" ,
                'defined-type': "vnfd:cpu-feature-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'PREFER_SEP': {}, u'REQUIRE_SEP': {}, u'REQUIRE_ERMS': {}, u'PREFER_TSC': {}, u'PREFER_FMA': {}, u'PREFER_MONITOR': {}, u'PREFER_PDCM': {}, u'PREFER_FXSR': {}, u'PREFER_SSE4_2': {}, u'REQUIRE_PNI': {}, u'REQUIRE_SSE4_2': {}, u'PREFER_SMX': {}, u'REQUIRE_SMX': {}, u'PREFER_DDIO': {}, u'REQUIRE_MPX': {}, u'REQUIRE_FXSR': {}, u'PREFER_MOVBE': {}, u'REQUIRE_TM': {}, u'PREFER_PGE': {}, u'REQUIRE_PSE': {}, u'REQUIRE_DE': {}, u'PREFER_HLE': {}, u'REQUIRE_XTPR': {}, u'REQUIRE_DTES64': {}, u'REQUIRE_BMI1': {}, u'REQUIRE_BMI2': {}, u'REQUIRE_PCID': {}, u'REQUIRE_PDCM': {}, u'REQUIRE_CLFLUSH': {}, u'REQUIRE_SSE2': {}, u'PREFER_MTRR': {}, u'PREFER_AVX': {}, u'REQUIRE_SS': {}, u'PREFER_F16C': {}, u'REQUIRE_DTS': {}, u'REQUIRE_PCLMULQDQ': {}, u'REQUIRE_MTRR': {}, u'PREFER_SMAP': {}, u'PREFER_MPX': {}, u'REQUIRE_TSC': {}, u'PREFER_VMX': {}, u'REQUIRE_SMEP': {}, u'PREFER_AES': {}, u'PREFER_RDTSCP': {}, u'PREFER_CID': {}, u'REQUIRE_CID': {}, u'PREFER_VME': {}, u'REQUIRE_SSSE3': {}, u'PREFER_CAT': {}, u'REQUIRE_CAT': {}, u'PREFER_TM2': {}, u'PREFER_CMOV': {}, u'PREFER_PAE': {}, u'PREFER_CLFLUSH': {}, u'PREFER_RTM': {}, u'REQUIRE_MMX': {}, u'PREFER_PAT': {}, u'PREFER_INVPCID': {}, u'REQUIRE_RTM': {}, u'PREFER_TSC_DEADLINE_TIMER': {}, u'PREFER_POPCNT': {}, u'REQUIRE_TM2': {}, u'REQUIRE_CX16': {}, u'REQUIRE_TSC_DEADLINE_TIMER': {}, u'REQUIRE_APIC': {}, u'PREFER_PNI': {}, u'REQUIRE_DS_CPL': {}, u'REQUIRE_SSE4_1': {}, u'PREFER_FSGSBASE': {}, u'PREFER_SSSE3': {}, u'REQUIRE_PSE36': {}, u'PREFER_ADX': {}, u'PREFER_CX8': {}, u'PREFER_ERMS': {}, u'PREFER_HT': {}, u'PREFER_SSE2': {}, u'PREFER_AVX2': {}, u'REQUIRE_PGE': {}, u'REQUIRE_HLE': {}, u'PREFER_BMI2': {}, u'PREFER_BMI1': {}, u'PREFER_PCLMULQDQ': {}, u'PREFER_CX16': {}, u'REQUIRE_POPCNT': {}, u'PREFER_EST': {}, u'REQUIRE_FMA': {}, u'REQUIRE_EST': {}, u'PREFER_DTES64': {}, u'PREFER_APIC': {}, u'REQUIRE_ADX': {}, u'REQUIRE_FSGSBASE': {}, u'PREFER_XSAVE': {}, u'REQUIRE_IA64': {}, u'PREFER_DCA': {}, u'PREFER_SMEP': {}, u'PREFER_SSE4_1': {}, u'REQUIRE_RDTSCP': {}, u'REQUIRE_DDIO': {}, u'PREFER_ACPI': {}, u'REQUIRE_AES': {}, u'REQUIRE_HT': {}, u'PREFER_MMX': {}, u'REQUIRE_MOVBE': {}, u'REQUIRE_INVPCID': {}, u'PREFER_PSE': {}, u'PREFER_DS_CPL': {}, u'REQUIRE_CX8': {}, u'REQUIRE_AVX': {}, u'PREFER_PCID': {}, u'PREFER_IA64': {}, u'REQUIRE_X2APIC': {}, u'PREFER_TM': {}, u'REQUIRE_SMAP': {}, u'REQUIRE_MONITOR': {}, u'PREFER_RDSEED': {}, u'REQUIRE_CMOV': {}, u'PREFER_X2APIC': {}, u'REQUIRE_DCA': {}, u'REQUIRE_XSAVE': {}, u'REQUIRE_AVX2': {}, u'PREFER_SS': {}, u'REQUIRE_VME': {}, u'REQUIRE_ACPI': {}, u'REQUIRE_PBE': {}, u'PREFER_MSR': {}, u'REQUIRE_VMX': {}, u'PREFER_CMT': {}, u'REQUIRE_CMT': {}, u'PREFER_PSE36': {}, u'REQUIRE_RDSEED': {}, u'PREFER_XTPR': {}, u'REQUIRE_RDRAND': {}, u'REQUIRE_MCE': {}, u'REQUIRE_MCA': {}, u'REQUIRE_F16C': {}, u'PREFER_DE': {}, u'PREFER_DTS': {}, u'REQUIRE_PAT': {}, u'PREFER_SSE': {}, u'REQUIRE_SSE': {}, u'REQUIRE_MSR': {}, u'PREFER_RDRAND': {}, u'PREFER_MCA': {}, u'PREFER_MCE': {}, u'REQUIRE_PAE': {}, u'PREFER_PBE': {}},), is_leaf=True, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='cpu-feature-type', is_config=True)""" ,
            })

        self.__feature = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_feature(self):
        self.__feature = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                               restriction_arg={u'PREFER_SEP': {} , u'REQUIRE_SEP': {} ,
                                                                                u'REQUIRE_ERMS': {} ,
                                                                                u'PREFER_TSC': {} , u'PREFER_FMA': {} ,
                                                                                u'PREFER_MONITOR': {} ,
                                                                                u'PREFER_PDCM': {} ,
                                                                                u'PREFER_FXSR': {} ,
                                                                                u'PREFER_SSE4_2': {} ,
                                                                                u'REQUIRE_PNI': {} ,
                                                                                u'REQUIRE_SSE4_2': {} ,
                                                                                u'PREFER_SMX': {} , u'REQUIRE_SMX': {} ,
                                                                                u'PREFER_DDIO': {} ,
                                                                                u'REQUIRE_MPX': {} ,
                                                                                u'REQUIRE_FXSR': {} ,
                                                                                u'PREFER_MOVBE': {} ,
                                                                                u'REQUIRE_TM': {} , u'PREFER_PGE': {} ,
                                                                                u'REQUIRE_PSE': {} , u'REQUIRE_DE': {} ,
                                                                                u'PREFER_HLE': {} ,
                                                                                u'REQUIRE_XTPR': {} ,
                                                                                u'REQUIRE_DTES64': {} ,
                                                                                u'REQUIRE_BMI1': {} ,
                                                                                u'REQUIRE_BMI2': {} ,
                                                                                u'REQUIRE_PCID': {} ,
                                                                                u'REQUIRE_PDCM': {} ,
                                                                                u'REQUIRE_CLFLUSH': {} ,
                                                                                u'REQUIRE_SSE2': {} ,
                                                                                u'PREFER_MTRR': {} , u'PREFER_AVX': {} ,
                                                                                u'REQUIRE_SS': {} , u'PREFER_F16C': {} ,
                                                                                u'REQUIRE_DTS': {} ,
                                                                                u'REQUIRE_PCLMULQDQ': {} ,
                                                                                u'REQUIRE_MTRR': {} ,
                                                                                u'PREFER_SMAP': {} , u'PREFER_MPX': {} ,
                                                                                u'REQUIRE_TSC': {} , u'PREFER_VMX': {} ,
                                                                                u'REQUIRE_SMEP': {} ,
                                                                                u'PREFER_AES': {} ,
                                                                                u'PREFER_RDTSCP': {} ,
                                                                                u'PREFER_CID': {} , u'REQUIRE_CID': {} ,
                                                                                u'PREFER_VME': {} ,
                                                                                u'REQUIRE_SSSE3': {} ,
                                                                                u'PREFER_CAT': {} , u'REQUIRE_CAT': {} ,
                                                                                u'PREFER_TM2': {} , u'PREFER_CMOV': {} ,
                                                                                u'PREFER_PAE': {} ,
                                                                                u'PREFER_CLFLUSH': {} ,
                                                                                u'PREFER_RTM': {} , u'REQUIRE_MMX': {} ,
                                                                                u'PREFER_PAT': {} ,
                                                                                u'PREFER_INVPCID': {} ,
                                                                                u'REQUIRE_RTM': {} ,
                                                                                u'PREFER_TSC_DEADLINE_TIMER': {} ,
                                                                                u'PREFER_POPCNT': {} ,
                                                                                u'REQUIRE_TM2': {} ,
                                                                                u'REQUIRE_CX16': {} ,
                                                                                u'REQUIRE_TSC_DEADLINE_TIMER': {} ,
                                                                                u'REQUIRE_APIC': {} ,
                                                                                u'PREFER_PNI': {} ,
                                                                                u'REQUIRE_DS_CPL': {} ,
                                                                                u'REQUIRE_SSE4_1': {} ,
                                                                                u'PREFER_FSGSBASE': {} ,
                                                                                u'PREFER_SSSE3': {} ,
                                                                                u'REQUIRE_PSE36': {} ,
                                                                                u'PREFER_ADX': {} , u'PREFER_CX8': {} ,
                                                                                u'PREFER_ERMS': {} , u'PREFER_HT': {} ,
                                                                                u'PREFER_SSE2': {} ,
                                                                                u'PREFER_AVX2': {} ,
                                                                                u'REQUIRE_PGE': {} ,
                                                                                u'REQUIRE_HLE': {} ,
                                                                                u'PREFER_BMI2': {} ,
                                                                                u'PREFER_BMI1': {} ,
                                                                                u'PREFER_PCLMULQDQ': {} ,
                                                                                u'PREFER_CX16': {} ,
                                                                                u'REQUIRE_POPCNT': {} ,
                                                                                u'PREFER_EST': {} , u'REQUIRE_FMA': {} ,
                                                                                u'REQUIRE_EST': {} ,
                                                                                u'PREFER_DTES64': {} ,
                                                                                u'PREFER_APIC': {} ,
                                                                                u'REQUIRE_ADX': {} ,
                                                                                u'REQUIRE_FSGSBASE': {} ,
                                                                                u'PREFER_XSAVE': {} ,
                                                                                u'REQUIRE_IA64': {} ,
                                                                                u'PREFER_DCA': {} , u'PREFER_SMEP': {} ,
                                                                                u'PREFER_SSE4_1': {} ,
                                                                                u'REQUIRE_RDTSCP': {} ,
                                                                                u'REQUIRE_DDIO': {} ,
                                                                                u'PREFER_ACPI': {} ,
                                                                                u'REQUIRE_AES': {} , u'REQUIRE_HT': {} ,
                                                                                u'PREFER_MMX': {} ,
                                                                                u'REQUIRE_MOVBE': {} ,
                                                                                u'REQUIRE_INVPCID': {} ,
                                                                                u'PREFER_PSE': {} ,
                                                                                u'PREFER_DS_CPL': {} ,
                                                                                u'REQUIRE_CX8': {} ,
                                                                                u'REQUIRE_AVX': {} ,
                                                                                u'PREFER_PCID': {} ,
                                                                                u'PREFER_IA64': {} ,
                                                                                u'REQUIRE_X2APIC': {} ,
                                                                                u'PREFER_TM': {} , u'REQUIRE_SMAP': {} ,
                                                                                u'REQUIRE_MONITOR': {} ,
                                                                                u'PREFER_RDSEED': {} ,
                                                                                u'REQUIRE_CMOV': {} ,
                                                                                u'PREFER_X2APIC': {} ,
                                                                                u'REQUIRE_DCA': {} ,
                                                                                u'REQUIRE_XSAVE': {} ,
                                                                                u'REQUIRE_AVX2': {} , u'PREFER_SS': {} ,
                                                                                u'REQUIRE_VME': {} ,
                                                                                u'REQUIRE_ACPI': {} ,
                                                                                u'REQUIRE_PBE': {} , u'PREFER_MSR': {} ,
                                                                                u'REQUIRE_VMX': {} , u'PREFER_CMT': {} ,
                                                                                u'REQUIRE_CMT': {} ,
                                                                                u'PREFER_PSE36': {} ,
                                                                                u'REQUIRE_RDSEED': {} ,
                                                                                u'PREFER_XTPR': {} ,
                                                                                u'REQUIRE_RDRAND': {} ,
                                                                                u'REQUIRE_MCE': {} ,
                                                                                u'REQUIRE_MCA': {} ,
                                                                                u'REQUIRE_F16C': {} , u'PREFER_DE': {} ,
                                                                                u'PREFER_DTS': {} , u'REQUIRE_PAT': {} ,
                                                                                u'PREFER_SSE': {} , u'REQUIRE_SSE': {} ,
                                                                                u'REQUIRE_MSR': {} ,
                                                                                u'PREFER_RDRAND': {} ,
                                                                                u'PREFER_MCA': {} , u'PREFER_MCE': {} ,
                                                                                u'REQUIRE_PAE': {} ,
                                                                                u'PREFER_PBE': {}} , ) , is_leaf=True ,
                                      yang_name="feature" , parent=self , path_helper=self._path_helper ,
                                      extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                      yang_type='cpu-feature-type' , is_config=True)

    feature = __builtin__.property(_get_feature , _set_feature)

    _pyangbind_elements = {'feature': feature , }


class yc_om_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_om_cpu_feature(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/host-epa/om-cpu-feature. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of OpenMANO CPU features
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__feature' ,)

    _yang_name = 'om-cpu-feature'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__feature = YANGDynClass(base=unicode , is_leaf=True , yang_name="feature" , parent=self ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , is_keyval=True ,
                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                      yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'host-epa' , u'om-cpu-feature']

    def _get_feature(self):
        """
    Getter method for feature, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/om_cpu_feature/feature (string)

    YANG Description: CPU feature
    """
        return self.__feature

    def _set_feature(self , v , load=False):
        """
    Setter method for feature, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/om_cpu_feature/feature (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_feature is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_feature() directly.

    YANG Description: CPU feature
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="feature" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """feature must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__feature = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_feature(self):
        self.__feature = YANGDynClass(base=unicode , is_leaf=True , yang_name="feature" , parent=self ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , is_keyval=True ,
                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                      yang_type='string' , is_config=True)

    feature = __builtin__.property(_get_feature , _set_feature)

    _pyangbind_elements = {'feature': feature , }


class yc_host_epa_vnfd__vnfd_catalog_vnfd_vdu_host_epa(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/host-epa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the host level EPA attributes.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__cpu_model' , '__cpu_arch' , '__cpu_vendor' , '__cpu_socket_count' ,
                 '__cpu_core_count' , '__cpu_core_thread_count' , '__cpu_feature' , '__om_cpu_model_string' ,
                 '__om_cpu_feature' ,)

    _yang_name = 'host-epa'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__cpu_arch = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                restriction_arg={u'REQUIRE_X86_64': {} ,
                                                                                 u'PREFER_X86_64': {} ,
                                                                                 u'REQUIRE_X86': {} ,
                                                                                 u'REQUIRE_ARMV7': {} ,
                                                                                 u'PREFER_X86': {} ,
                                                                                 u'REQUIRE_IA64': {} ,
                                                                                 u'REQUIRE_ARMV8': {} ,
                                                                                 u'REQUIRE_I686': {} ,
                                                                                 u'PREFER_ARMV7': {} ,
                                                                                 u'PREFER_ARMV8': {} ,
                                                                                 u'PREFER_I686': {} ,
                                                                                 u'PREFER_IA64': {}} , ) ,
                                       is_leaf=True , yang_name="cpu-arch" , parent=self ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                       defining_module='vnfd' , yang_type='enumeration' , is_config=True)
        self.__om_cpu_feature = YANGDynClass(
            base=YANGListType("feature" , yc_om_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_om_cpu_feature ,
                              yang_name="om-cpu-feature" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='feature' , extensions=None) ,
            is_container='list' , yang_name="om-cpu-feature" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__om_cpu_model_string = YANGDynClass(base=unicode , is_leaf=True , yang_name="om-cpu-model-string" ,
                                                  parent=self , path_helper=self._path_helper ,
                                                  extmethods=self._extmethods , register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                  defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__cpu_core_thread_count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="cpu-core-thread-count" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)
        self.__cpu_model = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'REQUIRE_IVYBRIDGE': {} ,
                                                                                  u'PREFER_HASWELL': {} ,
                                                                                  u'PREFER_WESTMERE': {} ,
                                                                                  u'REQUIRE_WESTMERE': {} ,
                                                                                  u'PREFER_NEHALEM': {} ,
                                                                                  u'REQUIRE_PENRYN': {} ,
                                                                                  u'REQUIRE_SANDYBRIDGE': {} ,
                                                                                  u'PREFER_BROADWELL': {} ,
                                                                                  u'REQUIRE_BROADWELL': {} ,
                                                                                  u'PREFER_CORE2DUO': {} ,
                                                                                  u'PREFER_CONROE': {} ,
                                                                                  u'REQUIRE_CORE2DUO': {} ,
                                                                                  u'REQUIRE_CONROE': {} ,
                                                                                  u'PREFER_SANDYBRIDGE': {} ,
                                                                                  u'REQUIRE_HASWELL': {} ,
                                                                                  u'PREFER_PENRYN': {} ,
                                                                                  u'PREFER_IVYBRIDGE': {} ,
                                                                                  u'REQUIRE_NEHALEM': {}} , ) ,
                                        is_leaf=True , yang_name="cpu-model" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                        defining_module='vnfd' , yang_type='enumeration' , is_config=True)
        self.__cpu_core_count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="cpu-core-count" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)
        self.__cpu_feature = YANGDynClass(
            base=YANGListType("feature" , yc_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_cpu_feature ,
                              yang_name="cpu-feature" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='feature' , extensions=None) ,
            is_container='list' , yang_name="cpu-feature" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__cpu_vendor = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                  restriction_arg={u'PREFER_INTEL': {} ,
                                                                                   u'REQUIRE_INTEL': {} ,
                                                                                   u'REQUIRE_AMD': {} ,
                                                                                   u'PREFER_AMD': {}} , ) ,
                                         is_leaf=True , yang_name="cpu-vendor" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='enumeration' , is_config=True)
        self.__cpu_socket_count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="cpu-socket-count" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'host-epa']

    def _get_cpu_model(self):
        """
    Getter method for cpu_model, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_model (enumeration)

    YANG Description: Host CPU model. Examples include: SandyBridge,
IvyBridge
    """
        return self.__cpu_model

    def _set_cpu_model(self , v , load=False):
        """
    Setter method for cpu_model, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_model (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_model is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_model() directly.

    YANG Description: Host CPU model. Examples include: SandyBridge,
IvyBridge
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'REQUIRE_IVYBRIDGE': {} ,
                                                                           u'PREFER_HASWELL': {} ,
                                                                           u'PREFER_WESTMERE': {} ,
                                                                           u'REQUIRE_WESTMERE': {} ,
                                                                           u'PREFER_NEHALEM': {} ,
                                                                           u'REQUIRE_PENRYN': {} ,
                                                                           u'REQUIRE_SANDYBRIDGE': {} ,
                                                                           u'PREFER_BROADWELL': {} ,
                                                                           u'REQUIRE_BROADWELL': {} ,
                                                                           u'PREFER_CORE2DUO': {} ,
                                                                           u'PREFER_CONROE': {} ,
                                                                           u'REQUIRE_CORE2DUO': {} ,
                                                                           u'REQUIRE_CONROE': {} ,
                                                                           u'PREFER_SANDYBRIDGE': {} ,
                                                                           u'REQUIRE_HASWELL': {} ,
                                                                           u'PREFER_PENRYN': {} ,
                                                                           u'PREFER_IVYBRIDGE': {} ,
                                                                           u'REQUIRE_NEHALEM': {}} , ) , is_leaf=True ,
                             yang_name="cpu-model" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """cpu_model must be of a type compatible with enumeration""" ,
                'defined-type': "vnfd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'REQUIRE_IVYBRIDGE': {}, u'PREFER_HASWELL': {}, u'PREFER_WESTMERE': {}, u'REQUIRE_WESTMERE': {}, u'PREFER_NEHALEM': {}, u'REQUIRE_PENRYN': {}, u'REQUIRE_SANDYBRIDGE': {}, u'PREFER_BROADWELL': {}, u'REQUIRE_BROADWELL': {}, u'PREFER_CORE2DUO': {}, u'PREFER_CONROE': {}, u'REQUIRE_CORE2DUO': {}, u'REQUIRE_CONROE': {}, u'PREFER_SANDYBRIDGE': {}, u'REQUIRE_HASWELL': {}, u'PREFER_PENRYN': {}, u'PREFER_IVYBRIDGE': {}, u'REQUIRE_NEHALEM': {}},), is_leaf=True, yang_name="cpu-model", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__cpu_model = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_cpu_model(self):
        self.__cpu_model = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'REQUIRE_IVYBRIDGE': {} ,
                                                                                  u'PREFER_HASWELL': {} ,
                                                                                  u'PREFER_WESTMERE': {} ,
                                                                                  u'REQUIRE_WESTMERE': {} ,
                                                                                  u'PREFER_NEHALEM': {} ,
                                                                                  u'REQUIRE_PENRYN': {} ,
                                                                                  u'REQUIRE_SANDYBRIDGE': {} ,
                                                                                  u'PREFER_BROADWELL': {} ,
                                                                                  u'REQUIRE_BROADWELL': {} ,
                                                                                  u'PREFER_CORE2DUO': {} ,
                                                                                  u'PREFER_CONROE': {} ,
                                                                                  u'REQUIRE_CORE2DUO': {} ,
                                                                                  u'REQUIRE_CONROE': {} ,
                                                                                  u'PREFER_SANDYBRIDGE': {} ,
                                                                                  u'REQUIRE_HASWELL': {} ,
                                                                                  u'PREFER_PENRYN': {} ,
                                                                                  u'PREFER_IVYBRIDGE': {} ,
                                                                                  u'REQUIRE_NEHALEM': {}} , ) ,
                                        is_leaf=True , yang_name="cpu-model" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                        defining_module='vnfd' , yang_type='enumeration' , is_config=True)

    def _get_cpu_arch(self):
        """
    Getter method for cpu_arch, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_arch (enumeration)

    YANG Description: Host CPU architecture.
    """
        return self.__cpu_arch

    def _set_cpu_arch(self , v , load=False):
        """
    Setter method for cpu_arch, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_arch (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_arch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_arch() directly.

    YANG Description: Host CPU architecture.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'REQUIRE_X86_64': {} ,
                                                                           u'PREFER_X86_64': {} , u'REQUIRE_X86': {} ,
                                                                           u'REQUIRE_ARMV7': {} , u'PREFER_X86': {} ,
                                                                           u'REQUIRE_IA64': {} , u'REQUIRE_ARMV8': {} ,
                                                                           u'REQUIRE_I686': {} , u'PREFER_ARMV7': {} ,
                                                                           u'PREFER_ARMV8': {} , u'PREFER_I686': {} ,
                                                                           u'PREFER_IA64': {}} , ) , is_leaf=True ,
                             yang_name="cpu-arch" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """cpu_arch must be of a type compatible with enumeration""" ,
                'defined-type': "vnfd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'REQUIRE_X86_64': {}, u'PREFER_X86_64': {}, u'REQUIRE_X86': {}, u'REQUIRE_ARMV7': {}, u'PREFER_X86': {}, u'REQUIRE_IA64': {}, u'REQUIRE_ARMV8': {}, u'REQUIRE_I686': {}, u'PREFER_ARMV7': {}, u'PREFER_ARMV8': {}, u'PREFER_I686': {}, u'PREFER_IA64': {}},), is_leaf=True, yang_name="cpu-arch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__cpu_arch = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_cpu_arch(self):
        self.__cpu_arch = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                restriction_arg={u'REQUIRE_X86_64': {} ,
                                                                                 u'PREFER_X86_64': {} ,
                                                                                 u'REQUIRE_X86': {} ,
                                                                                 u'REQUIRE_ARMV7': {} ,
                                                                                 u'PREFER_X86': {} ,
                                                                                 u'REQUIRE_IA64': {} ,
                                                                                 u'REQUIRE_ARMV8': {} ,
                                                                                 u'REQUIRE_I686': {} ,
                                                                                 u'PREFER_ARMV7': {} ,
                                                                                 u'PREFER_ARMV8': {} ,
                                                                                 u'PREFER_I686': {} ,
                                                                                 u'PREFER_IA64': {}} , ) ,
                                       is_leaf=True , yang_name="cpu-arch" , parent=self ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                       defining_module='vnfd' , yang_type='enumeration' , is_config=True)

    def _get_cpu_vendor(self):
        """
    Getter method for cpu_vendor, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_vendor (enumeration)

    YANG Description: Host CPU Vendor.
    """
        return self.__cpu_vendor

    def _set_cpu_vendor(self , v , load=False):
        """
    Setter method for cpu_vendor, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_vendor (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_vendor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_vendor() directly.

    YANG Description: Host CPU Vendor.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'PREFER_INTEL': {} , u'REQUIRE_INTEL': {} ,
                                                                           u'REQUIRE_AMD': {} , u'PREFER_AMD': {}} , ) ,
                             is_leaf=True , yang_name="cpu-vendor" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """cpu_vendor must be of a type compatible with enumeration""" ,
                'defined-type': "vnfd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'PREFER_INTEL': {}, u'REQUIRE_INTEL': {}, u'REQUIRE_AMD': {}, u'PREFER_AMD': {}},), is_leaf=True, yang_name="cpu-vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__cpu_vendor = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_cpu_vendor(self):
        self.__cpu_vendor = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                  restriction_arg={u'PREFER_INTEL': {} ,
                                                                                   u'REQUIRE_INTEL': {} ,
                                                                                   u'REQUIRE_AMD': {} ,
                                                                                   u'PREFER_AMD': {}} , ) ,
                                         is_leaf=True , yang_name="cpu-vendor" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='enumeration' , is_config=True)

    def _get_cpu_socket_count(self):
        """
    Getter method for cpu_socket_count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_socket_count (uint64)

    YANG Description: Number of sockets on the host.
    """
        return self.__cpu_socket_count

    def _set_cpu_socket_count(self , v , load=False):
        """
    Setter method for cpu_socket_count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_socket_count (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_socket_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_socket_count() directly.

    YANG Description: Number of sockets on the host.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="cpu-socket-count" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """cpu_socket_count must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-socket-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__cpu_socket_count = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_cpu_socket_count(self):
        self.__cpu_socket_count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="cpu-socket-count" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

    def _get_cpu_core_count(self):
        """
    Getter method for cpu_core_count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_core_count (uint64)

    YANG Description: Number of cores on the host.
    """
        return self.__cpu_core_count

    def _set_cpu_core_count(self , v , load=False):
        """
    Setter method for cpu_core_count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_core_count (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_core_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_core_count() directly.

    YANG Description: Number of cores on the host.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="cpu-core-count" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """cpu_core_count must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-core-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__cpu_core_count = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_cpu_core_count(self):
        self.__cpu_core_count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="cpu-core-count" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

    def _get_cpu_core_thread_count(self):
        """
    Getter method for cpu_core_thread_count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_core_thread_count (uint64)

    YANG Description: Number of threads per cores on the host.
    """
        return self.__cpu_core_thread_count

    def _set_cpu_core_thread_count(self , v , load=False):
        """
    Setter method for cpu_core_thread_count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_core_thread_count (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_core_thread_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_core_thread_count() directly.

    YANG Description: Number of threads per cores on the host.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True ,
                             yang_name="cpu-core-thread-count" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """cpu_core_thread_count must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="cpu-core-thread-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__cpu_core_thread_count = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_cpu_core_thread_count(self):
        self.__cpu_core_thread_count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="cpu-core-thread-count" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

    def _get_cpu_feature(self):
        """
    Getter method for cpu_feature, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_feature (list)

    YANG Description: List of CPU features.
    """
        return self.__cpu_feature

    def _set_cpu_feature(self , v , load=False):
        """
    Setter method for cpu_feature, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/cpu_feature (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_feature is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_feature() directly.

    YANG Description: List of CPU features.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("feature" ,
                                                   yc_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_cpu_feature ,
                                                   yang_name="cpu-feature" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='feature' , extensions=None) , is_container='list' ,
                             yang_name="cpu-feature" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """cpu_feature must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("feature",yc_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_cpu_feature, yang_name="cpu-feature", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='feature', extensions=None), is_container='list', yang_name="cpu-feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__cpu_feature = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_cpu_feature(self):
        self.__cpu_feature = YANGDynClass(
            base=YANGListType("feature" , yc_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_cpu_feature ,
                              yang_name="cpu-feature" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='feature' , extensions=None) ,
            is_container='list' , yang_name="cpu-feature" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    def _get_om_cpu_model_string(self):
        """
    Getter method for om_cpu_model_string, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/om_cpu_model_string (string)

    YANG Description: OpenMANO CPU model string
    """
        return self.__om_cpu_model_string

    def _set_om_cpu_model_string(self , v , load=False):
        """
    Setter method for om_cpu_model_string, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/om_cpu_model_string (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_om_cpu_model_string is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_om_cpu_model_string() directly.

    YANG Description: OpenMANO CPU model string
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="om-cpu-model-string" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """om_cpu_model_string must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="om-cpu-model-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__om_cpu_model_string = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_om_cpu_model_string(self):
        self.__om_cpu_model_string = YANGDynClass(base=unicode , is_leaf=True , yang_name="om-cpu-model-string" ,
                                                  parent=self , path_helper=self._path_helper ,
                                                  extmethods=self._extmethods , register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                  defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_om_cpu_feature(self):
        """
    Getter method for om_cpu_feature, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/om_cpu_feature (list)

    YANG Description: List of OpenMANO CPU features
    """
        return self.__om_cpu_feature

    def _set_om_cpu_feature(self , v , load=False):
        """
    Setter method for om_cpu_feature, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa/om_cpu_feature (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_om_cpu_feature is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_om_cpu_feature() directly.

    YANG Description: List of OpenMANO CPU features
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("feature" ,
                                                   yc_om_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_om_cpu_feature ,
                                                   yang_name="om-cpu-feature" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='feature' , extensions=None) , is_container='list' ,
                             yang_name="om-cpu-feature" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """om_cpu_feature must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("feature",yc_om_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_om_cpu_feature, yang_name="om-cpu-feature", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='feature', extensions=None), is_container='list', yang_name="om-cpu-feature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__om_cpu_feature = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_om_cpu_feature(self):
        self.__om_cpu_feature = YANGDynClass(
            base=YANGListType("feature" , yc_om_cpu_feature_vnfd__vnfd_catalog_vnfd_vdu_host_epa_om_cpu_feature ,
                              yang_name="om-cpu-feature" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='feature' , extensions=None) ,
            is_container='list' , yang_name="om-cpu-feature" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    cpu_model = __builtin__.property(_get_cpu_model , _set_cpu_model)
    cpu_arch = __builtin__.property(_get_cpu_arch , _set_cpu_arch)
    cpu_vendor = __builtin__.property(_get_cpu_vendor , _set_cpu_vendor)
    cpu_socket_count = __builtin__.property(_get_cpu_socket_count , _set_cpu_socket_count)
    cpu_core_count = __builtin__.property(_get_cpu_core_count , _set_cpu_core_count)
    cpu_core_thread_count = __builtin__.property(_get_cpu_core_thread_count , _set_cpu_core_thread_count)
    cpu_feature = __builtin__.property(_get_cpu_feature , _set_cpu_feature)
    om_cpu_model_string = __builtin__.property(_get_om_cpu_model_string , _set_om_cpu_model_string)
    om_cpu_feature = __builtin__.property(_get_om_cpu_feature , _set_om_cpu_feature)

    _pyangbind_elements = {'cpu_model': cpu_model , 'cpu_arch': cpu_arch , 'cpu_vendor': cpu_vendor ,
                           'cpu_socket_count': cpu_socket_count , 'cpu_core_count': cpu_core_count ,
                           'cpu_core_thread_count': cpu_core_thread_count , 'cpu_feature': cpu_feature ,
                           'om_cpu_model_string': om_cpu_model_string , 'om_cpu_feature': om_cpu_feature , }


class yc_ok_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_ok(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/alarm/actions/ok. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__url' ,)

    _yang_name = 'ok'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__url = YANGDynClass(base=unicode , is_leaf=True , yang_name="url" , parent=self ,
                                  path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                  is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                  defining_module='vnfd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'alarm' , u'actions' , u'ok']

    def _get_url(self):
        """
    Getter method for url, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/ok/url (string)
    """
        return self.__url

    def _set_url(self , v , load=False):
        """
    Setter method for url, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/ok/url (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_url is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_url() directly.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="url" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """url must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__url = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_url(self):
        self.__url = YANGDynClass(base=unicode , is_leaf=True , yang_name="url" , parent=self ,
                                  path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                  is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                  defining_module='vnfd' , yang_type='string' , is_config=True)

    url = __builtin__.property(_get_url , _set_url)

    _pyangbind_elements = {'url': url , }


class yc_insufficient_data_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_insufficient_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/alarm/actions/insufficient-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__url' ,)

    _yang_name = 'insufficient-data'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__url = YANGDynClass(base=unicode , is_leaf=True , yang_name="url" , parent=self ,
                                  path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                  is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                  defining_module='vnfd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'alarm' , u'actions' , u'insufficient-data']

    def _get_url(self):
        """
    Getter method for url, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/insufficient_data/url (string)
    """
        return self.__url

    def _set_url(self , v , load=False):
        """
    Setter method for url, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/insufficient_data/url (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_url is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_url() directly.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="url" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """url must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__url = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_url(self):
        self.__url = YANGDynClass(base=unicode , is_leaf=True , yang_name="url" , parent=self ,
                                  path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                  is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                  defining_module='vnfd' , yang_type='string' , is_config=True)

    url = __builtin__.property(_get_url , _set_url)

    _pyangbind_elements = {'url': url , }


class yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_alarm(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/alarm/actions/alarm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__url' ,)

    _yang_name = 'alarm'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__url = YANGDynClass(base=unicode , is_leaf=True , yang_name="url" , parent=self ,
                                  path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                  is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                  defining_module='vnfd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'alarm' , u'actions' , u'alarm']

    def _get_url(self):
        """
    Getter method for url, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/alarm/url (string)
    """
        return self.__url

    def _set_url(self , v , load=False):
        """
    Setter method for url, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/alarm/url (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_url is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_url() directly.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="url" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """url must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__url = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_url(self):
        self.__url = YANGDynClass(base=unicode , is_leaf=True , yang_name="url" , parent=self ,
                                  path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                  is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                  defining_module='vnfd' , yang_type='string' , is_config=True)

    url = __builtin__.property(_get_url , _set_url)

    _pyangbind_elements = {'url': url , }


class yc_actions_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/alarm/actions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__ok' , '__insufficient_data' , '__alarm' ,)

    _yang_name = 'actions'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__insufficient_data = YANGDynClass(
            base=YANGListType("url" , yc_insufficient_data_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_insufficient_data ,
                              yang_name="insufficient-data" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='url' , extensions=None) , is_container='list' ,
            yang_name="insufficient-data" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='list' , is_config=True)
        self.__alarm = YANGDynClass(
            base=YANGListType("url" , yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_alarm , yang_name="alarm" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='url' , extensions=None) , is_container='list' , yang_name="alarm" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='list' , is_config=True)
        self.__ok = YANGDynClass(
            base=YANGListType("url" , yc_ok_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_ok , yang_name="ok" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='url' , extensions=None) , is_container='list' , yang_name="ok" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'alarm' , u'actions']

    def _get_ok(self):
        """
    Getter method for ok, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/ok (list)
    """
        return self.__ok

    def _set_ok(self , v , load=False):
        """
    Setter method for ok, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/ok (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ok is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ok() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("url" , yc_ok_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_ok ,
                                                   yang_name="ok" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='url' , extensions=None) , is_container='list' ,
                             yang_name="ok" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ok must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("url",yc_ok_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_ok, yang_name="ok", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="ok", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__ok = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ok(self):
        self.__ok = YANGDynClass(
            base=YANGListType("url" , yc_ok_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_ok , yang_name="ok" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='url' , extensions=None) , is_container='list' , yang_name="ok" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    def _get_insufficient_data(self):
        """
    Getter method for insufficient_data, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/insufficient_data (list)
    """
        return self.__insufficient_data

    def _set_insufficient_data(self , v , load=False):
        """
    Setter method for insufficient_data, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/insufficient_data (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_insufficient_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_insufficient_data() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("url" ,
                                                   yc_insufficient_data_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_insufficient_data ,
                                                   yang_name="insufficient-data" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='url' , extensions=None) , is_container='list' ,
                             yang_name="insufficient-data" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """insufficient_data must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("url",yc_insufficient_data_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_insufficient_data, yang_name="insufficient-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="insufficient-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__insufficient_data = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_insufficient_data(self):
        self.__insufficient_data = YANGDynClass(
            base=YANGListType("url" , yc_insufficient_data_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_insufficient_data ,
                              yang_name="insufficient-data" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='url' , extensions=None) , is_container='list' ,
            yang_name="insufficient-data" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='list' , is_config=True)

    def _get_alarm(self):
        """
    Getter method for alarm, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/alarm (list)
    """
        return self.__alarm

    def _set_alarm(self , v , load=False):
        """
    Setter method for alarm, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions/alarm (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("url" , yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_alarm ,
                                                   yang_name="alarm" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='url' , extensions=None) , is_container='list' ,
                             yang_name="alarm" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """alarm must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("url",yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__alarm = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_alarm(self):
        self.__alarm = YANGDynClass(
            base=YANGListType("url" , yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions_alarm , yang_name="alarm" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='url' , extensions=None) , is_container='list' , yang_name="alarm" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='list' , is_config=True)

    ok = __builtin__.property(_get_ok , _set_ok)
    insufficient_data = __builtin__.property(_get_insufficient_data , _set_insufficient_data)
    alarm = __builtin__.property(_get_alarm , _set_alarm)

    _pyangbind_elements = {'ok': ok , 'insufficient_data': insufficient_data , 'alarm': alarm , }


class yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/alarm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__alarm_id' , '__name' , '__description' , '__vdur_id' , '__actions' ,
    '__repeat' , '__enabled' , '__severity' , '__metric' , '__statistic' , '__operation' , '__value' , '__period' ,
    '__evaluations' ,)

    _yang_name = 'alarm'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__repeat = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="repeat" ,
                                     parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                     register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                     defining_module='vnfd' , yang_type='boolean' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)
        self.__vdur_id = YANGDynClass(base=unicode , is_leaf=True , yang_name="vdur-id" , parent=self ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                      defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__severity = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                restriction_arg={u'CRITICAL': {} , u'MODERATE': {} ,
                                                                                 u'LOW': {}} , ) , is_leaf=True ,
                                       yang_name="severity" , parent=self , path_helper=self._path_helper ,
                                       extmethods=self._extmethods , register_paths=True ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='alarm-severity-type' , is_config=True)
        self.__metric = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                              restriction_arg={u'STORAGE_UTILIZATION': {} ,
                                                                               u'MEMORY_UTILIZATION': {} ,
                                                                               u'CPU_UTILIZATION': {}} , ) ,
                                     is_leaf=True , yang_name="metric" , parent=self , path_helper=self._path_helper ,
                                     extmethods=self._extmethods , register_paths=True ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                     yang_type='alarm-metric-type' , is_config=True)
        self.__enabled = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="enabled" ,
                                      parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                      defining_module='vnfd' , yang_type='boolean' , is_config=True)
        self.__period = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="period" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)
        self.__actions = YANGDynClass(base=yc_actions_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions ,
                                      is_container='container' , yang_name="actions" , parent=self ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , extensions=None ,
                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                      yang_type='container' , is_config=True)
        self.__alarm_id = YANGDynClass(base=unicode , is_leaf=True , yang_name="alarm-id" , parent=self ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , is_keyval=True ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='string' , is_config=True)
        self.__value = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4) , is_leaf=True ,
                                    yang_name="value" , parent=self , path_helper=self._path_helper ,
                                    extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='decimal64' , is_config=True)
        self.__statistic = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'COUNT': {} , u'AVERAGE': {} ,
                                                                                  u'MINIMUM': {} , u'SUM': {} ,
                                                                                  u'MAXIMUM': {}} , ) , is_leaf=True ,
                                        yang_name="statistic" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='alarm-statistic-type' , is_config=True)
        self.__operation = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'GE': {} , u'LE': {} , u'EQ': {} ,
                                                                                  u'LT': {} , u'GT': {}} , ) ,
                                        is_leaf=True , yang_name="operation" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                        defining_module='vnfd' , yang_type='relational-operation-type' , is_config=True)
        self.__evaluations = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="evaluations" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'alarm']

    def _get_alarm_id(self):
        """
    Getter method for alarm_id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/alarm_id (string)

    YANG Description: This field is reserved for the identifier assigned by the VIM provider
    """
        return self.__alarm_id

    def _set_alarm_id(self , v , load=False):
        """
    Setter method for alarm_id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/alarm_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm_id() directly.

    YANG Description: This field is reserved for the identifier assigned by the VIM provider
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="alarm-id" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """alarm_id must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="alarm-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__alarm_id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_alarm_id(self):
        self.__alarm_id = YANGDynClass(base=unicode , is_leaf=True , yang_name="alarm-id" , parent=self ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , is_keyval=True ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='string' , is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/name (string)

    YANG Description: A human readable string to identify the alarm
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: A human readable string to identify the alarm
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/description (string)

    YANG Description: A description of this alarm
    """
        return self.__description

    def _set_description(self , v , load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: A description of this alarm
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__description = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_vdur_id(self):
        """
    Getter method for vdur_id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/vdur_id (string)

    YANG Description: The identifier of the VDUR that the alarm is associated with
    """
        return self.__vdur_id

    def _set_vdur_id(self , v , load=False):
        """
    Setter method for vdur_id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/vdur_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdur_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdur_id() directly.

    YANG Description: The identifier of the VDUR that the alarm is associated with
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vdur-id" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vdur_id must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vdur-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__vdur_id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vdur_id(self):
        self.__vdur_id = YANGDynClass(base=unicode , is_leaf=True , yang_name="vdur-id" , parent=self ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                      defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_actions(self):
        """
    Getter method for actions, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions (container)
    """
        return self.__actions

    def _set_actions(self , v , load=False):
        """
    Setter method for actions, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/actions (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_actions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_actions() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_actions_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions , is_container='container' ,
                             yang_name="actions" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """actions must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_actions_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions, is_container='container', yang_name="actions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__actions = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_actions(self):
        self.__actions = YANGDynClass(base=yc_actions_vnfd__vnfd_catalog_vnfd_vdu_alarm_actions ,
                                      is_container='container' , yang_name="actions" , parent=self ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , extensions=None ,
                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                      yang_type='container' , is_config=True)

    def _get_repeat(self):
        """
    Getter method for repeat, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/repeat (boolean)

    YANG Description: This flag indicates whether the alarm should be repeatedly emitted
while the associated threshold has been crossed.
    """
        return self.__repeat

    def _set_repeat(self , v , load=False):
        """
    Setter method for repeat, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/repeat (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_repeat is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_repeat() directly.

    YANG Description: This flag indicates whether the alarm should be repeatedly emitted
while the associated threshold has been crossed.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="repeat" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """repeat must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__repeat = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_repeat(self):
        self.__repeat = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="repeat" ,
                                     parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                     register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                     defining_module='vnfd' , yang_type='boolean' , is_config=True)

    def _get_enabled(self):
        """
    Getter method for enabled, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/enabled (boolean)

    YANG Description: This flag indicates whether the alarm has been enabled or
disabled.
    """
        return self.__enabled

    def _set_enabled(self , v , load=False):
        """
    Setter method for enabled, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This flag indicates whether the alarm has been enabled or
disabled.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="enabled" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """enabled must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__enabled = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_enabled(self):
        self.__enabled = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="enabled" ,
                                      parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                      defining_module='vnfd' , yang_type='boolean' , is_config=True)

    def _get_severity(self):
        """
    Getter method for severity, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/severity (alarm-severity-type)

    YANG Description: A measure of the importance or urgency of the alarm
    """
        return self.__severity

    def _set_severity(self , v , load=False):
        """
    Setter method for severity, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/severity (alarm-severity-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_severity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_severity() directly.

    YANG Description: A measure of the importance or urgency of the alarm
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'CRITICAL': {} , u'MODERATE': {} ,
                                                                           u'LOW': {}} , ) , is_leaf=True ,
                             yang_name="severity" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='alarm-severity-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """severity must be of a type compatible with alarm-severity-type""" ,
                'defined-type': "vnfd:alarm-severity-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'CRITICAL': {}, u'MODERATE': {}, u'LOW': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='alarm-severity-type', is_config=True)""" ,
            })

        self.__severity = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_severity(self):
        self.__severity = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                restriction_arg={u'CRITICAL': {} , u'MODERATE': {} ,
                                                                                 u'LOW': {}} , ) , is_leaf=True ,
                                       yang_name="severity" , parent=self , path_helper=self._path_helper ,
                                       extmethods=self._extmethods , register_paths=True ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='alarm-severity-type' , is_config=True)

    def _get_metric(self):
        """
    Getter method for metric, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/metric (alarm-metric-type)

    YANG Description: The metric to be tracked by this alarm.
    """
        return self.__metric

    def _set_metric(self , v , load=False):
        """
    Setter method for metric, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/metric (alarm-metric-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric() directly.

    YANG Description: The metric to be tracked by this alarm.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'STORAGE_UTILIZATION': {} ,
                                                                           u'MEMORY_UTILIZATION': {} ,
                                                                           u'CPU_UTILIZATION': {}} , ) , is_leaf=True ,
                             yang_name="metric" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='alarm-metric-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """metric must be of a type compatible with alarm-metric-type""" ,
                'defined-type': "vnfd:alarm-metric-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'STORAGE_UTILIZATION': {}, u'MEMORY_UTILIZATION': {}, u'CPU_UTILIZATION': {}},), is_leaf=True, yang_name="metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='alarm-metric-type', is_config=True)""" ,
            })

        self.__metric = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_metric(self):
        self.__metric = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                              restriction_arg={u'STORAGE_UTILIZATION': {} ,
                                                                               u'MEMORY_UTILIZATION': {} ,
                                                                               u'CPU_UTILIZATION': {}} , ) ,
                                     is_leaf=True , yang_name="metric" , parent=self , path_helper=self._path_helper ,
                                     extmethods=self._extmethods , register_paths=True ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                     yang_type='alarm-metric-type' , is_config=True)

    def _get_statistic(self):
        """
    Getter method for statistic, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/statistic (alarm-statistic-type)

    YANG Description: The type of metric statistic that is tracked by this alarm
    """
        return self.__statistic

    def _set_statistic(self , v , load=False):
        """
    Setter method for statistic, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/statistic (alarm-statistic-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistic() directly.

    YANG Description: The type of metric statistic that is tracked by this alarm
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'COUNT': {} , u'AVERAGE': {} ,
                                                                           u'MINIMUM': {} , u'SUM': {} ,
                                                                           u'MAXIMUM': {}} , ) , is_leaf=True ,
                             yang_name="statistic" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='alarm-statistic-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """statistic must be of a type compatible with alarm-statistic-type""" ,
                'defined-type': "vnfd:alarm-statistic-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'COUNT': {}, u'AVERAGE': {}, u'MINIMUM': {}, u'SUM': {}, u'MAXIMUM': {}},), is_leaf=True, yang_name="statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='alarm-statistic-type', is_config=True)""" ,
            })

        self.__statistic = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_statistic(self):
        self.__statistic = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'COUNT': {} , u'AVERAGE': {} ,
                                                                                  u'MINIMUM': {} , u'SUM': {} ,
                                                                                  u'MAXIMUM': {}} , ) , is_leaf=True ,
                                        yang_name="statistic" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='alarm-statistic-type' , is_config=True)

    def _get_operation(self):
        """
    Getter method for operation, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/operation (relational-operation-type)

    YANG Description: The relational operator used to define whether an alarm should be
triggered in certain scenarios, such as if the metric statistic
goes above or below a specified value.
    """
        return self.__operation

    def _set_operation(self , v , load=False):
        """
    Setter method for operation, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/operation (relational-operation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operation() directly.

    YANG Description: The relational operator used to define whether an alarm should be
triggered in certain scenarios, such as if the metric statistic
goes above or below a specified value.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'GE': {} , u'LE': {} , u'EQ': {} ,
                                                                           u'LT': {} , u'GT': {}} , ) , is_leaf=True ,
                             yang_name="operation" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='relational-operation-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """operation must be of a type compatible with relational-operation-type""" ,
                'defined-type': "vnfd:relational-operation-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), is_leaf=True, yang_name="operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='relational-operation-type', is_config=True)""" ,
            })

        self.__operation = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_operation(self):
        self.__operation = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'GE': {} , u'LE': {} , u'EQ': {} ,
                                                                                  u'LT': {} , u'GT': {}} , ) ,
                                        is_leaf=True , yang_name="operation" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                        defining_module='vnfd' , yang_type='relational-operation-type' , is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/value (decimal64)

    YANG Description: This value defines the threshold that, if crossed, will trigger
the alarm.
    """
        return self.__value

    def _set_value(self , v , load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/value (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: This value defines the threshold that, if crossed, will trigger
the alarm.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedPrecisionDecimalType(precision=4) , is_leaf=True , yang_name="value" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='decimal64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with decimal64""" ,
                'defined-type': "decimal64" ,
                'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)""" ,
            })

        self.__value = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4) , is_leaf=True ,
                                    yang_name="value" , parent=self , path_helper=self._path_helper ,
                                    extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='decimal64' , is_config=True)

    def _get_period(self):
        """
    Getter method for period, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/period (uint32)

    YANG Description: The period defines the length of time (seconds) that the metric
data are collected over in oreder to evaluate the chosen
statistic.
    """
        return self.__period

    def _set_period(self , v , load=False):
        """
    Setter method for period, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/period (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_period() directly.

    YANG Description: The period defines the length of time (seconds) that the metric
data are collected over in oreder to evaluate the chosen
statistic.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , is_leaf=True , yang_name="period" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """period must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""" ,
            })

        self.__period = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_period(self):
        self.__period = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="period" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)

    def _get_evaluations(self):
        """
    Getter method for evaluations, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/evaluations (uint32)

    YANG Description: Defines the length of time (seconds) in which metric data are
collected in order to evaluate the chosen statistic.
    """
        return self.__evaluations

    def _set_evaluations(self , v , load=False):
        """
    Setter method for evaluations, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm/evaluations (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_evaluations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_evaluations() directly.

    YANG Description: Defines the length of time (seconds) in which metric data are
collected in order to evaluate the chosen statistic.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , is_leaf=True , yang_name="evaluations" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """evaluations must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="evaluations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""" ,
            })

        self.__evaluations = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_evaluations(self):
        self.__evaluations = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="evaluations" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)

    alarm_id = __builtin__.property(_get_alarm_id , _set_alarm_id)
    name = __builtin__.property(_get_name , _set_name)
    description = __builtin__.property(_get_description , _set_description)
    vdur_id = __builtin__.property(_get_vdur_id , _set_vdur_id)
    actions = __builtin__.property(_get_actions , _set_actions)
    repeat = __builtin__.property(_get_repeat , _set_repeat)
    enabled = __builtin__.property(_get_enabled , _set_enabled)
    severity = __builtin__.property(_get_severity , _set_severity)
    metric = __builtin__.property(_get_metric , _set_metric)
    statistic = __builtin__.property(_get_statistic , _set_statistic)
    operation = __builtin__.property(_get_operation , _set_operation)
    value = __builtin__.property(_get_value , _set_value)
    period = __builtin__.property(_get_period , _set_period)
    evaluations = __builtin__.property(_get_evaluations , _set_evaluations)

    _pyangbind_elements = {'alarm_id': alarm_id , 'name': name , 'description': description , 'vdur_id': vdur_id ,
                           'actions': actions , 'repeat': repeat , 'enabled': enabled , 'severity': severity ,
                           'metric': metric , 'statistic': statistic , 'operation': operation , 'value': value ,
                           'period': period , 'evaluations': evaluations , }


class yc_alternative_images_vnfd__vnfd_catalog_vnfd_vdu_alternative_images(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/alternative-images. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of alternative images per VIM type.
Different images can be used for specific types of VIMs instead
of the default image. This allows deployments in sites where the
image identifier in the VIM is given by the VIM provider and
cannot be modified.
If an alternative image is specified for a VIM type, it will prevail
over the default image
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__vim_type' , '__image' , '__image_checksum' ,)

    _yang_name = 'alternative-images'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__image = YANGDynClass(base=unicode , is_leaf=True , yang_name="image" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)
        self.__vim_type = YANGDynClass(base=unicode , is_leaf=True , yang_name="vim-type" , parent=self ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , is_keyval=True ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='string' , is_config=True)
        self.__image_checksum = YANGDynClass(base=unicode , is_leaf=True , yang_name="image-checksum" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'alternative-images']

    def _get_vim_type(self):
        """
    Getter method for vim_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alternative_images/vim_type (string)

    YANG Description: VIM type: openvim, openstack, vmware, aws, etc.
    """
        return self.__vim_type

    def _set_vim_type(self , v , load=False):
        """
    Setter method for vim_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alternative_images/vim_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vim_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vim_type() directly.

    YANG Description: VIM type: openvim, openstack, vmware, aws, etc.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vim-type" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vim_type must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vim-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__vim_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vim_type(self):
        self.__vim_type = YANGDynClass(base=unicode , is_leaf=True , yang_name="vim-type" , parent=self ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , is_keyval=True ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='string' , is_config=True)

    def _get_image(self):
        """
    Getter method for image, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alternative_images/image (string)

    YANG Description: Image name for the software image.
If the image name is found within the VNF package it will
be uploaded to all VIM accounts during onboarding process.
Otherwise, the image must be added to the VIM account with
the same name as entered here.

    """
        return self.__image

    def _set_image(self , v , load=False):
        """
    Setter method for image, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alternative_images/image (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image() directly.

    YANG Description: Image name for the software image.
If the image name is found within the VNF package it will
be uploaded to all VIM accounts during onboarding process.
Otherwise, the image must be added to the VIM account with
the same name as entered here.

    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="image" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """image must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__image = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_image(self):
        self.__image = YANGDynClass(base=unicode , is_leaf=True , yang_name="image" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)

    def _get_image_checksum(self):
        """
    Getter method for image_checksum, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alternative_images/image_checksum (string)

    YANG Description: Image md5sum for the software image.
The md5sum, if provided, along with the image name uniquely
identifies an image uploaded to the CAL.

    """
        return self.__image_checksum

    def _set_image_checksum(self , v , load=False):
        """
    Setter method for image_checksum, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alternative_images/image_checksum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image_checksum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image_checksum() directly.

    YANG Description: Image md5sum for the software image.
The md5sum, if provided, along with the image name uniquely
identifies an image uploaded to the CAL.

    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="image-checksum" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """image_checksum must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="image-checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__image_checksum = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_image_checksum(self):
        self.__image_checksum = YANGDynClass(base=unicode , is_leaf=True , yang_name="image-checksum" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='string' , is_config=True)

    vim_type = __builtin__.property(_get_vim_type , _set_vim_type)
    image = __builtin__.property(_get_image , _set_image)
    image_checksum = __builtin__.property(_get_image_checksum , _set_image_checksum)

    _pyangbind_elements = {'vim_type': vim_type , 'image': image , 'image_checksum': image_checksum , }


class yc_script_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_script(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/script. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__script_type' ,)

    _yang_name = 'script'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                   restriction_arg={u'rift': {}} , ) , is_leaf=True ,
                                          yang_name="script-type" , parent=self ,
                                          choice=(u'config-method' , u'script') , path_helper=self._path_helper ,
                                          extmethods=self._extmethods , register_paths=True ,
                                          namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                          yang_type='enumeration' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'vdu-configuration' , u'script']

    def _get_script_type(self):
        """
    Getter method for script_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/script/script_type (enumeration)

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
        return self.__script_type

    def _set_script_type(self , v , load=False):
        """
    Setter method for script_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/script/script_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script_type() directly.

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'rift': {}} , ) , is_leaf=True ,
                             yang_name="script-type" , parent=self , choice=(u'config-method' , u'script') ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """script_type must be of a type compatible with enumeration""" ,
                'defined-type': "vnfd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__script_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_script_type(self):
        self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                   restriction_arg={u'rift': {}} , ) , is_leaf=True ,
                                          yang_name="script-type" , parent=self ,
                                          choice=(u'config-method' , u'script') , path_helper=self._path_helper ,
                                          extmethods=self._extmethods , register_paths=True ,
                                          namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                          yang_type='enumeration' , is_config=True)

    script_type = __builtin__.property(_get_script_type , _set_script_type)

    __choices__ = {u'config-method': {u'script': [u'script_type']}}
    _pyangbind_elements = {'script_type': script_type , }


class yc_relation_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju_vca_relationships_relation(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/juju/vca-relationships/relation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of relations between VCA componets.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__requires' , '__provides' ,)

    _yang_name = 'relation'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__requires = YANGDynClass(base=unicode , is_leaf=True , yang_name="requires" , parent=self ,
                                       choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                       extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='string' , is_config=True)
        self.__provides = YANGDynClass(base=unicode , is_leaf=True , yang_name="provides" , parent=self ,
                                       choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                       extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'vdu-configuration' , u'juju' , u'vca-relationships' ,
                    u'relation']

    def _get_requires(self):
        """
    Getter method for requires, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/vca_relationships/relation/requires (string)

    YANG Description: Name of the required relation.
    """
        return self.__requires

    def _set_requires(self , v , load=False):
        """
    Setter method for requires, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/vca_relationships/relation/requires (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_requires is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_requires() directly.

    YANG Description: Name of the required relation.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="requires" , parent=self ,
                             choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """requires must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="requires", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__requires = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_requires(self):
        self.__requires = YANGDynClass(base=unicode , is_leaf=True , yang_name="requires" , parent=self ,
                                       choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                       extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='string' , is_config=True)

    def _get_provides(self):
        """
    Getter method for provides, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/vca_relationships/relation/provides (string)

    YANG Description: Name of the provided relation.
    """
        return self.__provides

    def _set_provides(self , v , load=False):
        """
    Setter method for provides, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/vca_relationships/relation/provides (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provides is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provides() directly.

    YANG Description: Name of the provided relation.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="provides" , parent=self ,
                             choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """provides must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="provides", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__provides = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_provides(self):
        self.__provides = YANGDynClass(base=unicode , is_leaf=True , yang_name="provides" , parent=self ,
                                       choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                       extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='string' , is_config=True)

    requires = __builtin__.property(_get_requires , _set_requires)
    provides = __builtin__.property(_get_provides , _set_provides)

    __choices__ = {u'config-method': {u'juju': [u'requires' , u'provides']}}
    _pyangbind_elements = {'requires': requires , 'provides': provides , }


class yc_vca_relationships_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju_vca_relationships(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/juju/vca-relationships. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__relation' ,)

    _yang_name = 'vca-relationships'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__relation = YANGDynClass(base=YANGListType("requires provides" ,
                                                         yc_relation_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju_vca_relationships_relation ,
                                                         yang_name="relation" , parent=self , is_container='list' ,
                                                         user_ordered=False , path_helper=self._path_helper ,
                                                         yang_keys='requires provides' , extensions=None ,
                                                         choice=(u'config-method' , u'juju')) , is_container='list' ,
                                       yang_name="relation" , parent=self , choice=(u'config-method' , u'juju') ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , extensions=None ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='list' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'vdu-configuration' , u'juju' , u'vca-relationships']

    def _get_relation(self):
        """
    Getter method for relation, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/vca_relationships/relation (list)

    YANG Description: List of relations between VCA componets.
    """
        return self.__relation

    def _set_relation(self , v , load=False):
        """
    Setter method for relation, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/vca_relationships/relation (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relation() directly.

    YANG Description: List of relations between VCA componets.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("requires provides" ,
                                                   yc_relation_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju_vca_relationships_relation ,
                                                   yang_name="relation" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='requires provides' , extensions=None ,
                                                   choice=(u'config-method' , u'juju')) , is_container='list' ,
                             yang_name="relation" , parent=self , choice=(u'config-method' , u'juju') ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """relation must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("requires provides",yc_relation_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju_vca_relationships_relation, yang_name="relation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='requires provides', extensions=None, choice=(u'config-method', u'juju')), is_container='list', yang_name="relation", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__relation = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_relation(self):
        self.__relation = YANGDynClass(base=YANGListType("requires provides" ,
                                                         yc_relation_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju_vca_relationships_relation ,
                                                         yang_name="relation" , parent=self , is_container='list' ,
                                                         user_ordered=False , path_helper=self._path_helper ,
                                                         yang_keys='requires provides' , extensions=None ,
                                                         choice=(u'config-method' , u'juju')) , is_container='list' ,
                                       yang_name="relation" , parent=self , choice=(u'config-method' , u'juju') ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , extensions=None ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='list' , is_config=True)

    relation = __builtin__.property(_get_relation , _set_relation)

    __choices__ = {u'config-method': {u'juju': [u'relation']}}
    _pyangbind_elements = {'relation': relation , }


class yc_juju_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/juju. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__charm' , '__proxy' , '__vca_relationships' ,)

    _yang_name = 'juju'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vca_relationships = YANGDynClass(
            base=yc_vca_relationships_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju_vca_relationships ,
            is_container='container' , yang_name="vca-relationships" , parent=self ,
            choice=(u'config-method' , u'juju') , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='container' , is_config=True)
        self.__charm = YANGDynClass(base=unicode , is_leaf=True , yang_name="charm" , parent=self ,
                                    choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                    extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)
        self.__proxy = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="proxy" ,
                                    parent=self , choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                    extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='boolean' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'vdu-configuration' , u'juju']

    def _get_charm(self):
        """
    Getter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/charm (string)

    YANG Description: Juju charm to use with the VNF or VDU.
    """
        return self.__charm

    def _set_charm(self , v , load=False):
        """
    Setter method for charm, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/charm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_charm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_charm() directly.

    YANG Description: Juju charm to use with the VNF or VDU.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="charm" , parent=self ,
                             choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """charm must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="charm", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__charm = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_charm(self):
        self.__charm = YANGDynClass(base=unicode , is_leaf=True , yang_name="charm" , parent=self ,
                                    choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                    extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)

    def _get_proxy(self):
        """
    Getter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/proxy (boolean)

    YANG Description: Is this a proxy charm?
    """
        return self.__proxy

    def _set_proxy(self , v , load=False):
        """
    Setter method for proxy, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/proxy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy() directly.

    YANG Description: Is this a proxy charm?
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="proxy" ,
                             parent=self , choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """proxy must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__proxy = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_proxy(self):
        self.__proxy = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="proxy" ,
                                    parent=self , choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                    extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='boolean' , is_config=True)

    def _get_vca_relationships(self):
        """
    Getter method for vca_relationships, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/vca_relationships (container)
    """
        return self.__vca_relationships

    def _set_vca_relationships(self , v , load=False):
        """
    Setter method for vca_relationships, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju/vca_relationships (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vca_relationships is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vca_relationships() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=yc_vca_relationships_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju_vca_relationships ,
                             is_container='container' , yang_name="vca-relationships" , parent=self ,
                             choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vca_relationships must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_vca_relationships_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju_vca_relationships, is_container='container', yang_name="vca-relationships", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__vca_relationships = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vca_relationships(self):
        self.__vca_relationships = YANGDynClass(
            base=yc_vca_relationships_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju_vca_relationships ,
            is_container='container' , yang_name="vca-relationships" , parent=self ,
            choice=(u'config-method' , u'juju') , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='container' , is_config=True)

    charm = __builtin__.property(_get_charm , _set_charm)
    proxy = __builtin__.property(_get_proxy , _set_proxy)
    vca_relationships = __builtin__.property(_get_vca_relationships , _set_vca_relationships)

    __choices__ = {u'config-method': {u'juju': [u'charm' , u'proxy' , u'vca_relationships']}}
    _pyangbind_elements = {'charm': charm , 'proxy': proxy , 'vca_relationships': vca_relationships , }


class yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the config primitive.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__name' , '__data_type' , '__mandatory' , '__default_value' , '__parameter_pool' ,
    '__read_only' , '__hidden' ,)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__default_value = YANGDynClass(base=unicode , is_leaf=True , yang_name="default-value" , parent=self ,
                                            path_helper=self._path_helper , extmethods=self._extmethods ,
                                            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                            defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__read_only = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                        yang_name="read-only" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='boolean' , is_config=True)
        self.__mandatory = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                        yang_name="mandatory" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='boolean' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                                  u'STRING': {}} , ) , is_leaf=True ,
                                        yang_name="data-type" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='manotypes:parameter-data-type' , is_config=True)
        self.__parameter_pool = YANGDynClass(base=unicode , is_leaf=True , yang_name="parameter-pool" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__hidden = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="hidden" ,
                                     parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                     register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                     defining_module='vnfd' , yang_type='boolean' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'vdu-configuration' , u'config-primitive' , u'parameter']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_data_type(self):
        """
    Getter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the name.
    """
        return self.__data_type

    def _set_data_type(self , v , load=False):
        """
    Setter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the name.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                           u'STRING': {}} , ) , is_leaf=True ,
                             yang_name="data-type" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='manotypes:parameter-data-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""" ,
                'defined-type': "manotypes:parameter-data-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)""" ,
            })

        self.__data_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_data_type(self):
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                                  u'STRING': {}} , ) , is_leaf=True ,
                                        yang_name="data-type" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='manotypes:parameter-data-type' , is_config=True)

    def _get_mandatory(self):
        """
    Getter method for mandatory, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/mandatory (boolean)

    YANG Description: Is this field mandatory
    """
        return self.__mandatory

    def _set_mandatory(self , v , load=False):
        """
    Setter method for mandatory, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mandatory() directly.

    YANG Description: Is this field mandatory
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="mandatory" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """mandatory must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__mandatory = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_mandatory(self):
        self.__mandatory = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                        yang_name="mandatory" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='boolean' , is_config=True)

    def _get_default_value(self):
        """
    Getter method for default_value, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/default_value (string)

    YANG Description: The default value for this field
    """
        return self.__default_value

    def _set_default_value(self , v , load=False):
        """
    Setter method for default_value, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/default_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_value() directly.

    YANG Description: The default value for this field
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="default-value" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """default_value must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__default_value = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_default_value(self):
        self.__default_value = YANGDynClass(base=unicode , is_leaf=True , yang_name="default-value" , parent=self ,
                                            path_helper=self._path_helper , extmethods=self._extmethods ,
                                            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                            defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_parameter_pool(self):
        """
    Getter method for parameter_pool, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/parameter_pool (string)

    YANG Description: NSD parameter pool name to use for this parameter
    """
        return self.__parameter_pool

    def _set_parameter_pool(self , v , load=False):
        """
    Setter method for parameter_pool, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/parameter_pool (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter_pool() directly.

    YANG Description: NSD parameter pool name to use for this parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="parameter-pool" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """parameter_pool must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__parameter_pool = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_parameter_pool(self):
        self.__parameter_pool = YANGDynClass(base=unicode , is_leaf=True , yang_name="parameter-pool" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_read_only(self):
        """
    Getter method for read_only, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/read_only (boolean)

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
        return self.__read_only

    def _set_read_only(self , v , load=False):
        """
    Setter method for read_only, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/read_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_read_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_read_only() directly.

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="read-only" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """read_only must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__read_only = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_read_only(self):
        self.__read_only = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                        yang_name="read-only" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='boolean' , is_config=True)

    def _get_hidden(self):
        """
    Getter method for hidden, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/hidden (boolean)

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
        return self.__hidden

    def _set_hidden(self , v , load=False):
        """
    Setter method for hidden, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter/hidden (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hidden is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hidden() directly.

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="hidden" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """hidden must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__hidden = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_hidden(self):
        self.__hidden = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="hidden" ,
                                     parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                     register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                     defining_module='vnfd' , yang_type='boolean' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    data_type = __builtin__.property(_get_data_type , _set_data_type)
    mandatory = __builtin__.property(_get_mandatory , _set_mandatory)
    default_value = __builtin__.property(_get_default_value , _set_default_value)
    parameter_pool = __builtin__.property(_get_parameter_pool , _set_parameter_pool)
    read_only = __builtin__.property(_get_read_only , _set_read_only)
    hidden = __builtin__.property(_get_hidden , _set_hidden)

    _pyangbind_elements = {'name': name , 'data_type': data_type , 'mandatory': mandatory ,
                           'default_value': default_value , 'parameter_pool': parameter_pool , 'read_only': read_only ,
                           'hidden': hidden , }


class yc_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__parameter' , '__user_defined_script' ,)

    _yang_name = 'config-primitive'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__user_defined_script = YANGDynClass(base=unicode , is_leaf=True , yang_name="user-defined-script" ,
                                                  parent=self , path_helper=self._path_helper ,
                                                  extmethods=self._extmethods , register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                  defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__parameter = YANGDynClass(base=YANGListType("name" ,
                                                          yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive_parameter ,
                                                          yang_name="parameter" , parent=self , is_container='list' ,
                                                          user_ordered=False , path_helper=self._path_helper ,
                                                          yang_keys='name' , extensions=None) , is_container='list' ,
                                        yang_name="parameter" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True , extensions=None ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='list' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'vdu-configuration' , u'config-primitive']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/name (string)

    YANG Description: Name of the config primitive.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the config primitive.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter (list)

    YANG Description: List of parameters to the config primitive.
    """
        return self.__parameter

    def _set_parameter(self , v , load=False):
        """
    Setter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the config primitive.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" ,
                                                   yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive_parameter ,
                                                   yang_name="parameter" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="parameter" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__parameter = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("name" ,
                                                          yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive_parameter ,
                                                          yang_name="parameter" , parent=self , is_container='list' ,
                                                          user_ordered=False , path_helper=self._path_helper ,
                                                          yang_keys='name' , extensions=None) , is_container='list' ,
                                        yang_name="parameter" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True , extensions=None ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='list' , is_config=True)

    def _get_user_defined_script(self):
        """
    Getter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/user_defined_script (string)

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
        return self.__user_defined_script

    def _set_user_defined_script(self , v , load=False):
        """
    Setter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="user-defined-script" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """user_defined_script must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__user_defined_script = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_user_defined_script(self):
        self.__user_defined_script = YANGDynClass(base=unicode , is_leaf=True , yang_name="user-defined-script" ,
                                                  parent=self , path_helper=self._path_helper ,
                                                  extmethods=self._extmethods , register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                  defining_module='vnfd' , yang_type='string' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    parameter = __builtin__.property(_get_parameter , _set_parameter)
    user_defined_script = __builtin__.property(_get_user_defined_script , _set_user_defined_script)

    _pyangbind_elements = {'name': name , 'parameter': parameter , 'user_defined_script': user_defined_script , }


class yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/initial-config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the configuration primitive.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__data_type' , '__value' ,)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__value = YANGDynClass(base=unicode , is_leaf=True , yang_name="value" , parent=self ,
                                    choice=(u'primitive-type' , u'primitive-definition') ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   choice=(u'primitive-type' , u'primitive-definition') ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                                  u'STRING': {}} , ) , is_leaf=True ,
                                        yang_name="data-type" , parent=self ,
                                        choice=(u'primitive-type' , u'primitive-definition') ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                        defining_module='vnfd' , yang_type='manotypes:parameter-data-type' ,
                                        is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'vdu-configuration' , u'initial-config-primitive' ,
                    u'parameter']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             choice=(u'primitive-type' , u'primitive-definition') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   choice=(u'primitive-type' , u'primitive-definition') ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_data_type(self):
        """
    Getter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the value.
    """
        return self.__data_type

    def _set_data_type(self , v , load=False):
        """
    Setter method for data_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the value.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                           u'STRING': {}} , ) , is_leaf=True ,
                             yang_name="data-type" , parent=self ,
                             choice=(u'primitive-type' , u'primitive-definition') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='manotypes:parameter-data-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""" ,
                'defined-type': "manotypes:parameter-data-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='manotypes:parameter-data-type', is_config=True)""" ,
            })

        self.__data_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_data_type(self):
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                                  u'STRING': {}} , ) , is_leaf=True ,
                                        yang_name="data-type" , parent=self ,
                                        choice=(u'primitive-type' , u'primitive-definition') ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                        defining_module='vnfd' , yang_type='manotypes:parameter-data-type' ,
                                        is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/parameter/value (string)

    YANG Description: Value associated with the name.
    """
        return self.__value

    def _set_value(self , v , load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value associated with the name.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="value" , parent=self ,
                             choice=(u'primitive-type' , u'primitive-definition') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="value", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__value = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=unicode , is_leaf=True , yang_name="value" , parent=self ,
                                    choice=(u'primitive-type' , u'primitive-definition') ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    data_type = __builtin__.property(_get_data_type , _set_data_type)
    value = __builtin__.property(_get_value , _set_value)

    __choices__ = {u'primitive-type': {u'primitive-definition': [u'name' , u'data_type' , u'value']}}
    _pyangbind_elements = {'name': name , 'data_type': data_type , 'value': value , }


class yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/initial-config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Initial set of configuration primitives.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__seq' , '__name' , '__parameter' , '__user_defined_script' ,)

    _yang_name = 'initial-config-primitive'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__user_defined_script = YANGDynClass(base=unicode , is_leaf=True , yang_name="user-defined-script" ,
                                                  parent=self , choice=(u'primitive-type' , u'primitive-definition') ,
                                                  path_helper=self._path_helper , extmethods=self._extmethods ,
                                                  register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                  defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__parameter = YANGDynClass(base=YANGListType("name" ,
                                                          yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive_parameter ,
                                                          yang_name="parameter" , parent=self , is_container='list' ,
                                                          user_ordered=False , path_helper=self._path_helper ,
                                                          yang_keys='name' , extensions=None , choice=False) ,
                                        is_container='list' , yang_name="parameter" , parent=self ,
                                        choice=(u'primitive-type' , u'primitive-definition') ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , extensions=None ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='list' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   choice=(u'primitive-type' , u'primitive-definition') ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)
        self.__seq = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="seq" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , is_keyval=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'vdu-configuration' , u'initial-config-primitive']

    def _get_seq(self):
        """
    Getter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
        return self.__seq

    def _set_seq(self , v , load=False):
        """
    Setter method for seq, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="seq" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """seq must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__seq = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_seq(self):
        self.__seq = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="seq" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , is_keyval=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/name (string)

    YANG Description: Name of the configuration primitive.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             choice=(u'primitive-type' , u'primitive-definition') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   choice=(u'primitive-type' , u'primitive-definition') ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/parameter (list)

    YANG Description: List of parameters to the configuration primitive.
    """
        return self.__parameter

    def _set_parameter(self , v , load=False):
        """
    Setter method for parameter, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the configuration primitive.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" ,
                                                   yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive_parameter ,
                                                   yang_name="parameter" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None , choice=False) ,
                             is_container='list' , yang_name="parameter" , parent=self ,
                             choice=(u'primitive-type' , u'primitive-definition') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__parameter = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("name" ,
                                                          yc_parameter_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive_parameter ,
                                                          yang_name="parameter" , parent=self , is_container='list' ,
                                                          user_ordered=False , path_helper=self._path_helper ,
                                                          yang_keys='name' , extensions=None , choice=False) ,
                                        is_container='list' , yang_name="parameter" , parent=self ,
                                        choice=(u'primitive-type' , u'primitive-definition') ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , extensions=None ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='list' , is_config=True)

    def _get_user_defined_script(self):
        """
    Getter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
        return self.__user_defined_script

    def _set_user_defined_script(self , v , load=False):
        """
    Setter method for user_defined_script, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="user-defined-script" , parent=self ,
                             choice=(u'primitive-type' , u'primitive-definition') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """user_defined_script must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="user-defined-script", parent=self, choice=(u'primitive-type', u'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__user_defined_script = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_user_defined_script(self):
        self.__user_defined_script = YANGDynClass(base=unicode , is_leaf=True , yang_name="user-defined-script" ,
                                                  parent=self , choice=(u'primitive-type' , u'primitive-definition') ,
                                                  path_helper=self._path_helper , extmethods=self._extmethods ,
                                                  register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                  defining_module='vnfd' , yang_type='string' , is_config=True)

    seq = __builtin__.property(_get_seq , _set_seq)
    name = __builtin__.property(_get_name , _set_name)
    parameter = __builtin__.property(_get_parameter , _set_parameter)
    user_defined_script = __builtin__.property(_get_user_defined_script , _set_user_defined_script)

    __choices__ = {u'primitive-type': {u'primitive-definition': [u'name' , u'parameter' , u'user_defined_script']}}
    _pyangbind_elements = {'seq': seq , 'name': name , 'parameter': parameter ,
                           'user_defined_script': user_defined_script , }


class yc_metrics_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_metrics(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration/metrics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VCA related metrics
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' ,)

    _yang_name = 'metrics'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'vdu-configuration' , u'metrics']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/metrics/name (string)

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/metrics/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)

    _pyangbind_elements = {'name': name , }


class yc_vdu_configuration_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/vdu-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__script' , '__juju' , '__config_primitive' , '__initial_config_primitive' ,
    '__metrics' ,)

    _yang_name = 'vdu-configuration'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju ,
                                   is_container='container' , yang_name="juju" , parent=self ,
                                   choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                   extmethods=self._extmethods , register_paths=True , extensions=None ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='container' , is_config=True)
        self.__config_primitive = YANGDynClass(base=YANGListType("name" ,
                                                                 yc_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive ,
                                                                 yang_name="config-primitive" , parent=self ,
                                                                 is_container='list' , user_ordered=False ,
                                                                 path_helper=self._path_helper , yang_keys='name' ,
                                                                 extensions=None) , is_container='list' ,
                                               yang_name="config-primitive" , parent=self ,
                                               path_helper=self._path_helper , extmethods=self._extmethods ,
                                               register_paths=True , extensions=None ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                               defining_module='vnfd' , yang_type='list' , is_config=True)
        self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq" ,
                                                                         yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive ,
                                                                         yang_name="initial-config-primitive" ,
                                                                         parent=self , is_container='list' ,
                                                                         user_ordered=False ,
                                                                         path_helper=self._path_helper ,
                                                                         yang_keys='seq' , extensions=None) ,
                                                       is_container='list' , yang_name="initial-config-primitive" ,
                                                       parent=self , path_helper=self._path_helper ,
                                                       extmethods=self._extmethods , register_paths=True ,
                                                       extensions=None ,
                                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                       defining_module='vnfd' , yang_type='list' , is_config=True)
        self.__metrics = YANGDynClass(
            base=YANGListType("name" , yc_metrics_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_metrics ,
                              yang_name="metrics" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="metrics" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__script = YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_script ,
                                     is_container='container' , yang_name="script" , parent=self ,
                                     choice=(u'config-method' , u'script') , path_helper=self._path_helper ,
                                     extmethods=self._extmethods , register_paths=True , extensions=None ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                     yang_type='container' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'vdu-configuration']

    def _get_script(self):
        """
    Getter method for script, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/script (container)
    """
        return self.__script

    def _set_script(self , v , load=False):
        """
    Setter method for script, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/script (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_script_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_script ,
                             is_container='container' , yang_name="script" , parent=self ,
                             choice=(u'config-method' , u'script') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """script must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_script, is_container='container', yang_name="script", parent=self, choice=(u'config-method', u'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__script = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_script(self):
        self.__script = YANGDynClass(base=yc_script_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_script ,
                                     is_container='container' , yang_name="script" , parent=self ,
                                     choice=(u'config-method' , u'script') , path_helper=self._path_helper ,
                                     extmethods=self._extmethods , register_paths=True , extensions=None ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                     yang_type='container' , is_config=True)

    def _get_juju(self):
        """
    Getter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju (container)
    """
        return self.__juju

    def _set_juju(self , v , load=False):
        """
    Setter method for juju, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/juju (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_juju_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju ,
                             is_container='container' , yang_name="juju" , parent=self ,
                             choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """juju must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=(u'config-method', u'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__juju = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_juju(self):
        self.__juju = YANGDynClass(base=yc_juju_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_juju ,
                                   is_container='container' , yang_name="juju" , parent=self ,
                                   choice=(u'config-method' , u'juju') , path_helper=self._path_helper ,
                                   extmethods=self._extmethods , register_paths=True , extensions=None ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='container' , is_config=True)

    def _get_config_primitive(self):
        """
    Getter method for config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive (list)

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
        return self.__config_primitive

    def _set_config_primitive(self , v , load=False):
        """
    Setter method for config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_primitive() directly.

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" ,
                                                   yc_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive ,
                                                   yang_name="config-primitive" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="config-primitive" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """config_primitive must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__config_primitive = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_config_primitive(self):
        self.__config_primitive = YANGDynClass(base=YANGListType("name" ,
                                                                 yc_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_config_primitive ,
                                                                 yang_name="config-primitive" , parent=self ,
                                                                 is_container='list' , user_ordered=False ,
                                                                 path_helper=self._path_helper , yang_keys='name' ,
                                                                 extensions=None) , is_container='list' ,
                                               yang_name="config-primitive" , parent=self ,
                                               path_helper=self._path_helper , extmethods=self._extmethods ,
                                               register_paths=True , extensions=None ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                               defining_module='vnfd' , yang_type='list' , is_config=True)

    def _get_initial_config_primitive(self):
        """
    Getter method for initial_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive (list)

    YANG Description: Initial set of configuration primitives.
    """
        return self.__initial_config_primitive

    def _set_initial_config_primitive(self , v , load=False):
        """
    Setter method for initial_config_primitive, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/initial_config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_initial_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_initial_config_primitive() directly.

    YANG Description: Initial set of configuration primitives.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("seq" ,
                                                   yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive ,
                                                   yang_name="initial-config-primitive" , parent=self ,
                                                   is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='seq' , extensions=None) ,
                             is_container='list' , yang_name="initial-config-primitive" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """initial_config_primitive must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__initial_config_primitive = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_initial_config_primitive(self):
        self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq" ,
                                                                         yc_initial_config_primitive_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_initial_config_primitive ,
                                                                         yang_name="initial-config-primitive" ,
                                                                         parent=self , is_container='list' ,
                                                                         user_ordered=False ,
                                                                         path_helper=self._path_helper ,
                                                                         yang_keys='seq' , extensions=None) ,
                                                       is_container='list' , yang_name="initial-config-primitive" ,
                                                       parent=self , path_helper=self._path_helper ,
                                                       extmethods=self._extmethods , register_paths=True ,
                                                       extensions=None ,
                                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                       defining_module='vnfd' , yang_type='list' , is_config=True)

    def _get_metrics(self):
        """
    Getter method for metrics, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/metrics (list)

    YANG Description: List of VCA related metrics
    """
        return self.__metrics

    def _set_metrics(self , v , load=False):
        """
    Setter method for metrics, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration/metrics (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metrics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metrics() directly.

    YANG Description: List of VCA related metrics
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" ,
                                                   yc_metrics_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_metrics ,
                                                   yang_name="metrics" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="metrics" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """metrics must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_metrics_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__metrics = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_metrics(self):
        self.__metrics = YANGDynClass(
            base=YANGListType("name" , yc_metrics_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration_metrics ,
                              yang_name="metrics" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="metrics" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    script = __builtin__.property(_get_script , _set_script)
    juju = __builtin__.property(_get_juju , _set_juju)
    config_primitive = __builtin__.property(_get_config_primitive , _set_config_primitive)
    initial_config_primitive = __builtin__.property(_get_initial_config_primitive , _set_initial_config_primitive)
    metrics = __builtin__.property(_get_metrics , _set_metrics)

    __choices__ = {u'config-method': {u'juju': [u'juju'] , u'script': [u'script']}}
    _pyangbind_elements = {'script': script , 'juju': juju , 'config_primitive': config_primitive ,
                           'initial_config_primitive': initial_config_primitive , 'metrics': metrics , }


class yc_monitoring_param_vnfd__vnfd_catalog_vnfd_vdu_monitoring_param(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/monitoring-param. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VDU-related monitoring parameters at NFVI level
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__id' , '__nfvi_metric' , '__interface_name_ref' ,)

    _yang_name = 'monitoring-param'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__interface_name_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="interface-name-ref" ,
                                                 parent=self , path_helper=self._path_helper ,
                                                 extmethods=self._extmethods , register_paths=True ,
                                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                 defining_module='vnfd' , yang_type='leafref' , is_config=True)
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                 defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__nfvi_metric = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                   restriction_arg={u'disk_write_ops': {} ,
                                                                                    u'disk_write_bytes': {} ,
                                                                                    u'cpu_utilization': {} ,
                                                                                    u'packets_received': {} ,
                                                                                    u'disk_read_ops': {} ,
                                                                                    u'disk_read_bytes': {} ,
                                                                                    u'average_memory_utilization': {} ,
                                                                                    u'packets_dropped': {} ,
                                                                                    u'packets_sent': {}} , ) ,
                                          is_leaf=True , yang_name="nfvi-metric" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='manotypes:nfvi-metric-type' ,
                                          is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'monitoring-param']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/monitoring_param/id (string)

    YANG Description: The unique id of the monitoring param at VDU level
    """
        return self.__id

    def _set_id(self , v , load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/monitoring_param/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The unique id of the monitoring param at VDU level
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                 defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_nfvi_metric(self):
        """
    Getter method for nfvi_metric, mapped from YANG variable /vnfd_catalog/vnfd/vdu/monitoring_param/nfvi_metric (manotypes:nfvi-metric-type)

    YANG Description: The associated NFVI metric to be monitored
    """
        return self.__nfvi_metric

    def _set_nfvi_metric(self , v , load=False):
        """
    Setter method for nfvi_metric, mapped from YANG variable /vnfd_catalog/vnfd/vdu/monitoring_param/nfvi_metric (manotypes:nfvi-metric-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nfvi_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nfvi_metric() directly.

    YANG Description: The associated NFVI metric to be monitored
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'disk_write_ops': {} ,
                                                                           u'disk_write_bytes': {} ,
                                                                           u'cpu_utilization': {} ,
                                                                           u'packets_received': {} ,
                                                                           u'disk_read_ops': {} ,
                                                                           u'disk_read_bytes': {} ,
                                                                           u'average_memory_utilization': {} ,
                                                                           u'packets_dropped': {} ,
                                                                           u'packets_sent': {}} , ) , is_leaf=True ,
                             yang_name="nfvi-metric" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='manotypes:nfvi-metric-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """nfvi_metric must be of a type compatible with manotypes:nfvi-metric-type""" ,
                'defined-type': "manotypes:nfvi-metric-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'disk_write_ops': {}, u'disk_write_bytes': {}, u'cpu_utilization': {}, u'packets_received': {}, u'disk_read_ops': {}, u'disk_read_bytes': {}, u'average_memory_utilization': {}, u'packets_dropped': {}, u'packets_sent': {}},), is_leaf=True, yang_name="nfvi-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='manotypes:nfvi-metric-type', is_config=True)""" ,
            })

        self.__nfvi_metric = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_nfvi_metric(self):
        self.__nfvi_metric = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                   restriction_arg={u'disk_write_ops': {} ,
                                                                                    u'disk_write_bytes': {} ,
                                                                                    u'cpu_utilization': {} ,
                                                                                    u'packets_received': {} ,
                                                                                    u'disk_read_ops': {} ,
                                                                                    u'disk_read_bytes': {} ,
                                                                                    u'average_memory_utilization': {} ,
                                                                                    u'packets_dropped': {} ,
                                                                                    u'packets_sent': {}} , ) ,
                                          is_leaf=True , yang_name="nfvi-metric" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='manotypes:nfvi-metric-type' ,
                                          is_config=True)

    def _get_interface_name_ref(self):
        """
    Getter method for interface_name_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/monitoring_param/interface_name_ref (leafref)

    YANG Description: Reference to a VDU interface name. Applicable only when the nfvi-metric
refers to an interface and not to the VM
    """
        return self.__interface_name_ref

    def _set_interface_name_ref(self , v , load=False):
        """
    Setter method for interface_name_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/monitoring_param/interface_name_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_name_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_name_ref() directly.

    YANG Description: Reference to a VDU interface name. Applicable only when the nfvi-metric
refers to an interface and not to the VM
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="interface-name-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """interface_name_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="interface-name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__interface_name_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_interface_name_ref(self):
        self.__interface_name_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="interface-name-ref" ,
                                                 parent=self , path_helper=self._path_helper ,
                                                 extmethods=self._extmethods , register_paths=True ,
                                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                 defining_module='vnfd' , yang_type='leafref' , is_config=True)

    id = __builtin__.property(_get_id , _set_id)
    nfvi_metric = __builtin__.property(_get_nfvi_metric , _set_nfvi_metric)
    interface_name_ref = __builtin__.property(_get_interface_name_ref , _set_interface_name_ref)

    _pyangbind_elements = {'id': id , 'nfvi_metric': nfvi_metric , 'interface_name_ref': interface_name_ref , }


class yc_supplemental_boot_data_vnfd__vnfd_catalog_vnfd_vdu_supplemental_boot_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/supplemental-boot-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__boot_data_drive' ,)

    _yang_name = 'supplemental-boot-data'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__boot_data_drive = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                              yang_name="boot-data-drive" , parent=self ,
                                              path_helper=self._path_helper , extmethods=self._extmethods ,
                                              register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                              defining_module='vnfd' , yang_type='boolean' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'supplemental-boot-data']

    def _get_boot_data_drive(self):
        """
    Getter method for boot_data_drive, mapped from YANG variable /vnfd_catalog/vnfd/vdu/supplemental_boot_data/boot_data_drive (boolean)

    YANG Description: Some VIMs implement additional drives to host config-files or meta-data
    """
        return self.__boot_data_drive

    def _set_boot_data_drive(self , v , load=False):
        """
    Setter method for boot_data_drive, mapped from YANG variable /vnfd_catalog/vnfd/vdu/supplemental_boot_data/boot_data_drive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_boot_data_drive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_boot_data_drive() directly.

    YANG Description: Some VIMs implement additional drives to host config-files or meta-data
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                             yang_name="boot-data-drive" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """boot_data_drive must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="boot-data-drive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__boot_data_drive = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_boot_data_drive(self):
        self.__boot_data_drive = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                              yang_name="boot-data-drive" , parent=self ,
                                              path_helper=self._path_helper , extmethods=self._extmethods ,
                                              register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                              defining_module='vnfd' , yang_type='boolean' , is_config=True)

    boot_data_drive = __builtin__.property(_get_boot_data_drive , _set_boot_data_drive)

    _pyangbind_elements = {'boot_data_drive': boot_data_drive , }


class yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_vdu_internal_connection_point(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/internal-connection-point. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List for internal connection points. Each VNFC
has zero or more internal connection points.
Internal connection points are used for connecting
the VNF with components internal to the VNF. If a VNF
has only one VNFC, it may not have any internal
connection points.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__name' , '__id' , '__short_name' , '__type' , '__port_security_enabled' ,
    '__internal_vld_ref' ,)

    _yang_name = 'internal-connection-point'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)
        self.__short_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__internal_vld_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="internal-vld-ref" ,
                                               parent=self , path_helper=self._path_helper ,
                                               extmethods=self._extmethods , register_paths=True ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                               defining_module='vnfd' , yang_type='leafref' , is_config=True)
        self.__port_security_enabled = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True ,
                                                    yang_name="port-security-enabled" , parent=self ,
                                                    path_helper=self._path_helper , extmethods=self._extmethods ,
                                                    register_paths=True ,
                                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                    defining_module='vnfd' , yang_type='boolean' , is_config=True)
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                            restriction_arg={u'VPORT': {}} , ) , is_leaf=True ,
                                   yang_name="type" , parent=self , path_helper=self._path_helper ,
                                   extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='manotypes:connection-point-type' , is_config=True)
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                 defining_module='vnfd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'internal-connection-point']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/name (string)

    YANG Description: Name of the connection point
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the connection point
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/id (string)

    YANG Description: Identifier for the internal connection points
    """
        return self.__id

    def _set_id(self , v , load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the internal connection points
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                 defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_short_name(self):
        """
    Getter method for short_name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/short_name (string)

    YANG Description: Short name to appear as label in the UI
    """
        return self.__short_name

    def _set_short_name(self , v , load=False):
        """
    Setter method for short_name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.

    YANG Description: Short name to appear as label in the UI
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """short_name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__short_name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_short_name(self):
        self.__short_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_type(self):
        """
    Getter method for type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/type (manotypes:connection-point-type)

    YANG Description: Type of the connection point.
    """
        return self.__type

    def _set_type(self , v , load=False):
        """
    Setter method for type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/type (manotypes:connection-point-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the connection point.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'VPORT': {}} , ) , is_leaf=True ,
                             yang_name="type" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='manotypes:connection-point-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """type must be of a type compatible with manotypes:connection-point-type""" ,
                'defined-type': "manotypes:connection-point-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'VPORT': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='manotypes:connection-point-type', is_config=True)""" ,
            })

        self.__type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                            restriction_arg={u'VPORT': {}} , ) , is_leaf=True ,
                                   yang_name="type" , parent=self , path_helper=self._path_helper ,
                                   extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='manotypes:connection-point-type' , is_config=True)

    def _get_port_security_enabled(self):
        """
    Getter method for port_security_enabled, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/port_security_enabled (boolean)

    YANG Description: Enables the port security for the port.
    """
        return self.__port_security_enabled

    def _set_port_security_enabled(self , v , load=False):
        """
    Setter method for port_security_enabled, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/port_security_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_security_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_security_enabled() directly.

    YANG Description: Enables the port security for the port.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("true") , is_leaf=True ,
                             yang_name="port-security-enabled" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """port_security_enabled must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="port-security-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__port_security_enabled = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_port_security_enabled(self):
        self.__port_security_enabled = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True ,
                                                    yang_name="port-security-enabled" , parent=self ,
                                                    path_helper=self._path_helper , extmethods=self._extmethods ,
                                                    register_paths=True ,
                                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                    defining_module='vnfd' , yang_type='boolean' , is_config=True)

    def _get_internal_vld_ref(self):
        """
    Getter method for internal_vld_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/internal_vld_ref (leafref)
    """
        return self.__internal_vld_ref

    def _set_internal_vld_ref(self , v , load=False):
        """
    Setter method for internal_vld_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point/internal_vld_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_internal_vld_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_internal_vld_ref() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="internal-vld-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """internal_vld_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="internal-vld-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__internal_vld_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_internal_vld_ref(self):
        self.__internal_vld_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="internal-vld-ref" ,
                                               parent=self , path_helper=self._path_helper ,
                                               extmethods=self._extmethods , register_paths=True ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                               defining_module='vnfd' , yang_type='leafref' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    id = __builtin__.property(_get_id , _set_id)
    short_name = __builtin__.property(_get_short_name , _set_short_name)
    type = __builtin__.property(_get_type , _set_type)
    port_security_enabled = __builtin__.property(_get_port_security_enabled , _set_port_security_enabled)
    internal_vld_ref = __builtin__.property(_get_internal_vld_ref , _set_internal_vld_ref)

    _pyangbind_elements = {'name': name , 'id': id , 'short_name': short_name , 'type': type ,
                           'port_security_enabled': port_security_enabled , 'internal_vld_ref': internal_vld_ref , }


class yc_virtual_interface_vnfd__vnfd_catalog_vnfd_vdu_interface_virtual_interface(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/interface/virtual-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the virtual interface properties
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__type' , '__vpci' , '__bandwidth' ,)

    _yang_name = 'virtual-interface'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vpci = YANGDynClass(base=unicode , is_leaf=True , yang_name="vpci" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                            restriction_arg={u'OM-MGMT': {} , u'VIRTIO': {} ,
                                                                             u'SR-IOV': {} , u'PCI-PASSTHROUGH': {} ,
                                                                             u'RTL8139': {} , u'PCNET': {} ,
                                                                             u'PARAVIRT': {} , u'E1000': {}} , ) ,
                                   default=unicode("PARAVIRT") , is_leaf=True , yang_name="type" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='enumeration' , is_config=True)
        self.__bandwidth = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="bandwidth" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'interface' , u'virtual-interface']

    def _get_type(self):
        """
    Getter method for type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/virtual_interface/type (enumeration)

    YANG Description: Specifies the type of virtual interface
between VM and host.
PARAVIRT        : Use the default paravirtualized interface for the VIM (virtio, vmxnet3, etc.).
VIRTIO          : Deprecated! Use the traditional VIRTIO interface.
PCI-PASSTHROUGH : Use PCI-PASSTHROUGH interface.
SR-IOV          : Use SR-IOV interface.
E1000           : Emulate E1000 interface.
RTL8139         : Emulate RTL8139 interface.
PCNET           : Emulate PCNET interface.
OM-MGMT         : Deprecated! Use PARAVIRT instead and set the VNF management interface at vnfd:mgmt-interface:cp
    """
        return self.__type

    def _set_type(self , v , load=False):
        """
    Setter method for type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/virtual_interface/type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the type of virtual interface
between VM and host.
PARAVIRT        : Use the default paravirtualized interface for the VIM (virtio, vmxnet3, etc.).
VIRTIO          : Deprecated! Use the traditional VIRTIO interface.
PCI-PASSTHROUGH : Use PCI-PASSTHROUGH interface.
SR-IOV          : Use SR-IOV interface.
E1000           : Emulate E1000 interface.
RTL8139         : Emulate RTL8139 interface.
PCNET           : Emulate PCNET interface.
OM-MGMT         : Deprecated! Use PARAVIRT instead and set the VNF management interface at vnfd:mgmt-interface:cp
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'OM-MGMT': {} , u'VIRTIO': {} ,
                                                                           u'SR-IOV': {} , u'PCI-PASSTHROUGH': {} ,
                                                                           u'RTL8139': {} , u'PCNET': {} ,
                                                                           u'PARAVIRT': {} , u'E1000': {}} , ) ,
                             default=unicode("PARAVIRT") , is_leaf=True , yang_name="type" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """type must be of a type compatible with enumeration""" ,
                'defined-type': "vnfd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'OM-MGMT': {}, u'VIRTIO': {}, u'SR-IOV': {}, u'PCI-PASSTHROUGH': {}, u'RTL8139': {}, u'PCNET': {}, u'PARAVIRT': {}, u'E1000': {}},), default=unicode("PARAVIRT"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                            restriction_arg={u'OM-MGMT': {} , u'VIRTIO': {} ,
                                                                             u'SR-IOV': {} , u'PCI-PASSTHROUGH': {} ,
                                                                             u'RTL8139': {} , u'PCNET': {} ,
                                                                             u'PARAVIRT': {} , u'E1000': {}} , ) ,
                                   default=unicode("PARAVIRT") , is_leaf=True , yang_name="type" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='enumeration' , is_config=True)

    def _get_vpci(self):
        """
    Getter method for vpci, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/virtual_interface/vpci (string)

    YANG Description: Specifies the virtual PCI address. Expressed in
the following format dddd:dd:dd.d. For example
0000:00:12.0. This information can be used to
pass as metadata during the VM creation.
    """
        return self.__vpci

    def _set_vpci(self , v , load=False):
        """
    Setter method for vpci, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/virtual_interface/vpci (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpci is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpci() directly.

    YANG Description: Specifies the virtual PCI address. Expressed in
the following format dddd:dd:dd.d. For example
0000:00:12.0. This information can be used to
pass as metadata during the VM creation.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vpci" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vpci must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__vpci = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vpci(self):
        self.__vpci = YANGDynClass(base=unicode , is_leaf=True , yang_name="vpci" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)

    def _get_bandwidth(self):
        """
    Getter method for bandwidth, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/virtual_interface/bandwidth (uint64)

    YANG Description: Aggregate bandwidth of the NIC.
    """
        return self.__bandwidth

    def _set_bandwidth(self , v , load=False):
        """
    Setter method for bandwidth, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/virtual_interface/bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: Aggregate bandwidth of the NIC.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="bandwidth" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """bandwidth must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__bandwidth = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_bandwidth(self):
        self.__bandwidth = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="bandwidth" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

    type = __builtin__.property(_get_type , _set_type)
    vpci = __builtin__.property(_get_vpci , _set_vpci)
    bandwidth = __builtin__.property(_get_bandwidth , _set_bandwidth)

    _pyangbind_elements = {'type': type , 'vpci': vpci , 'bandwidth': bandwidth , }


class yc_interface_vnfd__vnfd_catalog_vnfd_vdu_interface(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Interfaces (external and internal) for the VNF
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__name' , '__position' , '__mgmt_interface' , '__type' , '__mac_address' ,
    '__internal_connection_point_ref' , '__external_connection_point_ref' , '__virtual_interface' ,)

    _yang_name = 'interface'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__external_connection_point_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                            yang_name="external-connection-point-ref" , parent=self ,
                                                            choice=(u'connection-point-type' , u'external') ,
                                                            path_helper=self._path_helper ,
                                                            extmethods=self._extmethods , register_paths=True ,
                                                            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                            defining_module='vnfd' , yang_type='leafref' ,
                                                            is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__internal_connection_point_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                            yang_name="internal-connection-point-ref" , parent=self ,
                                                            choice=(u'connection-point-type' , u'internal') ,
                                                            path_helper=self._path_helper ,
                                                            extmethods=self._extmethods , register_paths=True ,
                                                            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                            defining_module='vnfd' , yang_type='leafref' ,
                                                            is_config=True)
        self.__mac_address = YANGDynClass(base=unicode , is_leaf=True , yang_name="mac-address" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__position = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="position" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)
        self.__virtual_interface = YANGDynClass(
            base=yc_virtual_interface_vnfd__vnfd_catalog_vnfd_vdu_interface_virtual_interface ,
            is_container='container' , yang_name="virtual-interface" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                            restriction_arg={u'INTERNAL': {} , u'EXTERNAL': {}} , ) ,
                                   default=unicode("EXTERNAL") , is_leaf=True , yang_name="type" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='interface-type' , is_config=True)
        self.__mgmt_interface = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                             yang_name="mgmt-interface" , parent=self , path_helper=self._path_helper ,
                                             extmethods=self._extmethods , register_paths=True ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='boolean' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'interface']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/name (string)

    YANG Description: Name of the interface. Note that this
name has only local significance to the VDU.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the interface. Note that this
name has only local significance to the VDU.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_position(self):
        """
    Getter method for position, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/position (uint32)

    YANG Description: Explicit Position of the interface within the list
    """
        return self.__position

    def _set_position(self , v , load=False):
        """
    Setter method for position, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/position (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_position is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_position() directly.

    YANG Description: Explicit Position of the interface within the list
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , is_leaf=True , yang_name="position" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """position must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""" ,
            })

        self.__position = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_position(self):
        self.__position = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="position" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)

    def _get_mgmt_interface(self):
        """
    Getter method for mgmt_interface, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/mgmt_interface (boolean)

    YANG Description: Flag to indicate that this is the mgmt interface
to be used for VDU configuration
    """
        return self.__mgmt_interface

    def _set_mgmt_interface(self , v , load=False):
        """
    Setter method for mgmt_interface, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/mgmt_interface (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_interface() directly.

    YANG Description: Flag to indicate that this is the mgmt interface
to be used for VDU configuration
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="mgmt-interface" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """mgmt_interface must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__mgmt_interface = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_mgmt_interface(self):
        self.__mgmt_interface = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                             yang_name="mgmt-interface" , parent=self , path_helper=self._path_helper ,
                                             extmethods=self._extmethods , register_paths=True ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='boolean' , is_config=True)

    def _get_type(self):
        """
    Getter method for type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/type (interface-type)

    YANG Description: Type of the Interface
    """
        return self.__type

    def _set_type(self , v , load=False):
        """
    Setter method for type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/type (interface-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the Interface
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'INTERNAL': {} , u'EXTERNAL': {}} , ) ,
                             default=unicode("EXTERNAL") , is_leaf=True , yang_name="type" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='interface-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """type must be of a type compatible with interface-type""" ,
                'defined-type': "vnfd:interface-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'INTERNAL': {}, u'EXTERNAL': {}},), default=unicode("EXTERNAL"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='interface-type', is_config=True)""" ,
            })

        self.__type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                            restriction_arg={u'INTERNAL': {} , u'EXTERNAL': {}} , ) ,
                                   default=unicode("EXTERNAL") , is_leaf=True , yang_name="type" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='interface-type' , is_config=True)

    def _get_mac_address(self):
        """
    Getter method for mac_address, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/mac_address (string)

    YANG Description: MAC address of the interface.
Some VNFs require a specific MAC address to be configured
in the interface. While this is not recommended at all in
NFV environments, this parameter exists to allow those
scenarios.
This parameter will be likely deprecated in the future.
    """
        return self.__mac_address

    def _set_mac_address(self , v , load=False):
        """
    Setter method for mac_address, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/mac_address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: MAC address of the interface.
Some VNFs require a specific MAC address to be configured
in the interface. While this is not recommended at all in
NFV environments, this parameter exists to allow those
scenarios.
This parameter will be likely deprecated in the future.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="mac-address" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """mac_address must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__mac_address = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_mac_address(self):
        self.__mac_address = YANGDynClass(base=unicode , is_leaf=True , yang_name="mac-address" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_internal_connection_point_ref(self):
        """
    Getter method for internal_connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/internal_connection_point_ref (leafref)

    YANG Description: Leaf Ref to the particular internal connection point
    """
        return self.__internal_connection_point_ref

    def _set_internal_connection_point_ref(self , v , load=False):
        """
    Setter method for internal_connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/internal_connection_point_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_internal_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_internal_connection_point_ref() directly.

    YANG Description: Leaf Ref to the particular internal connection point
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="internal-connection-point-ref" , parent=self ,
                             choice=(u'connection-point-type' , u'internal') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """internal_connection_point_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="internal-connection-point-ref", parent=self, choice=(u'connection-point-type', u'internal'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__internal_connection_point_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_internal_connection_point_ref(self):
        self.__internal_connection_point_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                            yang_name="internal-connection-point-ref" , parent=self ,
                                                            choice=(u'connection-point-type' , u'internal') ,
                                                            path_helper=self._path_helper ,
                                                            extmethods=self._extmethods , register_paths=True ,
                                                            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                            defining_module='vnfd' , yang_type='leafref' ,
                                                            is_config=True)

    def _get_external_connection_point_ref(self):
        """
    Getter method for external_connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/external_connection_point_ref (leafref)

    YANG Description: Leaf Ref to the particular external connection point
    """
        return self.__external_connection_point_ref

    def _set_external_connection_point_ref(self , v , load=False):
        """
    Setter method for external_connection_point_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/external_connection_point_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_external_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_external_connection_point_ref() directly.

    YANG Description: Leaf Ref to the particular external connection point
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="external-connection-point-ref" , parent=self ,
                             choice=(u'connection-point-type' , u'external') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """external_connection_point_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="external-connection-point-ref", parent=self, choice=(u'connection-point-type', u'external'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__external_connection_point_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_external_connection_point_ref(self):
        self.__external_connection_point_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                            yang_name="external-connection-point-ref" , parent=self ,
                                                            choice=(u'connection-point-type' , u'external') ,
                                                            path_helper=self._path_helper ,
                                                            extmethods=self._extmethods , register_paths=True ,
                                                            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                            defining_module='vnfd' , yang_type='leafref' ,
                                                            is_config=True)

    def _get_virtual_interface(self):
        """
    Getter method for virtual_interface, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/virtual_interface (container)

    YANG Description: Container for the virtual interface properties
    """
        return self.__virtual_interface

    def _set_virtual_interface(self , v , load=False):
        """
    Setter method for virtual_interface, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface/virtual_interface (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_interface() directly.

    YANG Description: Container for the virtual interface properties
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_virtual_interface_vnfd__vnfd_catalog_vnfd_vdu_interface_virtual_interface ,
                             is_container='container' , yang_name="virtual-interface" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """virtual_interface must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_virtual_interface_vnfd__vnfd_catalog_vnfd_vdu_interface_virtual_interface, is_container='container', yang_name="virtual-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__virtual_interface = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_virtual_interface(self):
        self.__virtual_interface = YANGDynClass(
            base=yc_virtual_interface_vnfd__vnfd_catalog_vnfd_vdu_interface_virtual_interface ,
            is_container='container' , yang_name="virtual-interface" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    position = __builtin__.property(_get_position , _set_position)
    mgmt_interface = __builtin__.property(_get_mgmt_interface , _set_mgmt_interface)
    type = __builtin__.property(_get_type , _set_type)
    mac_address = __builtin__.property(_get_mac_address , _set_mac_address)
    internal_connection_point_ref = __builtin__.property(_get_internal_connection_point_ref ,
                                                         _set_internal_connection_point_ref)
    external_connection_point_ref = __builtin__.property(_get_external_connection_point_ref ,
                                                         _set_external_connection_point_ref)
    virtual_interface = __builtin__.property(_get_virtual_interface , _set_virtual_interface)

    __choices__ = {u'connection-point-type': {u'internal': [u'internal_connection_point_ref'] ,
                                              u'external': [u'external_connection_point_ref']}}
    _pyangbind_elements = {'name': name , 'position': position , 'mgmt_interface': mgmt_interface , 'type': type ,
                           'mac_address': mac_address , 'internal_connection_point_ref': internal_connection_point_ref ,
                           'external_connection_point_ref': external_connection_point_ref ,
                           'virtual_interface': virtual_interface , }


class yc_volumes_vnfd__vnfd_catalog_vnfd_vdu_volumes(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu/volumes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__description' , '__size' , '__ephemeral' , '__image' ,
                 '__image_checksum' , '__device_bus' , '__device_type' ,)

    _yang_name = 'volumes'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__image = YANGDynClass(base=unicode , is_leaf=True , yang_name="image" , parent=self ,
                                    choice=(u'volume-source' , u'image') , path_helper=self._path_helper ,
                                    extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__ephemeral = YANGDynClass(base=YANGBool , is_leaf=True , yang_name="ephemeral" , parent=self ,
                                        choice=(u'volume-source' , u'ephemeral') , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='empty' , is_config=True)
        self.__device_bus = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                  restriction_arg={u'scsi': {} , u'virtio': {} ,
                                                                                   u'ide': {} , u'usb': {}} , ) ,
                                         is_leaf=True , yang_name="device-bus" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='enumeration' , is_config=True)
        self.__device_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                   restriction_arg={u'cdrom': {} , u'floppy': {} ,
                                                                                    u'disk': {} , u'lun': {}} , ) ,
                                          is_leaf=True , yang_name="device-type" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='enumeration' , is_config=True)
        self.__image_checksum = YANGDynClass(base=unicode , is_leaf=True , yang_name="image-checksum" , parent=self ,
                                             choice=(u'volume-source' , u'image') , path_helper=self._path_helper ,
                                             extmethods=self._extmethods , register_paths=True ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__size = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="size" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu' , u'volumes']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/name (string)

    YANG Description: Name of the disk-volumes, e.g. vda, vdb etc
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the disk-volumes, e.g. vda, vdb etc
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/description (string)

    YANG Description: Description for Volume
    """
        return self.__description

    def _set_description(self , v , load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description for Volume
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__description = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_size(self):
        """
    Getter method for size, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/size (uint64)

    YANG Description: Size of disk in GB
    """
        return self.__size

    def _set_size(self , v , load=False):
        """
    Setter method for size, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/size (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size() directly.

    YANG Description: Size of disk in GB
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="size" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """size must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__size = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_size(self):
        self.__size = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="size" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

    def _get_ephemeral(self):
        """
    Getter method for ephemeral, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/ephemeral (empty)
    """
        return self.__ephemeral

    def _set_ephemeral(self , v , load=False):
        """
    Setter method for ephemeral, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/ephemeral (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ephemeral is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ephemeral() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , is_leaf=True , yang_name="ephemeral" , parent=self ,
                             choice=(u'volume-source' , u'ephemeral') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='empty' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ephemeral must be of a type compatible with empty""" ,
                'defined-type': "empty" ,
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ephemeral", parent=self, choice=(u'volume-source', u'ephemeral'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='empty', is_config=True)""" ,
            })

        self.__ephemeral = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ephemeral(self):
        self.__ephemeral = YANGDynClass(base=YANGBool , is_leaf=True , yang_name="ephemeral" , parent=self ,
                                        choice=(u'volume-source' , u'ephemeral') , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='empty' , is_config=True)

    def _get_image(self):
        """
    Getter method for image, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/image (string)

    YANG Description: Image name for the software image.
If the image name is found within the VNF package it will
be uploaded to all VIM accounts during onboarding process.
Otherwise, the image must be added to the VIM account with
the same name as entered here.

    """
        return self.__image

    def _set_image(self , v , load=False):
        """
    Setter method for image, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/image (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image() directly.

    YANG Description: Image name for the software image.
If the image name is found within the VNF package it will
be uploaded to all VIM accounts during onboarding process.
Otherwise, the image must be added to the VIM account with
the same name as entered here.

    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="image" , parent=self ,
                             choice=(u'volume-source' , u'image') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """image must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="image", parent=self, choice=(u'volume-source', u'image'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__image = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_image(self):
        self.__image = YANGDynClass(base=unicode , is_leaf=True , yang_name="image" , parent=self ,
                                    choice=(u'volume-source' , u'image') , path_helper=self._path_helper ,
                                    extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)

    def _get_image_checksum(self):
        """
    Getter method for image_checksum, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/image_checksum (string)

    YANG Description: Image md5sum for the software image.
The md5sum, if provided, along with the image name uniquely
identifies an image uploaded to the CAL.

    """
        return self.__image_checksum

    def _set_image_checksum(self , v , load=False):
        """
    Setter method for image_checksum, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/image_checksum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image_checksum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image_checksum() directly.

    YANG Description: Image md5sum for the software image.
The md5sum, if provided, along with the image name uniquely
identifies an image uploaded to the CAL.

    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="image-checksum" , parent=self ,
                             choice=(u'volume-source' , u'image') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """image_checksum must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="image-checksum", parent=self, choice=(u'volume-source', u'image'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__image_checksum = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_image_checksum(self):
        self.__image_checksum = YANGDynClass(base=unicode , is_leaf=True , yang_name="image-checksum" , parent=self ,
                                             choice=(u'volume-source' , u'image') , path_helper=self._path_helper ,
                                             extmethods=self._extmethods , register_paths=True ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_device_bus(self):
        """
    Getter method for device_bus, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/device_bus (enumeration)

    YANG Description: Type of disk-bus on which this disk is exposed to guest
    """
        return self.__device_bus

    def _set_device_bus(self , v , load=False):
        """
    Setter method for device_bus, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/device_bus (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_bus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_bus() directly.

    YANG Description: Type of disk-bus on which this disk is exposed to guest
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'scsi': {} , u'virtio': {} , u'ide': {} ,
                                                                           u'usb': {}} , ) , is_leaf=True ,
                             yang_name="device-bus" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """device_bus must be of a type compatible with enumeration""" ,
                'defined-type': "vnfd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'scsi': {}, u'virtio': {}, u'ide': {}, u'usb': {}},), is_leaf=True, yang_name="device-bus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__device_bus = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_device_bus(self):
        self.__device_bus = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                  restriction_arg={u'scsi': {} , u'virtio': {} ,
                                                                                   u'ide': {} , u'usb': {}} , ) ,
                                         is_leaf=True , yang_name="device-bus" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='enumeration' , is_config=True)

    def _get_device_type(self):
        """
    Getter method for device_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/device_type (enumeration)

    YANG Description: The type of device as exposed to guest
    """
        return self.__device_type

    def _set_device_type(self , v , load=False):
        """
    Setter method for device_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes/device_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_type() directly.

    YANG Description: The type of device as exposed to guest
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'cdrom': {} , u'floppy': {} , u'disk': {} ,
                                                                           u'lun': {}} , ) , is_leaf=True ,
                             yang_name="device-type" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """device_type must be of a type compatible with enumeration""" ,
                'defined-type': "vnfd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'cdrom': {}, u'floppy': {}, u'disk': {}, u'lun': {}},), is_leaf=True, yang_name="device-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__device_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_device_type(self):
        self.__device_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                   restriction_arg={u'cdrom': {} , u'floppy': {} ,
                                                                                    u'disk': {} , u'lun': {}} , ) ,
                                          is_leaf=True , yang_name="device-type" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='enumeration' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    description = __builtin__.property(_get_description , _set_description)
    size = __builtin__.property(_get_size , _set_size)
    ephemeral = __builtin__.property(_get_ephemeral , _set_ephemeral)
    image = __builtin__.property(_get_image , _set_image)
    image_checksum = __builtin__.property(_get_image_checksum , _set_image_checksum)
    device_bus = __builtin__.property(_get_device_bus , _set_device_bus)
    device_type = __builtin__.property(_get_device_type , _set_device_type)

    __choices__ = {u'volume-source': {u'image': [u'image' , u'image_checksum'] , u'ephemeral': [u'ephemeral']}}
    _pyangbind_elements = {'name': name , 'description': description , 'size': size , 'ephemeral': ephemeral ,
                           'image': image , 'image_checksum': image_checksum , 'device_bus': device_bus ,
                           'device_type': device_type , }


class yc_vdu_vnfd__vnfd_catalog_vnfd_vdu(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Virtual Deployment Units
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__id' , '__name' , '__description' , '__pdu_type' , '__count' , '__mgmt_vpci' ,
    '__vm_flavor' , '__guest_epa' , '__vswitch_epa' , '__hypervisor_epa' , '__host_epa' , '__alarm' , '__image' ,
    '__image_checksum' , '__alternative_images' , '__vdu_configuration' , '__monitoring_param' , '__cloud_init' ,
    '__cloud_init_file' , '__supplemental_boot_data' , '__internal_connection_point' , '__interface' , '__volumes' ,)

    _yang_name = 'vdu'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__internal_connection_point = YANGDynClass(base=YANGListType("id" ,
                                                                          yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_vdu_internal_connection_point ,
                                                                          yang_name="internal-connection-point" ,
                                                                          parent=self , is_container='list' ,
                                                                          user_ordered=False ,
                                                                          path_helper=self._path_helper ,
                                                                          yang_keys='id' , extensions=None) ,
                                                        is_container='list' , yang_name="internal-connection-point" ,
                                                        parent=self , path_helper=self._path_helper ,
                                                        extmethods=self._extmethods , register_paths=True ,
                                                        extensions=None ,
                                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                        defining_module='vnfd' , yang_type='list' , is_config=True)
        self.__alternative_images = YANGDynClass(
            base=YANGListType("vim_type" , yc_alternative_images_vnfd__vnfd_catalog_vnfd_vdu_alternative_images ,
                              yang_name="alternative-images" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='vim-type' , extensions=None) ,
            is_container='list' , yang_name="alternative-images" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__image = YANGDynClass(base=unicode , is_leaf=True , yang_name="image" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)
        self.__hypervisor_epa = YANGDynClass(base=yc_hypervisor_epa_vnfd__vnfd_catalog_vnfd_vdu_hypervisor_epa ,
                                             is_container='container' , yang_name="hypervisor-epa" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , extensions=None ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='container' , is_config=True)
        self.__image_checksum = YANGDynClass(base=unicode , is_leaf=True , yang_name="image-checksum" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__vswitch_epa = YANGDynClass(base=yc_vswitch_epa_vnfd__vnfd_catalog_vnfd_vdu_vswitch_epa ,
                                          is_container='container' , yang_name="vswitch-epa" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , extensions=None ,
                                          namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                          yang_type='container' , is_config=True)
        self.__mgmt_vpci = YANGDynClass(base=unicode , is_leaf=True , yang_name="mgmt-vpci" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                        defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__cloud_init_file = YANGDynClass(base=unicode , is_leaf=True , yang_name="cloud-init-file" , parent=self ,
                                              choice=(u'cloud-init-input' , u'filename') ,
                                              path_helper=self._path_helper , extmethods=self._extmethods ,
                                              register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                              defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__vm_flavor = YANGDynClass(base=yc_vm_flavor_vnfd__vnfd_catalog_vnfd_vdu_vm_flavor ,
                                        is_container='container' , yang_name="vm-flavor" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , extensions=None ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='container' , is_config=True)
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                 defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__supplemental_boot_data = YANGDynClass(
            base=yc_supplemental_boot_data_vnfd__vnfd_catalog_vnfd_vdu_supplemental_boot_data ,
            is_container='container' , yang_name="supplemental-boot-data" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)
        self.__guest_epa = YANGDynClass(base=yc_guest_epa_vnfd__vnfd_catalog_vnfd_vdu_guest_epa ,
                                        is_container='container' , yang_name="guest-epa" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , extensions=None ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='container' , is_config=True)
        self.__pdu_type = YANGDynClass(base=unicode , is_leaf=True , yang_name="pdu-type" , parent=self ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                       defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__monitoring_param = YANGDynClass(
            base=YANGListType("id" , yc_monitoring_param_vnfd__vnfd_catalog_vnfd_vdu_monitoring_param ,
                              yang_name="monitoring-param" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='id' , extensions=None) , is_container='list' ,
            yang_name="monitoring-param" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='list' , is_config=True)
        self.__interface = YANGDynClass(
            base=YANGListType("name" , yc_interface_vnfd__vnfd_catalog_vnfd_vdu_interface , yang_name="interface" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='name' , extensions=None) , is_container='list' , yang_name="interface" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='list' , is_config=True)
        self.__host_epa = YANGDynClass(base=yc_host_epa_vnfd__vnfd_catalog_vnfd_vdu_host_epa ,
                                       is_container='container' , yang_name="host-epa" , parent=self ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , extensions=None ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='container' , is_config=True)
        self.__vdu_configuration = YANGDynClass(
            base=yc_vdu_configuration_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration , is_container='container' ,
            yang_name="vdu-configuration" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='container' , is_config=True)
        self.__count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="count" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)
        self.__cloud_init = YANGDynClass(base=unicode , is_leaf=True , yang_name="cloud-init" , parent=self ,
                                         choice=(u'cloud-init-input' , u'inline') , path_helper=self._path_helper ,
                                         extmethods=self._extmethods , register_paths=True ,
                                         namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                         yang_type='string' , is_config=True)
        self.__volumes = YANGDynClass(
            base=YANGListType("name" , yc_volumes_vnfd__vnfd_catalog_vnfd_vdu_volumes , yang_name="volumes" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='name' , extensions=None) , is_container='list' , yang_name="volumes" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='list' , is_config=True)
        self.__alarm = YANGDynClass(
            base=YANGListType("alarm_id" , yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm , yang_name="alarm" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='alarm-id' , extensions=None) , is_container='list' , yang_name="alarm" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='list' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/id (string)

    YANG Description: Unique id for the VDU
    """
        return self.__id

    def _set_id(self , v , load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/vdu/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique id for the VDU
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                 defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/name (string)

    YANG Description: Unique name for the VDU
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/vdu/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Unique name for the VDU
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd_catalog/vnfd/vdu/description (string)

    YANG Description: Description of the VDU.
    """
        return self.__description

    def _set_description(self , v , load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd_catalog/vnfd/vdu/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the VDU.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__description = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_pdu_type(self):
        """
    Getter method for pdu_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/pdu_type (string)

    YANG Description: Type of PDU. If this field exists, the deployment unit must be
understood as a PDU, not as a VDU. This field is used to identify
the category of PDU instances to be used at instantiation time. For
the instantiation to be successful, there must be available
PDU instances of this type in the selected datacenter.
    """
        return self.__pdu_type

    def _set_pdu_type(self , v , load=False):
        """
    Setter method for pdu_type, mapped from YANG variable /vnfd_catalog/vnfd/vdu/pdu_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pdu_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pdu_type() directly.

    YANG Description: Type of PDU. If this field exists, the deployment unit must be
understood as a PDU, not as a VDU. This field is used to identify
the category of PDU instances to be used at instantiation time. For
the instantiation to be successful, there must be available
PDU instances of this type in the selected datacenter.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="pdu-type" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """pdu_type must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="pdu-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__pdu_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_pdu_type(self):
        self.__pdu_type = YANGDynClass(base=unicode , is_leaf=True , yang_name="pdu-type" , parent=self ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                       defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_count(self):
        """
    Getter method for count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/count (uint64)

    YANG Description: Number of instances of VDU
    """
        return self.__count

    def _set_count(self , v , load=False):
        """
    Setter method for count, mapped from YANG variable /vnfd_catalog/vnfd/vdu/count (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.

    YANG Description: Number of instances of VDU
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="count" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """count must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__count = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_count(self):
        self.__count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="count" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

    def _get_mgmt_vpci(self):
        """
    Getter method for mgmt_vpci, mapped from YANG variable /vnfd_catalog/vnfd/vdu/mgmt_vpci (string)

    YANG Description: Specifies the virtual PCI address. Expressed in
the following format dddd:dd:dd.d. For example
0000:00:12.0. This information can be used to
pass as metadata during the VM creation.
    """
        return self.__mgmt_vpci

    def _set_mgmt_vpci(self , v , load=False):
        """
    Setter method for mgmt_vpci, mapped from YANG variable /vnfd_catalog/vnfd/vdu/mgmt_vpci (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_vpci is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_vpci() directly.

    YANG Description: Specifies the virtual PCI address. Expressed in
the following format dddd:dd:dd.d. For example
0000:00:12.0. This information can be used to
pass as metadata during the VM creation.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="mgmt-vpci" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """mgmt_vpci must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="mgmt-vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__mgmt_vpci = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_mgmt_vpci(self):
        self.__mgmt_vpci = YANGDynClass(base=unicode , is_leaf=True , yang_name="mgmt-vpci" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                        defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_vm_flavor(self):
        """
    Getter method for vm_flavor, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vm_flavor (container)
    """
        return self.__vm_flavor

    def _set_vm_flavor(self , v , load=False):
        """
    Setter method for vm_flavor, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vm_flavor (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vm_flavor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vm_flavor() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_vm_flavor_vnfd__vnfd_catalog_vnfd_vdu_vm_flavor , is_container='container' ,
                             yang_name="vm-flavor" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vm_flavor must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_vm_flavor_vnfd__vnfd_catalog_vnfd_vdu_vm_flavor, is_container='container', yang_name="vm-flavor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__vm_flavor = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vm_flavor(self):
        self.__vm_flavor = YANGDynClass(base=yc_vm_flavor_vnfd__vnfd_catalog_vnfd_vdu_vm_flavor ,
                                        is_container='container' , yang_name="vm-flavor" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , extensions=None ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='container' , is_config=True)

    def _get_guest_epa(self):
        """
    Getter method for guest_epa, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa (container)
    """
        return self.__guest_epa

    def _set_guest_epa(self , v , load=False):
        """
    Setter method for guest_epa, mapped from YANG variable /vnfd_catalog/vnfd/vdu/guest_epa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_guest_epa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_guest_epa() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_guest_epa_vnfd__vnfd_catalog_vnfd_vdu_guest_epa , is_container='container' ,
                             yang_name="guest-epa" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """guest_epa must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_guest_epa_vnfd__vnfd_catalog_vnfd_vdu_guest_epa, is_container='container', yang_name="guest-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__guest_epa = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_guest_epa(self):
        self.__guest_epa = YANGDynClass(base=yc_guest_epa_vnfd__vnfd_catalog_vnfd_vdu_guest_epa ,
                                        is_container='container' , yang_name="guest-epa" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , extensions=None ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                        yang_type='container' , is_config=True)

    def _get_vswitch_epa(self):
        """
    Getter method for vswitch_epa, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vswitch_epa (container)
    """
        return self.__vswitch_epa

    def _set_vswitch_epa(self , v , load=False):
        """
    Setter method for vswitch_epa, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vswitch_epa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vswitch_epa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vswitch_epa() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_vswitch_epa_vnfd__vnfd_catalog_vnfd_vdu_vswitch_epa ,
                             is_container='container' , yang_name="vswitch-epa" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vswitch_epa must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_vswitch_epa_vnfd__vnfd_catalog_vnfd_vdu_vswitch_epa, is_container='container', yang_name="vswitch-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__vswitch_epa = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vswitch_epa(self):
        self.__vswitch_epa = YANGDynClass(base=yc_vswitch_epa_vnfd__vnfd_catalog_vnfd_vdu_vswitch_epa ,
                                          is_container='container' , yang_name="vswitch-epa" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , extensions=None ,
                                          namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                          yang_type='container' , is_config=True)

    def _get_hypervisor_epa(self):
        """
    Getter method for hypervisor_epa, mapped from YANG variable /vnfd_catalog/vnfd/vdu/hypervisor_epa (container)
    """
        return self.__hypervisor_epa

    def _set_hypervisor_epa(self , v , load=False):
        """
    Setter method for hypervisor_epa, mapped from YANG variable /vnfd_catalog/vnfd/vdu/hypervisor_epa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hypervisor_epa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hypervisor_epa() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_hypervisor_epa_vnfd__vnfd_catalog_vnfd_vdu_hypervisor_epa ,
                             is_container='container' , yang_name="hypervisor-epa" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """hypervisor_epa must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_hypervisor_epa_vnfd__vnfd_catalog_vnfd_vdu_hypervisor_epa, is_container='container', yang_name="hypervisor-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__hypervisor_epa = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_hypervisor_epa(self):
        self.__hypervisor_epa = YANGDynClass(base=yc_hypervisor_epa_vnfd__vnfd_catalog_vnfd_vdu_hypervisor_epa ,
                                             is_container='container' , yang_name="hypervisor-epa" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , extensions=None ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='container' , is_config=True)

    def _get_host_epa(self):
        """
    Getter method for host_epa, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa (container)

    YANG Description: Specifies the host level EPA attributes.
    """
        return self.__host_epa

    def _set_host_epa(self , v , load=False):
        """
    Setter method for host_epa, mapped from YANG variable /vnfd_catalog/vnfd/vdu/host_epa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_host_epa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_host_epa() directly.

    YANG Description: Specifies the host level EPA attributes.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_host_epa_vnfd__vnfd_catalog_vnfd_vdu_host_epa , is_container='container' ,
                             yang_name="host-epa" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """host_epa must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_host_epa_vnfd__vnfd_catalog_vnfd_vdu_host_epa, is_container='container', yang_name="host-epa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__host_epa = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_host_epa(self):
        self.__host_epa = YANGDynClass(base=yc_host_epa_vnfd__vnfd_catalog_vnfd_vdu_host_epa ,
                                       is_container='container' , yang_name="host-epa" , parent=self ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , extensions=None ,
                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                       yang_type='container' , is_config=True)

    def _get_alarm(self):
        """
    Getter method for alarm, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm (list)
    """
        return self.__alarm

    def _set_alarm(self , v , load=False):
        """
    Setter method for alarm, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alarm (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("alarm_id" , yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm ,
                                                   yang_name="alarm" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='alarm-id' , extensions=None) , is_container='list' ,
                             yang_name="alarm" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """alarm must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("alarm_id",yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='alarm-id', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__alarm = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_alarm(self):
        self.__alarm = YANGDynClass(
            base=YANGListType("alarm_id" , yc_alarm_vnfd__vnfd_catalog_vnfd_vdu_alarm , yang_name="alarm" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='alarm-id' , extensions=None) , is_container='list' , yang_name="alarm" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='list' , is_config=True)

    def _get_image(self):
        """
    Getter method for image, mapped from YANG variable /vnfd_catalog/vnfd/vdu/image (string)

    YANG Description: Image name for the software image.
If the image name is found within the VNF package it will
be uploaded to all VIM accounts during onboarding process.
Otherwise, the image must be added to the VIM account with
the same name as entered here.

    """
        return self.__image

    def _set_image(self , v , load=False):
        """
    Setter method for image, mapped from YANG variable /vnfd_catalog/vnfd/vdu/image (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image() directly.

    YANG Description: Image name for the software image.
If the image name is found within the VNF package it will
be uploaded to all VIM accounts during onboarding process.
Otherwise, the image must be added to the VIM account with
the same name as entered here.

    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="image" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """image must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__image = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_image(self):
        self.__image = YANGDynClass(base=unicode , is_leaf=True , yang_name="image" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)

    def _get_image_checksum(self):
        """
    Getter method for image_checksum, mapped from YANG variable /vnfd_catalog/vnfd/vdu/image_checksum (string)

    YANG Description: Image md5sum for the software image.
The md5sum, if provided, along with the image name uniquely
identifies an image uploaded to the CAL.

    """
        return self.__image_checksum

    def _set_image_checksum(self , v , load=False):
        """
    Setter method for image_checksum, mapped from YANG variable /vnfd_catalog/vnfd/vdu/image_checksum (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image_checksum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image_checksum() directly.

    YANG Description: Image md5sum for the software image.
The md5sum, if provided, along with the image name uniquely
identifies an image uploaded to the CAL.

    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="image-checksum" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """image_checksum must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="image-checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__image_checksum = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_image_checksum(self):
        self.__image_checksum = YANGDynClass(base=unicode , is_leaf=True , yang_name="image-checksum" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_alternative_images(self):
        """
    Getter method for alternative_images, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alternative_images (list)

    YANG Description: List of alternative images per VIM type.
Different images can be used for specific types of VIMs instead
of the default image. This allows deployments in sites where the
image identifier in the VIM is given by the VIM provider and
cannot be modified.
If an alternative image is specified for a VIM type, it will prevail
over the default image
    """
        return self.__alternative_images

    def _set_alternative_images(self , v , load=False):
        """
    Setter method for alternative_images, mapped from YANG variable /vnfd_catalog/vnfd/vdu/alternative_images (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alternative_images is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alternative_images() directly.

    YANG Description: List of alternative images per VIM type.
Different images can be used for specific types of VIMs instead
of the default image. This allows deployments in sites where the
image identifier in the VIM is given by the VIM provider and
cannot be modified.
If an alternative image is specified for a VIM type, it will prevail
over the default image
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("vim_type" ,
                                                   yc_alternative_images_vnfd__vnfd_catalog_vnfd_vdu_alternative_images ,
                                                   yang_name="alternative-images" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='vim-type' , extensions=None) , is_container='list' ,
                             yang_name="alternative-images" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """alternative_images must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("vim_type",yc_alternative_images_vnfd__vnfd_catalog_vnfd_vdu_alternative_images, yang_name="alternative-images", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vim-type', extensions=None), is_container='list', yang_name="alternative-images", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__alternative_images = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_alternative_images(self):
        self.__alternative_images = YANGDynClass(
            base=YANGListType("vim_type" , yc_alternative_images_vnfd__vnfd_catalog_vnfd_vdu_alternative_images ,
                              yang_name="alternative-images" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='vim-type' , extensions=None) ,
            is_container='list' , yang_name="alternative-images" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    def _get_vdu_configuration(self):
        """
    Getter method for vdu_configuration, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration (container)
    """
        return self.__vdu_configuration

    def _set_vdu_configuration(self , v , load=False):
        """
    Setter method for vdu_configuration, mapped from YANG variable /vnfd_catalog/vnfd/vdu/vdu_configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_configuration() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_vdu_configuration_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration ,
                             is_container='container' , yang_name="vdu-configuration" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vdu_configuration must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_vdu_configuration_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration, is_container='container', yang_name="vdu-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__vdu_configuration = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vdu_configuration(self):
        self.__vdu_configuration = YANGDynClass(
            base=yc_vdu_configuration_vnfd__vnfd_catalog_vnfd_vdu_vdu_configuration , is_container='container' ,
            yang_name="vdu-configuration" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='container' , is_config=True)

    def _get_monitoring_param(self):
        """
    Getter method for monitoring_param, mapped from YANG variable /vnfd_catalog/vnfd/vdu/monitoring_param (list)

    YANG Description: List of VDU-related monitoring parameters at NFVI level
    """
        return self.__monitoring_param

    def _set_monitoring_param(self , v , load=False):
        """
    Setter method for monitoring_param, mapped from YANG variable /vnfd_catalog/vnfd/vdu/monitoring_param (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitoring_param is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitoring_param() directly.

    YANG Description: List of VDU-related monitoring parameters at NFVI level
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=YANGListType("id" , yc_monitoring_param_vnfd__vnfd_catalog_vnfd_vdu_monitoring_param ,
                                               yang_name="monitoring-param" , parent=self , is_container='list' ,
                                               user_ordered=False , path_helper=self._path_helper , yang_keys='id' ,
                                               extensions=None) , is_container='list' , yang_name="monitoring-param" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """monitoring_param must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_monitoring_param_vnfd__vnfd_catalog_vnfd_vdu_monitoring_param, yang_name="monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__monitoring_param = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_monitoring_param(self):
        self.__monitoring_param = YANGDynClass(
            base=YANGListType("id" , yc_monitoring_param_vnfd__vnfd_catalog_vnfd_vdu_monitoring_param ,
                              yang_name="monitoring-param" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='id' , extensions=None) , is_container='list' ,
            yang_name="monitoring-param" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='list' , is_config=True)

    def _get_cloud_init(self):
        """
    Getter method for cloud_init, mapped from YANG variable /vnfd_catalog/vnfd/vdu/cloud_init (string)

    YANG Description: Contents of cloud-init script, provided inline, in cloud-config format
    """
        return self.__cloud_init

    def _set_cloud_init(self , v , load=False):
        """
    Setter method for cloud_init, mapped from YANG variable /vnfd_catalog/vnfd/vdu/cloud_init (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud_init is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud_init() directly.

    YANG Description: Contents of cloud-init script, provided inline, in cloud-config format
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="cloud-init" , parent=self ,
                             choice=(u'cloud-init-input' , u'inline') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """cloud_init must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cloud-init", parent=self, choice=(u'cloud-init-input', u'inline'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__cloud_init = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_cloud_init(self):
        self.__cloud_init = YANGDynClass(base=unicode , is_leaf=True , yang_name="cloud-init" , parent=self ,
                                         choice=(u'cloud-init-input' , u'inline') , path_helper=self._path_helper ,
                                         extmethods=self._extmethods , register_paths=True ,
                                         namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                         yang_type='string' , is_config=True)

    def _get_cloud_init_file(self):
        """
    Getter method for cloud_init_file, mapped from YANG variable /vnfd_catalog/vnfd/vdu/cloud_init_file (string)

    YANG Description: Name of file with contents of cloud-init script in cloud-config format
    """
        return self.__cloud_init_file

    def _set_cloud_init_file(self , v , load=False):
        """
    Setter method for cloud_init_file, mapped from YANG variable /vnfd_catalog/vnfd/vdu/cloud_init_file (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud_init_file is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud_init_file() directly.

    YANG Description: Name of file with contents of cloud-init script in cloud-config format
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="cloud-init-file" , parent=self ,
                             choice=(u'cloud-init-input' , u'filename') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """cloud_init_file must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="cloud-init-file", parent=self, choice=(u'cloud-init-input', u'filename'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__cloud_init_file = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_cloud_init_file(self):
        self.__cloud_init_file = YANGDynClass(base=unicode , is_leaf=True , yang_name="cloud-init-file" , parent=self ,
                                              choice=(u'cloud-init-input' , u'filename') ,
                                              path_helper=self._path_helper , extmethods=self._extmethods ,
                                              register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                              defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_supplemental_boot_data(self):
        """
    Getter method for supplemental_boot_data, mapped from YANG variable /vnfd_catalog/vnfd/vdu/supplemental_boot_data (container)
    """
        return self.__supplemental_boot_data

    def _set_supplemental_boot_data(self , v , load=False):
        """
    Setter method for supplemental_boot_data, mapped from YANG variable /vnfd_catalog/vnfd/vdu/supplemental_boot_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supplemental_boot_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supplemental_boot_data() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_supplemental_boot_data_vnfd__vnfd_catalog_vnfd_vdu_supplemental_boot_data ,
                             is_container='container' , yang_name="supplemental-boot-data" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """supplemental_boot_data must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_supplemental_boot_data_vnfd__vnfd_catalog_vnfd_vdu_supplemental_boot_data, is_container='container', yang_name="supplemental-boot-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__supplemental_boot_data = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_supplemental_boot_data(self):
        self.__supplemental_boot_data = YANGDynClass(
            base=yc_supplemental_boot_data_vnfd__vnfd_catalog_vnfd_vdu_supplemental_boot_data ,
            is_container='container' , yang_name="supplemental-boot-data" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)

    def _get_internal_connection_point(self):
        """
    Getter method for internal_connection_point, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point (list)

    YANG Description: List for internal connection points. Each VNFC
has zero or more internal connection points.
Internal connection points are used for connecting
the VNF with components internal to the VNF. If a VNF
has only one VNFC, it may not have any internal
connection points.
    """
        return self.__internal_connection_point

    def _set_internal_connection_point(self , v , load=False):
        """
    Setter method for internal_connection_point, mapped from YANG variable /vnfd_catalog/vnfd/vdu/internal_connection_point (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_internal_connection_point is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_internal_connection_point() directly.

    YANG Description: List for internal connection points. Each VNFC
has zero or more internal connection points.
Internal connection points are used for connecting
the VNF with components internal to the VNF. If a VNF
has only one VNFC, it may not have any internal
connection points.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("id" ,
                                                   yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_vdu_internal_connection_point ,
                                                   yang_name="internal-connection-point" , parent=self ,
                                                   is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='id' , extensions=None) ,
                             is_container='list' , yang_name="internal-connection-point" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """internal_connection_point must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_vdu_internal_connection_point, yang_name="internal-connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="internal-connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__internal_connection_point = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_internal_connection_point(self):
        self.__internal_connection_point = YANGDynClass(base=YANGListType("id" ,
                                                                          yc_internal_connection_point_vnfd__vnfd_catalog_vnfd_vdu_internal_connection_point ,
                                                                          yang_name="internal-connection-point" ,
                                                                          parent=self , is_container='list' ,
                                                                          user_ordered=False ,
                                                                          path_helper=self._path_helper ,
                                                                          yang_keys='id' , extensions=None) ,
                                                        is_container='list' , yang_name="internal-connection-point" ,
                                                        parent=self , path_helper=self._path_helper ,
                                                        extmethods=self._extmethods , register_paths=True ,
                                                        extensions=None ,
                                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                        defining_module='vnfd' , yang_type='list' , is_config=True)

    def _get_interface(self):
        """
    Getter method for interface, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface (list)

    YANG Description: List of Interfaces (external and internal) for the VNF
    """
        return self.__interface

    def _set_interface(self , v , load=False):
        """
    Setter method for interface, mapped from YANG variable /vnfd_catalog/vnfd/vdu/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: List of Interfaces (external and internal) for the VNF
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" , yc_interface_vnfd__vnfd_catalog_vnfd_vdu_interface ,
                                                   yang_name="interface" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="interface" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """interface must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_interface_vnfd__vnfd_catalog_vnfd_vdu_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__interface = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_interface(self):
        self.__interface = YANGDynClass(
            base=YANGListType("name" , yc_interface_vnfd__vnfd_catalog_vnfd_vdu_interface , yang_name="interface" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='name' , extensions=None) , is_container='list' , yang_name="interface" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='list' , is_config=True)

    def _get_volumes(self):
        """
    Getter method for volumes, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes (list)
    """
        return self.__volumes

    def _set_volumes(self , v , load=False):
        """
    Setter method for volumes, mapped from YANG variable /vnfd_catalog/vnfd/vdu/volumes (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_volumes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_volumes() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" , yc_volumes_vnfd__vnfd_catalog_vnfd_vdu_volumes ,
                                                   yang_name="volumes" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="volumes" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """volumes must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_volumes_vnfd__vnfd_catalog_vnfd_vdu_volumes, yang_name="volumes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="volumes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__volumes = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_volumes(self):
        self.__volumes = YANGDynClass(
            base=YANGListType("name" , yc_volumes_vnfd__vnfd_catalog_vnfd_vdu_volumes , yang_name="volumes" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='name' , extensions=None) , is_container='list' , yang_name="volumes" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='list' , is_config=True)

    id = __builtin__.property(_get_id , _set_id)
    name = __builtin__.property(_get_name , _set_name)
    description = __builtin__.property(_get_description , _set_description)
    pdu_type = __builtin__.property(_get_pdu_type , _set_pdu_type)
    count = __builtin__.property(_get_count , _set_count)
    mgmt_vpci = __builtin__.property(_get_mgmt_vpci , _set_mgmt_vpci)
    vm_flavor = __builtin__.property(_get_vm_flavor , _set_vm_flavor)
    guest_epa = __builtin__.property(_get_guest_epa , _set_guest_epa)
    vswitch_epa = __builtin__.property(_get_vswitch_epa , _set_vswitch_epa)
    hypervisor_epa = __builtin__.property(_get_hypervisor_epa , _set_hypervisor_epa)
    host_epa = __builtin__.property(_get_host_epa , _set_host_epa)
    alarm = __builtin__.property(_get_alarm , _set_alarm)
    image = __builtin__.property(_get_image , _set_image)
    image_checksum = __builtin__.property(_get_image_checksum , _set_image_checksum)
    alternative_images = __builtin__.property(_get_alternative_images , _set_alternative_images)
    vdu_configuration = __builtin__.property(_get_vdu_configuration , _set_vdu_configuration)
    monitoring_param = __builtin__.property(_get_monitoring_param , _set_monitoring_param)
    cloud_init = __builtin__.property(_get_cloud_init , _set_cloud_init)
    cloud_init_file = __builtin__.property(_get_cloud_init_file , _set_cloud_init_file)
    supplemental_boot_data = __builtin__.property(_get_supplemental_boot_data , _set_supplemental_boot_data)
    internal_connection_point = __builtin__.property(_get_internal_connection_point , _set_internal_connection_point)
    interface = __builtin__.property(_get_interface , _set_interface)
    volumes = __builtin__.property(_get_volumes , _set_volumes)

    __choices__ = {u'cloud-init-input': {u'inline': [u'cloud_init'] , u'filename': [u'cloud_init_file']}}
    _pyangbind_elements = {'id': id , 'name': name , 'description': description , 'pdu_type': pdu_type ,
                           'count': count , 'mgmt_vpci': mgmt_vpci , 'vm_flavor': vm_flavor , 'guest_epa': guest_epa ,
                           'vswitch_epa': vswitch_epa , 'hypervisor_epa': hypervisor_epa , 'host_epa': host_epa ,
                           'alarm': alarm , 'image': image , 'image_checksum': image_checksum ,
                           'alternative_images': alternative_images , 'vdu_configuration': vdu_configuration ,
                           'monitoring_param': monitoring_param , 'cloud_init': cloud_init ,
                           'cloud_init_file': cloud_init_file , 'supplemental_boot_data': supplemental_boot_data ,
                           'internal_connection_point': internal_connection_point , 'interface': interface ,
                           'volumes': volumes , }


class yc_vdu_dependency_vnfd__vnfd_catalog_vnfd_vdu_dependency(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/vdu-dependency. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VDU dependencies.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__vdu_source_ref' , '__vdu_depends_on_ref' ,)

    _yang_name = 'vdu-dependency'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vdu_depends_on_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vdu-depends-on-ref" ,
                                                 parent=self , path_helper=self._path_helper ,
                                                 extmethods=self._extmethods , register_paths=True ,
                                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                 defining_module='vnfd' , yang_type='leafref' , is_config=True)
        self.__vdu_source_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vdu-source-ref" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , is_keyval=True ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='leafref' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'vdu-dependency']

    def _get_vdu_source_ref(self):
        """
    Getter method for vdu_source_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu_dependency/vdu_source_ref (leafref)
    """
        return self.__vdu_source_ref

    def _set_vdu_source_ref(self , v , load=False):
        """
    Setter method for vdu_source_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu_dependency/vdu_source_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_source_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_source_ref() directly.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vdu-source-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vdu_source_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vdu-source-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vdu_source_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vdu_source_ref(self):
        self.__vdu_source_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vdu-source-ref" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , is_keyval=True ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='leafref' , is_config=True)

    def _get_vdu_depends_on_ref(self):
        """
    Getter method for vdu_depends_on_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu_dependency/vdu_depends_on_ref (leafref)

    YANG Description: Reference to the VDU on which
the source VDU depends.
    """
        return self.__vdu_depends_on_ref

    def _set_vdu_depends_on_ref(self , v , load=False):
        """
    Setter method for vdu_depends_on_ref, mapped from YANG variable /vnfd_catalog/vnfd/vdu_dependency/vdu_depends_on_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_depends_on_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_depends_on_ref() directly.

    YANG Description: Reference to the VDU on which
the source VDU depends.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vdu-depends-on-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vdu_depends_on_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vdu-depends-on-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vdu_depends_on_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vdu_depends_on_ref(self):
        self.__vdu_depends_on_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vdu-depends-on-ref" ,
                                                 parent=self , path_helper=self._path_helper ,
                                                 extmethods=self._extmethods , register_paths=True ,
                                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                 defining_module='vnfd' , yang_type='leafref' , is_config=True)

    vdu_source_ref = __builtin__.property(_get_vdu_source_ref , _set_vdu_source_ref)
    vdu_depends_on_ref = __builtin__.property(_get_vdu_depends_on_ref , _set_vdu_depends_on_ref)

    _pyangbind_elements = {'vdu_source_ref': vdu_source_ref , 'vdu_depends_on_ref': vdu_depends_on_ref , }


class yc_headers_vnfd__vnfd_catalog_vnfd_http_endpoint_headers(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/http-endpoint/headers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Custom HTTP headers to put on HTTP request
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__key' , '__value' ,)

    _yang_name = 'headers'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__value = YANGDynClass(base=unicode , is_leaf=True , yang_name="value" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)
        self.__key = YANGDynClass(base=unicode , is_leaf=True , yang_name="key" , parent=self ,
                                  path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                  is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                  defining_module='vnfd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'http-endpoint' , u'headers']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/headers/key (string)

    YANG Description: HTTP header key
    """
        return self.__key

    def _set_key(self , v , load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/headers/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: HTTP header key
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="key" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__key = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=unicode , is_leaf=True , yang_name="key" , parent=self ,
                                  path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                  is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                  defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/headers/value (string)

    YANG Description: HTTP header value
    """
        return self.__value

    def _set_value(self , v , load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/headers/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: HTTP header value
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="value" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__value = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=unicode , is_leaf=True , yang_name="value" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)

    key = __builtin__.property(_get_key , _set_key)
    value = __builtin__.property(_get_value , _set_value)

    _pyangbind_elements = {'key': key , 'value': value , }


class yc_http_endpoint_vnfd__vnfd_catalog_vnfd_http_endpoint(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/http-endpoint. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of http endpoints to be used by monitoring params
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__path' , '__https' , '__port' , '__username' , '__password' ,
                 '__polling_interval_secs' , '__method' , '__headers' ,)

    _yang_name = 'http-endpoint'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__username = YANGDynClass(base=unicode , is_leaf=True , yang_name="username" , parent=self ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                       defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__polling_interval_secs = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            default=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8)(2) ,
            is_leaf=True , yang_name="polling-interval-secs" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint8' , is_config=True)
        self.__method = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                              restriction_arg={u'GET': {} , u'PATCH': {} , u'PUT': {} ,
                                                                               u'POST': {} , u'OPTIONS': {} ,
                                                                               u'DELETE': {}} , ) ,
                                     default=unicode("GET") , is_leaf=True , yang_name="method" , parent=self ,
                                     path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                     yang_type='manotypes:http-method' , is_config=True)
        self.__headers = YANGDynClass(
            base=YANGListType("key" , yc_headers_vnfd__vnfd_catalog_vnfd_http_endpoint_headers , yang_name="headers" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='key' , extensions=None) , is_container='list' , yang_name="headers" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='list' , is_config=True)
        self.__https = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="https" ,
                                    parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                    register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                    defining_module='vnfd' , yang_type='boolean' , is_config=True)
        self.__path = YANGDynClass(base=unicode , is_leaf=True , yang_name="path" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__password = YANGDynClass(base=unicode , is_leaf=True , yang_name="password" , parent=self ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                       defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__port = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
            restriction_dict={'range': [u'0..65535']}) , is_leaf=True , yang_name="port" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='inet:port-number' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'http-endpoint']

    def _get_path(self):
        """
    Getter method for path, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/path (string)

    YANG Description: The HTTP path on the management server
    """
        return self.__path

    def _set_path(self , v , load=False):
        """
    Setter method for path, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/path (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path() directly.

    YANG Description: The HTTP path on the management server
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="path" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """path must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__path = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_path(self):
        self.__path = YANGDynClass(base=unicode , is_leaf=True , yang_name="path" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_https(self):
        """
    Getter method for https, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/https (boolean)

    YANG Description: Pick HTTPS instead of HTTP , Default is false
    """
        return self.__https

    def _set_https(self , v , load=False):
        """
    Setter method for https, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/https (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_https is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_https() directly.

    YANG Description: Pick HTTPS instead of HTTP , Default is false
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="https" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """https must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="https", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__https = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_https(self):
        self.__https = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="https" ,
                                    parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                    register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                    defining_module='vnfd' , yang_type='boolean' , is_config=True)

    def _get_port(self):
        """
    Getter method for port, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/port (inet:port-number)

    YANG Description: The HTTP port to connect to
    """
        return self.__port

    def _set_port(self , v , load=False):
        """
    Setter method for port, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: The HTTP port to connect to
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(
                base_type=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
                restriction_dict={'range': [u'0..65535']}) , is_leaf=True , yang_name="port" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='inet:port-number' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """port must be of a type compatible with inet:port-number""" ,
                'defined-type': "inet:port-number" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='inet:port-number', is_config=True)""" ,
            })

        self.__port = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_port(self):
        self.__port = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
            restriction_dict={'range': [u'0..65535']}) , is_leaf=True , yang_name="port" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='inet:port-number' , is_config=True)

    def _get_username(self):
        """
    Getter method for username, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/username (string)

    YANG Description: The HTTP basic auth username
    """
        return self.__username

    def _set_username(self , v , load=False):
        """
    Setter method for username, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/username (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_username is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_username() directly.

    YANG Description: The HTTP basic auth username
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="username" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """username must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="username", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__username = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_username(self):
        self.__username = YANGDynClass(base=unicode , is_leaf=True , yang_name="username" , parent=self ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                       defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_password(self):
        """
    Getter method for password, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/password (string)

    YANG Description: The HTTP basic auth password
    """
        return self.__password

    def _set_password(self , v , load=False):
        """
    Setter method for password, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_password() directly.

    YANG Description: The HTTP basic auth password
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="password" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """password must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__password = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_password(self):
        self.__password = YANGDynClass(base=unicode , is_leaf=True , yang_name="password" , parent=self ,
                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                       defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_polling_interval_secs(self):
        """
    Getter method for polling_interval_secs, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/polling_interval_secs (uint8)

    YANG Description: The HTTP polling interval in seconds
    """
        return self.__polling_interval_secs

    def _set_polling_interval_secs(self , v , load=False):
        """
    Setter method for polling_interval_secs, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/polling_interval_secs (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_polling_interval_secs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_polling_interval_secs() directly.

    YANG Description: The HTTP polling interval in seconds
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} ,
                                                          int_size=8) ,
                             default=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} ,
                                                         int_size=8)(2) , is_leaf=True ,
                             yang_name="polling-interval-secs" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint8' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """polling_interval_secs must be of a type compatible with uint8""" ,
                'defined-type': "uint8" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(2), is_leaf=True, yang_name="polling-interval-secs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)""" ,
            })

        self.__polling_interval_secs = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_polling_interval_secs(self):
        self.__polling_interval_secs = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            default=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8)(2) ,
            is_leaf=True , yang_name="polling-interval-secs" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint8' , is_config=True)

    def _get_method(self):
        """
    Getter method for method, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/method (manotypes:http-method)

    YANG Description: Method that the URI should perform.
Deafult action is GET.
    """
        return self.__method

    def _set_method(self , v , load=False):
        """
    Setter method for method, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/method (manotypes:http-method)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_method() directly.

    YANG Description: Method that the URI should perform.
Deafult action is GET.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'GET': {} , u'PATCH': {} , u'PUT': {} ,
                                                                           u'POST': {} , u'OPTIONS': {} ,
                                                                           u'DELETE': {}} , ) , default=unicode("GET") ,
                             is_leaf=True , yang_name="method" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='manotypes:http-method' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """method must be of a type compatible with manotypes:http-method""" ,
                'defined-type': "manotypes:http-method" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GET': {}, u'PATCH': {}, u'PUT': {}, u'POST': {}, u'OPTIONS': {}, u'DELETE': {}},), default=unicode("GET"), is_leaf=True, yang_name="method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='manotypes:http-method', is_config=True)""" ,
            })

        self.__method = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_method(self):
        self.__method = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                              restriction_arg={u'GET': {} , u'PATCH': {} , u'PUT': {} ,
                                                                               u'POST': {} , u'OPTIONS': {} ,
                                                                               u'DELETE': {}} , ) ,
                                     default=unicode("GET") , is_leaf=True , yang_name="method" , parent=self ,
                                     path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                     yang_type='manotypes:http-method' , is_config=True)

    def _get_headers(self):
        """
    Getter method for headers, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/headers (list)

    YANG Description: Custom HTTP headers to put on HTTP request
    """
        return self.__headers

    def _set_headers(self , v , load=False):
        """
    Setter method for headers, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint/headers (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_headers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_headers() directly.

    YANG Description: Custom HTTP headers to put on HTTP request
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("key" , yc_headers_vnfd__vnfd_catalog_vnfd_http_endpoint_headers ,
                                                   yang_name="headers" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='key' , extensions=None) , is_container='list' ,
                             yang_name="headers" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """headers must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_headers_vnfd__vnfd_catalog_vnfd_http_endpoint_headers, yang_name="headers", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="headers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__headers = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_headers(self):
        self.__headers = YANGDynClass(
            base=YANGListType("key" , yc_headers_vnfd__vnfd_catalog_vnfd_http_endpoint_headers , yang_name="headers" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='key' , extensions=None) , is_container='list' , yang_name="headers" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='list' , is_config=True)

    path = __builtin__.property(_get_path , _set_path)
    https = __builtin__.property(_get_https , _set_https)
    port = __builtin__.property(_get_port , _set_port)
    username = __builtin__.property(_get_username , _set_username)
    password = __builtin__.property(_get_password , _set_password)
    polling_interval_secs = __builtin__.property(_get_polling_interval_secs , _set_polling_interval_secs)
    method = __builtin__.property(_get_method , _set_method)
    headers = __builtin__.property(_get_headers , _set_headers)

    _pyangbind_elements = {'path': path , 'https': https , 'port': port , 'username': username , 'password': password ,
                           'polling_interval_secs': polling_interval_secs , 'method': method , 'headers': headers , }


class yc_scaling_criteria_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy_scaling_criteria(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/scaling-group-descriptor/scaling-policy/scaling-criteria. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: list of conditions to be met for generating scaling
  requests
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__name' , '__scale_in_threshold' , '__scale_in_relational_operation' ,
    '__scale_out_threshold' , '__scale_out_relational_operation' , '__vnf_monitoring_param_ref' ,)

    _yang_name = 'scaling-criteria'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__scale_out_threshold = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="scale-out-threshold" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)
        self.__vnf_monitoring_param_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                       yang_name="vnf-monitoring-param-ref" , parent=self ,
                                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                                       register_paths=True ,
                                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                       defining_module='vnfd' , yang_type='leafref' , is_config=True)
        self.__scale_in_threshold = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="scale-in-threshold" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)
        self.__scale_out_relational_operation = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'GE': {} , u'LE': {} , u'EQ': {} , u'LT': {} , u'GT': {}} , ) ,
            default=unicode("GE") , is_leaf=True , yang_name="scale-out-relational-operation" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='manotypes:relational-operation-type' , is_config=True)
        self.__scale_in_relational_operation = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'GE': {} , u'LE': {} , u'EQ': {} , u'LT': {} , u'GT': {}} , ) ,
            default=unicode("LE") , is_leaf=True , yang_name="scale-in-relational-operation" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='manotypes:relational-operation-type' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'scaling-group-descriptor' , u'scaling-policy' , u'scaling-criteria']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/name (string)
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_scale_in_threshold(self):
        """
    Getter method for scale_in_threshold, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_in_threshold (uint64)

    YANG Description: Value below which scale-in requests are generated
    """
        return self.__scale_in_threshold

    def _set_scale_in_threshold(self , v , load=False):
        """
    Setter method for scale_in_threshold, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_in_threshold (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_in_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_in_threshold() directly.

    YANG Description: Value below which scale-in requests are generated
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="scale-in-threshold" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scale_in_threshold must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="scale-in-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__scale_in_threshold = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scale_in_threshold(self):
        self.__scale_in_threshold = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="scale-in-threshold" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

    def _get_scale_in_relational_operation(self):
        """
    Getter method for scale_in_relational_operation, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_in_relational_operation (manotypes:relational-operation-type)

    YANG Description: The relational operator used to compare the monitoring param
against the scale-in-threshold.
    """
        return self.__scale_in_relational_operation

    def _set_scale_in_relational_operation(self , v , load=False):
        """
    Setter method for scale_in_relational_operation, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_in_relational_operation (manotypes:relational-operation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_in_relational_operation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_in_relational_operation() directly.

    YANG Description: The relational operator used to compare the monitoring param
against the scale-in-threshold.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'GE': {} , u'LE': {} , u'EQ': {} ,
                                                                           u'LT': {} , u'GT': {}} , ) ,
                             default=unicode("LE") , is_leaf=True , yang_name="scale-in-relational-operation" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='manotypes:relational-operation-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scale_in_relational_operation must be of a type compatible with manotypes:relational-operation-type""" ,
                'defined-type': "manotypes:relational-operation-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=unicode("LE"), is_leaf=True, yang_name="scale-in-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='manotypes:relational-operation-type', is_config=True)""" ,
            })

        self.__scale_in_relational_operation = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scale_in_relational_operation(self):
        self.__scale_in_relational_operation = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'GE': {} , u'LE': {} , u'EQ': {} , u'LT': {} , u'GT': {}} , ) ,
            default=unicode("LE") , is_leaf=True , yang_name="scale-in-relational-operation" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='manotypes:relational-operation-type' , is_config=True)

    def _get_scale_out_threshold(self):
        """
    Getter method for scale_out_threshold, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_out_threshold (uint64)

    YANG Description: Value above which scale-out requests are generated
    """
        return self.__scale_out_threshold

    def _set_scale_out_threshold(self , v , load=False):
        """
    Setter method for scale_out_threshold, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_out_threshold (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_out_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_out_threshold() directly.

    YANG Description: Value above which scale-out requests are generated
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True ,
                             yang_name="scale-out-threshold" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scale_out_threshold must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="scale-out-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__scale_out_threshold = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scale_out_threshold(self):
        self.__scale_out_threshold = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="scale-out-threshold" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

    def _get_scale_out_relational_operation(self):
        """
    Getter method for scale_out_relational_operation, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_out_relational_operation (manotypes:relational-operation-type)

    YANG Description: The relational operator used to compare the monitoring param
against the scale-out-threshold.
    """
        return self.__scale_out_relational_operation

    def _set_scale_out_relational_operation(self , v , load=False):
        """
    Setter method for scale_out_relational_operation, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_out_relational_operation (manotypes:relational-operation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_out_relational_operation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_out_relational_operation() directly.

    YANG Description: The relational operator used to compare the monitoring param
against the scale-out-threshold.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'GE': {} , u'LE': {} , u'EQ': {} ,
                                                                           u'LT': {} , u'GT': {}} , ) ,
                             default=unicode("GE") , is_leaf=True , yang_name="scale-out-relational-operation" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='manotypes:relational-operation-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scale_out_relational_operation must be of a type compatible with manotypes:relational-operation-type""" ,
                'defined-type': "manotypes:relational-operation-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=unicode("GE"), is_leaf=True, yang_name="scale-out-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='manotypes:relational-operation-type', is_config=True)""" ,
            })

        self.__scale_out_relational_operation = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scale_out_relational_operation(self):
        self.__scale_out_relational_operation = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'GE': {} , u'LE': {} , u'EQ': {} , u'LT': {} , u'GT': {}} , ) ,
            default=unicode("GE") , is_leaf=True , yang_name="scale-out-relational-operation" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='manotypes:relational-operation-type' , is_config=True)

    def _get_vnf_monitoring_param_ref(self):
        """
    Getter method for vnf_monitoring_param_ref, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/vnf_monitoring_param_ref (leafref)

    YANG Description: Reference to the VNF level monitoring parameter
that is aggregated
    """
        return self.__vnf_monitoring_param_ref

    def _set_vnf_monitoring_param_ref(self , v , load=False):
        """
    Setter method for vnf_monitoring_param_ref, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria/vnf_monitoring_param_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_monitoring_param_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_monitoring_param_ref() directly.

    YANG Description: Reference to the VNF level monitoring parameter
that is aggregated
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnf-monitoring-param-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnf_monitoring_param_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnf-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vnf_monitoring_param_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnf_monitoring_param_ref(self):
        self.__vnf_monitoring_param_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                       yang_name="vnf-monitoring-param-ref" , parent=self ,
                                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                                       register_paths=True ,
                                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                       defining_module='vnfd' , yang_type='leafref' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    scale_in_threshold = __builtin__.property(_get_scale_in_threshold , _set_scale_in_threshold)
    scale_in_relational_operation = __builtin__.property(_get_scale_in_relational_operation ,
                                                         _set_scale_in_relational_operation)
    scale_out_threshold = __builtin__.property(_get_scale_out_threshold , _set_scale_out_threshold)
    scale_out_relational_operation = __builtin__.property(_get_scale_out_relational_operation ,
                                                          _set_scale_out_relational_operation)
    vnf_monitoring_param_ref = __builtin__.property(_get_vnf_monitoring_param_ref , _set_vnf_monitoring_param_ref)

    _pyangbind_elements = {'name': name , 'scale_in_threshold': scale_in_threshold ,
                           'scale_in_relational_operation': scale_in_relational_operation ,
                           'scale_out_threshold': scale_out_threshold ,
                           'scale_out_relational_operation': scale_out_relational_operation ,
                           'vnf_monitoring_param_ref': vnf_monitoring_param_ref , }


class yc_scaling_policy_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/scaling-group-descriptor/scaling-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__name' , '__scaling_type' , '__enabled' , '__scale_in_operation_type' ,
    '__scale_out_operation_type' , '__threshold_time' , '__cooldown_time' , '__scaling_criteria' ,)

    _yang_name = 'scaling-policy'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__scale_out_operation_type = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'AND': {'value': 1} , u'OR': {'value': 2}} , ) ,
            default=unicode("OR") , is_leaf=True , yang_name="scale-out-operation-type" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='manotypes:scaling-criteria-operation' , is_config=True)
        self.__scale_in_operation_type = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'AND': {'value': 1} , u'OR': {'value': 2}} , ) ,
            default=unicode("AND") , is_leaf=True , yang_name="scale-in-operation-type" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='manotypes:scaling-criteria-operation' , is_config=True)
        self.__enabled = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="enabled" ,
                                      parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                      defining_module='vnfd' , yang_type='boolean' , is_config=True)
        self.__cooldown_time = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="cooldown-time" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)
        self.__scaling_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                    restriction_arg={u'automatic': {'value': 2} ,
                                                                                     u'manual': {'value': 1}} , ) ,
                                           is_leaf=True , yang_name="scaling-type" , parent=self ,
                                           path_helper=self._path_helper , extmethods=self._extmethods ,
                                           register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                           defining_module='vnfd' , yang_type='manotypes:scaling-policy-type' ,
                                           is_config=True)
        self.__threshold_time = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="threshold-time" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)
        self.__scaling_criteria = YANGDynClass(base=YANGListType("name" ,
                                                                 yc_scaling_criteria_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy_scaling_criteria ,
                                                                 yang_name="scaling-criteria" , parent=self ,
                                                                 is_container='list' , user_ordered=False ,
                                                                 path_helper=self._path_helper , yang_keys='name' ,
                                                                 extensions=None) , is_container='list' ,
                                               yang_name="scaling-criteria" , parent=self ,
                                               path_helper=self._path_helper , extmethods=self._extmethods ,
                                               register_paths=True , extensions=None ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                               defining_module='vnfd' , yang_type='list' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'scaling-group-descriptor' , u'scaling-policy']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/name (string)

    YANG Description: Name of the scaling policy
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the scaling policy
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_scaling_type(self):
        """
    Getter method for scaling_type, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_type (manotypes:scaling-policy-type)

    YANG Description: Type of scaling
    """
        return self.__scaling_type

    def _set_scaling_type(self , v , load=False):
        """
    Setter method for scaling_type, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_type (manotypes:scaling-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_type() directly.

    YANG Description: Type of scaling
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'automatic': {'value': 2} ,
                                                                           u'manual': {'value': 1}} , ) , is_leaf=True ,
                             yang_name="scaling-type" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='manotypes:scaling-policy-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scaling_type must be of a type compatible with manotypes:scaling-policy-type""" ,
                'defined-type': "manotypes:scaling-policy-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'automatic': {'value': 2}, u'manual': {'value': 1}},), is_leaf=True, yang_name="scaling-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-policy-type', is_config=True)""" ,
            })

        self.__scaling_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scaling_type(self):
        self.__scaling_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                    restriction_arg={u'automatic': {'value': 2} ,
                                                                                     u'manual': {'value': 1}} , ) ,
                                           is_leaf=True , yang_name="scaling-type" , parent=self ,
                                           path_helper=self._path_helper , extmethods=self._extmethods ,
                                           register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                           defining_module='vnfd' , yang_type='manotypes:scaling-policy-type' ,
                                           is_config=True)

    def _get_enabled(self):
        """
    Getter method for enabled, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/enabled (boolean)

    YANG Description: Specifies if the scaling policy can be applied
    """
        return self.__enabled

    def _set_enabled(self , v , load=False):
        """
    Setter method for enabled, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Specifies if the scaling policy can be applied
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="enabled" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """enabled must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='boolean', is_config=True)""" ,
            })

        self.__enabled = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_enabled(self):
        self.__enabled = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="enabled" ,
                                      parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                      defining_module='vnfd' , yang_type='boolean' , is_config=True)

    def _get_scale_in_operation_type(self):
        """
    Getter method for scale_in_operation_type, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scale_in_operation_type (manotypes:scaling-criteria-operation)

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale in threshold condition has been met.
Defaults to AND
    """
        return self.__scale_in_operation_type

    def _set_scale_in_operation_type(self , v , load=False):
        """
    Setter method for scale_in_operation_type, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scale_in_operation_type (manotypes:scaling-criteria-operation)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_in_operation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_in_operation_type() directly.

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale in threshold condition has been met.
Defaults to AND
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'AND': {'value': 1} ,
                                                                           u'OR': {'value': 2}} , ) ,
                             default=unicode("AND") , is_leaf=True , yang_name="scale-in-operation-type" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='manotypes:scaling-criteria-operation' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scale_in_operation_type must be of a type compatible with manotypes:scaling-criteria-operation""" ,
                'defined-type': "manotypes:scaling-criteria-operation" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {'value': 1}, u'OR': {'value': 2}},), default=unicode("AND"), is_leaf=True, yang_name="scale-in-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-criteria-operation', is_config=True)""" ,
            })

        self.__scale_in_operation_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scale_in_operation_type(self):
        self.__scale_in_operation_type = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'AND': {'value': 1} , u'OR': {'value': 2}} , ) ,
            default=unicode("AND") , is_leaf=True , yang_name="scale-in-operation-type" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='manotypes:scaling-criteria-operation' , is_config=True)

    def _get_scale_out_operation_type(self):
        """
    Getter method for scale_out_operation_type, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scale_out_operation_type (manotypes:scaling-criteria-operation)

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale out threshold condition has been met.
Defauls to OR
    """
        return self.__scale_out_operation_type

    def _set_scale_out_operation_type(self , v , load=False):
        """
    Setter method for scale_out_operation_type, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scale_out_operation_type (manotypes:scaling-criteria-operation)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_out_operation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_out_operation_type() directly.

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale out threshold condition has been met.
Defauls to OR
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'AND': {'value': 1} ,
                                                                           u'OR': {'value': 2}} , ) ,
                             default=unicode("OR") , is_leaf=True , yang_name="scale-out-operation-type" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='manotypes:scaling-criteria-operation' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scale_out_operation_type must be of a type compatible with manotypes:scaling-criteria-operation""" ,
                'defined-type': "manotypes:scaling-criteria-operation" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {'value': 1}, u'OR': {'value': 2}},), default=unicode("OR"), is_leaf=True, yang_name="scale-out-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-criteria-operation', is_config=True)""" ,
            })

        self.__scale_out_operation_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scale_out_operation_type(self):
        self.__scale_out_operation_type = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'AND': {'value': 1} , u'OR': {'value': 2}} , ) ,
            default=unicode("OR") , is_leaf=True , yang_name="scale-out-operation-type" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='manotypes:scaling-criteria-operation' , is_config=True)

    def _get_threshold_time(self):
        """
    Getter method for threshold_time, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/threshold_time (uint32)

    YANG Description: The duration for which the criteria must hold true
    """
        return self.__threshold_time

    def _set_threshold_time(self , v , load=False):
        """
    Setter method for threshold_time, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/threshold_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold_time() directly.

    YANG Description: The duration for which the criteria must hold true
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , is_leaf=True , yang_name="threshold-time" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """threshold_time must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="threshold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""" ,
            })

        self.__threshold_time = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_threshold_time(self):
        self.__threshold_time = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="threshold-time" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)

    def _get_cooldown_time(self):
        """
    Getter method for cooldown_time, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/cooldown_time (uint32)

    YANG Description: The duration after a scaling-in/scaling-out action has been
triggered, for which there will be no further optional
    """
        return self.__cooldown_time

    def _set_cooldown_time(self , v , load=False):
        """
    Setter method for cooldown_time, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/cooldown_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cooldown_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cooldown_time() directly.

    YANG Description: The duration after a scaling-in/scaling-out action has been
triggered, for which there will be no further optional
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , is_leaf=True , yang_name="cooldown-time" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """cooldown_time must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cooldown-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""" ,
            })

        self.__cooldown_time = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_cooldown_time(self):
        self.__cooldown_time = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="cooldown-time" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)

    def _get_scaling_criteria(self):
        """
    Getter method for scaling_criteria, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria (list)

    YANG Description: list of conditions to be met for generating scaling
  requests
    """
        return self.__scaling_criteria

    def _set_scaling_criteria(self , v , load=False):
        """
    Setter method for scaling_criteria, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy/scaling_criteria (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_criteria is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_criteria() directly.

    YANG Description: list of conditions to be met for generating scaling
  requests
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" ,
                                                   yc_scaling_criteria_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy_scaling_criteria ,
                                                   yang_name="scaling-criteria" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="scaling-criteria" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scaling_criteria must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_scaling_criteria_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy_scaling_criteria, yang_name="scaling-criteria", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-criteria", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__scaling_criteria = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scaling_criteria(self):
        self.__scaling_criteria = YANGDynClass(base=YANGListType("name" ,
                                                                 yc_scaling_criteria_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy_scaling_criteria ,
                                                                 yang_name="scaling-criteria" , parent=self ,
                                                                 is_container='list' , user_ordered=False ,
                                                                 path_helper=self._path_helper , yang_keys='name' ,
                                                                 extensions=None) , is_container='list' ,
                                               yang_name="scaling-criteria" , parent=self ,
                                               path_helper=self._path_helper , extmethods=self._extmethods ,
                                               register_paths=True , extensions=None ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                               defining_module='vnfd' , yang_type='list' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    scaling_type = __builtin__.property(_get_scaling_type , _set_scaling_type)
    enabled = __builtin__.property(_get_enabled , _set_enabled)
    scale_in_operation_type = __builtin__.property(_get_scale_in_operation_type , _set_scale_in_operation_type)
    scale_out_operation_type = __builtin__.property(_get_scale_out_operation_type , _set_scale_out_operation_type)
    threshold_time = __builtin__.property(_get_threshold_time , _set_threshold_time)
    cooldown_time = __builtin__.property(_get_cooldown_time , _set_cooldown_time)
    scaling_criteria = __builtin__.property(_get_scaling_criteria , _set_scaling_criteria)

    _pyangbind_elements = {'name': name , 'scaling_type': scaling_type , 'enabled': enabled ,
                           'scale_in_operation_type': scale_in_operation_type ,
                           'scale_out_operation_type': scale_out_operation_type , 'threshold_time': threshold_time ,
                           'cooldown_time': cooldown_time , 'scaling_criteria': scaling_criteria , }


class yc_vdu_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_vdu(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/scaling-group-descriptor/vdu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VDUs in this scaling group
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__vdu_id_ref' , '__count' ,)

    _yang_name = 'vdu'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            default=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32)(
                1) , is_leaf=True , yang_name="count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)
        self.__vdu_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vdu-id-ref" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , is_keyval=True ,
                                         namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                         yang_type='leafref' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'scaling-group-descriptor' , u'vdu']

    def _get_vdu_id_ref(self):
        """
    Getter method for vdu_id_ref, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/vdu/vdu_id_ref (leafref)

    YANG Description: Reference to the VDU id
    """
        return self.__vdu_id_ref

    def _set_vdu_id_ref(self , v , load=False):
        """
    Setter method for vdu_id_ref, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/vdu/vdu_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_id_ref() directly.

    YANG Description: Reference to the VDU id
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vdu-id-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vdu_id_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vdu-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vdu_id_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vdu_id_ref(self):
        self.__vdu_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vdu-id-ref" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , is_keyval=True ,
                                         namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                         yang_type='leafref' , is_config=True)

    def _get_count(self):
        """
    Getter method for count, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/vdu/count (uint32)

    YANG Description: count of this VDU id within this scaling group.
The count allows to define the number of instances
when a scaling action targets this scaling group
    """
        return self.__count

    def _set_count(self , v , load=False):
        """
    Setter method for count, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/vdu/count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.

    YANG Description: count of this VDU id within this scaling group.
The count allows to define the number of instances
when a scaling action targets this scaling group
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , default=RestrictedClassType(base_type=long ,
                                                                                                 restriction_dict={
                                                                                                     'range': [
                                                                                                         '0..4294967295']} ,
                                                                                                 int_size=32)(1) ,
                             is_leaf=True , yang_name="count" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """count must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""" ,
            })

        self.__count = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_count(self):
        self.__count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            default=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32)(
                1) , is_leaf=True , yang_name="count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)

    vdu_id_ref = __builtin__.property(_get_vdu_id_ref , _set_vdu_id_ref)
    count = __builtin__.property(_get_count , _set_count)

    _pyangbind_elements = {'vdu_id_ref': vdu_id_ref , 'count': count , }


class yc_scaling_config_action_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_config_action(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/scaling-group-descriptor/scaling-config-action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of scaling config actions
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__trigger' , '__vnf_config_primitive_name_ref' ,)

    _yang_name = 'scaling-config-action'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__trigger = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                               restriction_arg={u'pre-scale-out': {'value': 3} ,
                                                                                u'pre-scale-in': {'value': 1} ,
                                                                                u'post-scale-in': {'value': 2} ,
                                                                                u'post-scale-out': {'value': 4}} , ) ,
                                      is_leaf=True , yang_name="trigger" , parent=self , path_helper=self._path_helper ,
                                      extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                      yang_type='manotypes:scaling-trigger' , is_config=True)
        self.__vnf_config_primitive_name_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                            yang_name="vnf-config-primitive-name-ref" , parent=self ,
                                                            path_helper=self._path_helper ,
                                                            extmethods=self._extmethods , register_paths=True ,
                                                            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                            defining_module='vnfd' , yang_type='leafref' ,
                                                            is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'scaling-group-descriptor' , u'scaling-config-action']

    def _get_trigger(self):
        """
    Getter method for trigger, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_config_action/trigger (manotypes:scaling-trigger)

    YANG Description: scaling trigger
    """
        return self.__trigger

    def _set_trigger(self , v , load=False):
        """
    Setter method for trigger, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_config_action/trigger (manotypes:scaling-trigger)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trigger is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trigger() directly.

    YANG Description: scaling trigger
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'pre-scale-out': {'value': 3} ,
                                                                           u'pre-scale-in': {'value': 1} ,
                                                                           u'post-scale-in': {'value': 2} ,
                                                                           u'post-scale-out': {'value': 4}} , ) ,
                             is_leaf=True , yang_name="trigger" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='manotypes:scaling-trigger' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """trigger must be of a type compatible with manotypes:scaling-trigger""" ,
                'defined-type': "manotypes:scaling-trigger" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'pre-scale-out': {'value': 3}, u'pre-scale-in': {'value': 1}, u'post-scale-in': {'value': 2}, u'post-scale-out': {'value': 4}},), is_leaf=True, yang_name="trigger", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='manotypes:scaling-trigger', is_config=True)""" ,
            })

        self.__trigger = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_trigger(self):
        self.__trigger = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                               restriction_arg={u'pre-scale-out': {'value': 3} ,
                                                                                u'pre-scale-in': {'value': 1} ,
                                                                                u'post-scale-in': {'value': 2} ,
                                                                                u'post-scale-out': {'value': 4}} , ) ,
                                      is_leaf=True , yang_name="trigger" , parent=self , path_helper=self._path_helper ,
                                      extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                      yang_type='manotypes:scaling-trigger' , is_config=True)

    def _get_vnf_config_primitive_name_ref(self):
        """
    Getter method for vnf_config_primitive_name_ref, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_config_action/vnf_config_primitive_name_ref (leafref)

    YANG Description: Reference to the VNF config primitive
    """
        return self.__vnf_config_primitive_name_ref

    def _set_vnf_config_primitive_name_ref(self , v , load=False):
        """
    Setter method for vnf_config_primitive_name_ref, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_config_action/vnf_config_primitive_name_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_config_primitive_name_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_config_primitive_name_ref() directly.

    YANG Description: Reference to the VNF config primitive
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnf-config-primitive-name-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnf_config_primitive_name_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnf-config-primitive-name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vnf_config_primitive_name_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnf_config_primitive_name_ref(self):
        self.__vnf_config_primitive_name_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                            yang_name="vnf-config-primitive-name-ref" , parent=self ,
                                                            path_helper=self._path_helper ,
                                                            extmethods=self._extmethods , register_paths=True ,
                                                            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                            defining_module='vnfd' , yang_type='leafref' ,
                                                            is_config=True)

    trigger = __builtin__.property(_get_trigger , _set_trigger)
    vnf_config_primitive_name_ref = __builtin__.property(_get_vnf_config_primitive_name_ref ,
                                                         _set_vnf_config_primitive_name_ref)

    _pyangbind_elements = {'trigger': trigger , 'vnf_config_primitive_name_ref': vnf_config_primitive_name_ref , }


class yc_scaling_group_descriptor_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/scaling-group-descriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: scaling group descriptor within the VNF.
The scaling group defines a group of VDUs,
and the ratio of VDUs in the VNF
that is used as target for scaling action
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__scaling_policy' , '__vdu' , '__min_instance_count' ,
                 '__max_instance_count' , '__scaling_config_action' ,)

    _yang_name = 'scaling-group-descriptor'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vdu = YANGDynClass(
            base=YANGListType("vdu_id_ref" , yc_vdu_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_vdu ,
                              yang_name="vdu" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='vdu-id-ref' , extensions=None) ,
            is_container='list' , yang_name="vdu" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__max_instance_count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            default=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32)(
                10) , is_leaf=True , yang_name="max-instance-count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)
        self.__min_instance_count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            default=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32)(
                0) , is_leaf=True , yang_name="min-instance-count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)
        self.__scaling_policy = YANGDynClass(base=YANGListType("name" ,
                                                               yc_scaling_policy_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy ,
                                                               yang_name="scaling-policy" , parent=self ,
                                                               is_container='list' , user_ordered=False ,
                                                               path_helper=self._path_helper , yang_keys='name' ,
                                                               extensions=None) , is_container='list' ,
                                             yang_name="scaling-policy" , parent=self , path_helper=self._path_helper ,
                                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='list' , is_config=True)
        self.__scaling_config_action = YANGDynClass(base=YANGListType("trigger" ,
                                                                      yc_scaling_config_action_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_config_action ,
                                                                      yang_name="scaling-config-action" , parent=self ,
                                                                      is_container='list' , user_ordered=False ,
                                                                      path_helper=self._path_helper ,
                                                                      yang_keys='trigger' , extensions=None) ,
                                                    is_container='list' , yang_name="scaling-config-action" ,
                                                    parent=self , path_helper=self._path_helper ,
                                                    extmethods=self._extmethods , register_paths=True ,
                                                    extensions=None ,
                                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                    defining_module='vnfd' , yang_type='list' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'scaling-group-descriptor']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/name (string)

    YANG Description: Name of this scaling group.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of this scaling group.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_scaling_policy(self):
        """
    Getter method for scaling_policy, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy (list)
    """
        return self.__scaling_policy

    def _set_scaling_policy(self , v , load=False):
        """
    Setter method for scaling_policy, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_policy (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_policy() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" ,
                                                   yc_scaling_policy_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy ,
                                                   yang_name="scaling-policy" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="scaling-policy" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scaling_policy must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_scaling_policy_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy, yang_name="scaling-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__scaling_policy = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scaling_policy(self):
        self.__scaling_policy = YANGDynClass(base=YANGListType("name" ,
                                                               yc_scaling_policy_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_policy ,
                                                               yang_name="scaling-policy" , parent=self ,
                                                               is_container='list' , user_ordered=False ,
                                                               path_helper=self._path_helper , yang_keys='name' ,
                                                               extensions=None) , is_container='list' ,
                                             yang_name="scaling-policy" , parent=self , path_helper=self._path_helper ,
                                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='list' , is_config=True)

    def _get_vdu(self):
        """
    Getter method for vdu, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/vdu (list)

    YANG Description: List of VDUs in this scaling group
    """
        return self.__vdu

    def _set_vdu(self , v , load=False):
        """
    Setter method for vdu, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/vdu (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu() directly.

    YANG Description: List of VDUs in this scaling group
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("vdu_id_ref" ,
                                                   yc_vdu_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_vdu ,
                                                   yang_name="vdu" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='vdu-id-ref' , extensions=None) , is_container='list' ,
                             yang_name="vdu" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vdu must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("vdu_id_ref",yc_vdu_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_vdu, yang_name="vdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vdu-id-ref', extensions=None), is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__vdu = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vdu(self):
        self.__vdu = YANGDynClass(
            base=YANGListType("vdu_id_ref" , yc_vdu_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_vdu ,
                              yang_name="vdu" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='vdu-id-ref' , extensions=None) ,
            is_container='list' , yang_name="vdu" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    def _get_min_instance_count(self):
        """
    Getter method for min_instance_count, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/min_instance_count (uint32)

    YANG Description: Minimum instances of the scaling group which are allowed.
These instances are created by default when the network service
is instantiated.
    """
        return self.__min_instance_count

    def _set_min_instance_count(self , v , load=False):
        """
    Setter method for min_instance_count, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/min_instance_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_instance_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_instance_count() directly.

    YANG Description: Minimum instances of the scaling group which are allowed.
These instances are created by default when the network service
is instantiated.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , default=RestrictedClassType(base_type=long ,
                                                                                                 restriction_dict={
                                                                                                     'range': [
                                                                                                         '0..4294967295']} ,
                                                                                                 int_size=32)(0) ,
                             is_leaf=True , yang_name="min-instance-count" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """min_instance_count must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="min-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""" ,
            })

        self.__min_instance_count = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_min_instance_count(self):
        self.__min_instance_count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            default=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32)(
                0) , is_leaf=True , yang_name="min-instance-count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)

    def _get_max_instance_count(self):
        """
    Getter method for max_instance_count, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/max_instance_count (uint32)

    YANG Description: Maximum instances of this scaling group that are allowed
in a single network service. The network service scaling
will fail, when the number of service group instances
exceed the max-instance-count specified.
    """
        return self.__max_instance_count

    def _set_max_instance_count(self , v , load=False):
        """
    Setter method for max_instance_count, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/max_instance_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_instance_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_instance_count() directly.

    YANG Description: Maximum instances of this scaling group that are allowed
in a single network service. The network service scaling
will fail, when the number of service group instances
exceed the max-instance-count specified.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , default=RestrictedClassType(base_type=long ,
                                                                                                 restriction_dict={
                                                                                                     'range': [
                                                                                                         '0..4294967295']} ,
                                                                                                 int_size=32)(10) ,
                             is_leaf=True , yang_name="max-instance-count" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """max_instance_count must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="max-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint32', is_config=True)""" ,
            })

        self.__max_instance_count = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_max_instance_count(self):
        self.__max_instance_count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            default=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32)(
                10) , is_leaf=True , yang_name="max-instance-count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint32' , is_config=True)

    def _get_scaling_config_action(self):
        """
    Getter method for scaling_config_action, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_config_action (list)

    YANG Description: List of scaling config actions
    """
        return self.__scaling_config_action

    def _set_scaling_config_action(self , v , load=False):
        """
    Setter method for scaling_config_action, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor/scaling_config_action (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_config_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_config_action() directly.

    YANG Description: List of scaling config actions
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("trigger" ,
                                                   yc_scaling_config_action_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_config_action ,
                                                   yang_name="scaling-config-action" , parent=self ,
                                                   is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='trigger' ,
                                                   extensions=None) , is_container='list' ,
                             yang_name="scaling-config-action" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scaling_config_action must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("trigger",yc_scaling_config_action_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_config_action, yang_name="scaling-config-action", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='trigger', extensions=None), is_container='list', yang_name="scaling-config-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__scaling_config_action = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scaling_config_action(self):
        self.__scaling_config_action = YANGDynClass(base=YANGListType("trigger" ,
                                                                      yc_scaling_config_action_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor_scaling_config_action ,
                                                                      yang_name="scaling-config-action" , parent=self ,
                                                                      is_container='list' , user_ordered=False ,
                                                                      path_helper=self._path_helper ,
                                                                      yang_keys='trigger' , extensions=None) ,
                                                    is_container='list' , yang_name="scaling-config-action" ,
                                                    parent=self , path_helper=self._path_helper ,
                                                    extmethods=self._extmethods , register_paths=True ,
                                                    extensions=None ,
                                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                    defining_module='vnfd' , yang_type='list' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    scaling_policy = __builtin__.property(_get_scaling_policy , _set_scaling_policy)
    vdu = __builtin__.property(_get_vdu , _set_vdu)
    min_instance_count = __builtin__.property(_get_min_instance_count , _set_min_instance_count)
    max_instance_count = __builtin__.property(_get_max_instance_count , _set_max_instance_count)
    scaling_config_action = __builtin__.property(_get_scaling_config_action , _set_scaling_config_action)

    _pyangbind_elements = {'name': name , 'scaling_policy': scaling_policy , 'vdu': vdu ,
                           'min_instance_count': min_instance_count , 'max_instance_count': max_instance_count ,
                           'scaling_config_action': scaling_config_action , }


class yc_vdu_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_monitoring_param(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/monitoring-param/vdu-monitoring-param. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__vdu_ref' , '__vdu_monitoring_param_ref' ,)

    _yang_name = 'vdu-monitoring-param'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vdu_monitoring_param_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                       yang_name="vdu-monitoring-param-ref" , parent=self ,
                                                       choice=(u'monitoring-type' , u'vdu-monitoring-param') ,
                                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                                       register_paths=True ,
                                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                       defining_module='vnfd' , yang_type='leafref' , is_config=True)
        self.__vdu_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vdu-ref" , parent=self ,
                                      choice=(u'monitoring-type' , u'vdu-monitoring-param') ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                      defining_module='vnfd' , yang_type='leafref' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'monitoring-param' , u'vdu-monitoring-param']

    def _get_vdu_ref(self):
        """
    Getter method for vdu_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_monitoring_param/vdu_ref (leafref)
    """
        return self.__vdu_ref

    def _set_vdu_ref(self , v , load=False):
        """
    Setter method for vdu_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_monitoring_param/vdu_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_ref() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vdu-ref" , parent=self ,
                             choice=(u'monitoring-type' , u'vdu-monitoring-param') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vdu_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vdu-ref", parent=self, choice=(u'monitoring-type', u'vdu-monitoring-param'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vdu_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vdu_ref(self):
        self.__vdu_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vdu-ref" , parent=self ,
                                      choice=(u'monitoring-type' , u'vdu-monitoring-param') ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                      defining_module='vnfd' , yang_type='leafref' , is_config=True)

    def _get_vdu_monitoring_param_ref(self):
        """
    Getter method for vdu_monitoring_param_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_monitoring_param/vdu_monitoring_param_ref (leafref)
    """
        return self.__vdu_monitoring_param_ref

    def _set_vdu_monitoring_param_ref(self , v , load=False):
        """
    Setter method for vdu_monitoring_param_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_monitoring_param/vdu_monitoring_param_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_monitoring_param_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_monitoring_param_ref() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vdu-monitoring-param-ref" , parent=self ,
                             choice=(u'monitoring-type' , u'vdu-monitoring-param') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vdu_monitoring_param_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vdu-monitoring-param-ref", parent=self, choice=(u'monitoring-type', u'vdu-monitoring-param'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vdu_monitoring_param_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vdu_monitoring_param_ref(self):
        self.__vdu_monitoring_param_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                       yang_name="vdu-monitoring-param-ref" , parent=self ,
                                                       choice=(u'monitoring-type' , u'vdu-monitoring-param') ,
                                                       path_helper=self._path_helper , extmethods=self._extmethods ,
                                                       register_paths=True ,
                                                       namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                       defining_module='vnfd' , yang_type='leafref' , is_config=True)

    vdu_ref = __builtin__.property(_get_vdu_ref , _set_vdu_ref)
    vdu_monitoring_param_ref = __builtin__.property(_get_vdu_monitoring_param_ref , _set_vdu_monitoring_param_ref)

    __choices__ = {u'monitoring-type': {u'vdu-monitoring-param': [u'vdu_ref' , u'vdu_monitoring_param_ref']}}
    _pyangbind_elements = {'vdu_ref': vdu_ref , 'vdu_monitoring_param_ref': vdu_monitoring_param_ref , }


class yc_vnf_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vnf_metric(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/monitoring-param/vnf-metric. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__vnf_metric_name_ref' ,)

    _yang_name = 'vnf-metric'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnf_metric_name_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnf-metric-name-ref" ,
                                                  parent=self , choice=(u'monitoring-type' , u'vnf-metric') ,
                                                  path_helper=self._path_helper , extmethods=self._extmethods ,
                                                  register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                  defining_module='vnfd' , yang_type='leafref' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'monitoring-param' , u'vnf-metric']

    def _get_vnf_metric_name_ref(self):
        """
    Getter method for vnf_metric_name_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vnf_metric/vnf_metric_name_ref (leafref)
    """
        return self.__vnf_metric_name_ref

    def _set_vnf_metric_name_ref(self , v , load=False):
        """
    Setter method for vnf_metric_name_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vnf_metric/vnf_metric_name_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_metric_name_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_metric_name_ref() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnf-metric-name-ref" , parent=self ,
                             choice=(u'monitoring-type' , u'vnf-metric') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnf_metric_name_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnf-metric-name-ref", parent=self, choice=(u'monitoring-type', u'vnf-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vnf_metric_name_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnf_metric_name_ref(self):
        self.__vnf_metric_name_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnf-metric-name-ref" ,
                                                  parent=self , choice=(u'monitoring-type' , u'vnf-metric') ,
                                                  path_helper=self._path_helper , extmethods=self._extmethods ,
                                                  register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                  defining_module='vnfd' , yang_type='leafref' , is_config=True)

    vnf_metric_name_ref = __builtin__.property(_get_vnf_metric_name_ref , _set_vnf_metric_name_ref)

    __choices__ = {u'monitoring-type': {u'vnf-metric': [u'vnf_metric_name_ref']}}
    _pyangbind_elements = {'vnf_metric_name_ref': vnf_metric_name_ref , }


class yc_vdu_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_metric(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/monitoring-param/vdu-metric. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__vdu_ref' , '__vdu_metric_name_ref' ,)

    _yang_name = 'vdu-metric'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vdu_metric_name_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vdu-metric-name-ref" ,
                                                  parent=self , choice=(u'monitoring-type' , u'vdu-metric') ,
                                                  path_helper=self._path_helper , extmethods=self._extmethods ,
                                                  register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                  defining_module='vnfd' , yang_type='leafref' , is_config=True)
        self.__vdu_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vdu-ref" , parent=self ,
                                      choice=(u'monitoring-type' , u'vdu-metric') , path_helper=self._path_helper ,
                                      extmethods=self._extmethods , register_paths=True ,
                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                      yang_type='leafref' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'monitoring-param' , u'vdu-metric']

    def _get_vdu_ref(self):
        """
    Getter method for vdu_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_metric/vdu_ref (leafref)
    """
        return self.__vdu_ref

    def _set_vdu_ref(self , v , load=False):
        """
    Setter method for vdu_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_metric/vdu_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_ref() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vdu-ref" , parent=self ,
                             choice=(u'monitoring-type' , u'vdu-metric') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vdu_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vdu-ref", parent=self, choice=(u'monitoring-type', u'vdu-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vdu_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vdu_ref(self):
        self.__vdu_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vdu-ref" , parent=self ,
                                      choice=(u'monitoring-type' , u'vdu-metric') , path_helper=self._path_helper ,
                                      extmethods=self._extmethods , register_paths=True ,
                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                      yang_type='leafref' , is_config=True)

    def _get_vdu_metric_name_ref(self):
        """
    Getter method for vdu_metric_name_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_metric/vdu_metric_name_ref (leafref)
    """
        return self.__vdu_metric_name_ref

    def _set_vdu_metric_name_ref(self , v , load=False):
        """
    Setter method for vdu_metric_name_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_metric/vdu_metric_name_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_metric_name_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_metric_name_ref() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vdu-metric-name-ref" , parent=self ,
                             choice=(u'monitoring-type' , u'vdu-metric') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vdu_metric_name_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vdu-metric-name-ref", parent=self, choice=(u'monitoring-type', u'vdu-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vdu_metric_name_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vdu_metric_name_ref(self):
        self.__vdu_metric_name_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vdu-metric-name-ref" ,
                                                  parent=self , choice=(u'monitoring-type' , u'vdu-metric') ,
                                                  path_helper=self._path_helper , extmethods=self._extmethods ,
                                                  register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                  defining_module='vnfd' , yang_type='leafref' , is_config=True)

    vdu_ref = __builtin__.property(_get_vdu_ref , _set_vdu_ref)
    vdu_metric_name_ref = __builtin__.property(_get_vdu_metric_name_ref , _set_vdu_metric_name_ref)

    __choices__ = {u'monitoring-type': {u'vdu-metric': [u'vdu_ref' , u'vdu_metric_name_ref']}}
    _pyangbind_elements = {'vdu_ref': vdu_ref , 'vdu_metric_name_ref': vdu_metric_name_ref , }


class yc_json_query_params_vnfd__vnfd_catalog_vnfd_monitoring_param_json_query_params(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/monitoring-param/json-query-params. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__json_path' , '__object_path' ,)

    _yang_name = 'json-query-params'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__json_path = YANGDynClass(base=unicode , is_leaf=True , yang_name="json-path" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                        defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__object_path = YANGDynClass(base=unicode , is_leaf=True , yang_name="object-path" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'monitoring-param' , u'json-query-params']

    def _get_json_path(self):
        """
    Getter method for json_path, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/json_query_params/json_path (string)

    YANG Description: The jsonpath to use to extract value from JSON structure
    """
        return self.__json_path

    def _set_json_path(self , v , load=False):
        """
    Setter method for json_path, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/json_query_params/json_path (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_json_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_json_path() directly.

    YANG Description: The jsonpath to use to extract value from JSON structure
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="json-path" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """json_path must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="json-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__json_path = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_json_path(self):
        self.__json_path = YANGDynClass(base=unicode , is_leaf=True , yang_name="json-path" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                        defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_object_path(self):
        """
    Getter method for object_path, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/json_query_params/object_path (string)

    YANG Description: The objectpath to use to extract value from JSON structure
    """
        return self.__object_path

    def _set_object_path(self , v , load=False):
        """
    Setter method for object_path, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/json_query_params/object_path (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_object_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_object_path() directly.

    YANG Description: The objectpath to use to extract value from JSON structure
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="object-path" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """object_path must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="object-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__object_path = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_object_path(self):
        self.__object_path = YANGDynClass(base=unicode , is_leaf=True , yang_name="object-path" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)

    json_path = __builtin__.property(_get_json_path , _set_json_path)
    object_path = __builtin__.property(_get_object_path , _set_object_path)

    _pyangbind_elements = {'json_path': json_path , 'object_path': object_path , }


class yc_numeric_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_numeric_constraints(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/monitoring-param/numeric-constraints. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__min_value' , '__max_value' ,)

    _yang_name = 'numeric-constraints'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__max_value = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="max-value" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)
        self.__min_value = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="min-value" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'monitoring-param' , u'numeric-constraints']

    def _get_min_value(self):
        """
    Getter method for min_value, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/numeric_constraints/min_value (uint64)

    YANG Description: Minimum value for the parameter
    """
        return self.__min_value

    def _set_min_value(self , v , load=False):
        """
    Setter method for min_value, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/numeric_constraints/min_value (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_value() directly.

    YANG Description: Minimum value for the parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="min-value" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """min_value must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__min_value = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_min_value(self):
        self.__min_value = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="min-value" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

    def _get_max_value(self):
        """
    Getter method for max_value, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/numeric_constraints/max_value (uint64)

    YANG Description: Maximum value for the parameter
    """
        return self.__max_value

    def _set_max_value(self , v , load=False):
        """
    Setter method for max_value, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/numeric_constraints/max_value (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_value() directly.

    YANG Description: Maximum value for the parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="max-value" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """max_value must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint64', is_config=True)""" ,
            })

        self.__max_value = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_max_value(self):
        self.__max_value = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="max-value" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='uint64' ,
            is_config=True)

    min_value = __builtin__.property(_get_min_value , _set_min_value)
    max_value = __builtin__.property(_get_max_value , _set_max_value)

    _pyangbind_elements = {'min_value': min_value , 'max_value': max_value , }


class yc_text_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_text_constraints(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/monitoring-param/text-constraints. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__min_length' , '__max_length' ,)

    _yang_name = 'text-constraints'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__min_length = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="min-length" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint8' , is_config=True)
        self.__max_length = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="max-length" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint8' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'monitoring-param' , u'text-constraints']

    def _get_min_length(self):
        """
    Getter method for min_length, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/text_constraints/min_length (uint8)

    YANG Description: Minimum string length for the parameter
    """
        return self.__min_length

    def _set_min_length(self , v , load=False):
        """
    Setter method for min_length, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/text_constraints/min_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_length() directly.

    YANG Description: Minimum string length for the parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} ,
                                                          int_size=8) , is_leaf=True , yang_name="min-length" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint8' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """min_length must be of a type compatible with uint8""" ,
                'defined-type': "uint8" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="min-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)""" ,
            })

        self.__min_length = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_min_length(self):
        self.__min_length = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="min-length" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint8' , is_config=True)

    def _get_max_length(self):
        """
    Getter method for max_length, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/text_constraints/max_length (uint8)

    YANG Description: Maximum string length for the parameter
    """
        return self.__max_length

    def _set_max_length(self , v , load=False):
        """
    Setter method for max_length, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/text_constraints/max_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_length() directly.

    YANG Description: Maximum string length for the parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} ,
                                                          int_size=8) , is_leaf=True , yang_name="max-length" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='uint8' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """max_length must be of a type compatible with uint8""" ,
                'defined-type': "uint8" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='uint8', is_config=True)""" ,
            })

        self.__max_length = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_max_length(self):
        self.__max_length = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="max-length" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='uint8' , is_config=True)

    min_length = __builtin__.property(_get_min_length , _set_min_length)
    max_length = __builtin__.property(_get_max_length , _set_max_length)

    _pyangbind_elements = {'min_length': min_length , 'max_length': max_length , }


class yc_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/monitoring-param. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of monitoring parameters at the network service level
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__id' , '__name' , '__aggregation_type' , '__vdu_monitoring_param' ,
                 '__vnf_metric' , '__vdu_metric' , '__http_endpoint_ref' , '__json_query_method' ,
                 '__json_query_params' , '__description' , '__group_tag' , '__widget_type' , '__units' ,
                 '__value_type' , '__numeric_constraints' , '__text_constraints' , '__value_integer' ,
                 '__value_decimal' , '__value_string' ,)

    _yang_name = 'monitoring-param'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__value_integer = YANGDynClass(base=RestrictedClassType(base_type=long , restriction_dict={
            'range': ['-9223372036854775808..9223372036854775807']} , int_size=64) , is_leaf=True ,
                                            yang_name="value-integer" , parent=self , path_helper=self._path_helper ,
                                            extmethods=self._extmethods , register_paths=True ,
                                            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                            yang_type='int64' , is_config=True)
        self.__vdu_monitoring_param = YANGDynClass(
            base=yc_vdu_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_monitoring_param ,
            is_container='container' , yang_name="vdu-monitoring-param" , parent=self ,
            choice=(u'monitoring-type' , u'vdu-monitoring-param') , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)
        self.__aggregation_type = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'COUNT': {} , u'AVERAGE': {} , u'MINIMUM': {} , u'SUM': {} ,
                                                      u'MAXIMUM': {}} , ) , is_leaf=True ,
            yang_name="aggregation-type" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='aggregation-type' , is_config=True)
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__text_constraints = YANGDynClass(
            base=yc_text_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_text_constraints ,
            is_container='container' , yang_name="text-constraints" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)
        self.__group_tag = YANGDynClass(base=unicode , is_leaf=True , yang_name="group-tag" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                        defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__value_string = YANGDynClass(base=unicode , is_leaf=True , yang_name="value-string" , parent=self ,
                                           path_helper=self._path_helper , extmethods=self._extmethods ,
                                           register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                           defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__widget_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                   restriction_arg={u'BAR': {} , u'COUNTER': {} ,
                                                                                    u'HISTOGRAM': {} , u'SLIDER': {} ,
                                                                                    u'GAUGE': {} , u'TEXTBOX': {}} , ) ,
                                          default=unicode("COUNTER") , is_leaf=True , yang_name="widget-type" ,
                                          parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='manotypes:widget-type' , is_config=True)
        self.__units = YANGDynClass(base=unicode , is_leaf=True , yang_name="units" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)
        self.__http_endpoint_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="http-endpoint-ref" ,
                                                parent=self , path_helper=self._path_helper ,
                                                extmethods=self._extmethods , register_paths=True ,
                                                namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                defining_module='vnfd' , yang_type='leafref' , is_config=True)
        self.__vdu_metric = YANGDynClass(base=yc_vdu_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_metric ,
                                         is_container='container' , yang_name="vdu-metric" , parent=self ,
                                         choice=(u'monitoring-type' , u'vdu-metric') , path_helper=self._path_helper ,
                                         extmethods=self._extmethods , register_paths=True , extensions=None ,
                                         namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                         yang_type='container' , is_config=True)
        self.__json_query_params = YANGDynClass(
            base=yc_json_query_params_vnfd__vnfd_catalog_vnfd_monitoring_param_json_query_params ,
            is_container='container' , yang_name="json-query-params" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)
        self.__value_decimal = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4) , is_leaf=True ,
                                            yang_name="value-decimal" , parent=self , path_helper=self._path_helper ,
                                            extmethods=self._extmethods , register_paths=True ,
                                            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                            yang_type='decimal64' , is_config=True)
        self.__vnf_metric = YANGDynClass(base=yc_vnf_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vnf_metric ,
                                         is_container='container' , yang_name="vnf-metric" , parent=self ,
                                         choice=(u'monitoring-type' , u'vnf-metric') , path_helper=self._path_helper ,
                                         extmethods=self._extmethods , register_paths=True , extensions=None ,
                                         namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                         yang_type='container' , is_config=True)
        self.__json_query_method = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'NAMEKEY': {} , u'OBJECTPATH': {} , u'JSONPATH': {}} , ) ,
            default=unicode("NAMEKEY") , is_leaf=True , yang_name="json-query-method" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='manotypes:json-query-method' , is_config=True)
        self.__value_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                  restriction_arg={u'INT': {} , u'DECIMAL': {} ,
                                                                                   u'STRING': {}} , ) ,
                                         default=unicode("INT") , is_leaf=True , yang_name="value-type" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='param-value-type' , is_config=True)
        self.__numeric_constraints = YANGDynClass(
            base=yc_numeric_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_numeric_constraints ,
            is_container='container' , yang_name="numeric-constraints" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                 defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'monitoring-param']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/id (string)
    """
        return self.__id

    def _set_id(self , v , load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                 defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/name (string)
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)

    def _get_aggregation_type(self):
        """
    Getter method for aggregation_type, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/aggregation_type (aggregation-type)
    """
        return self.__aggregation_type

    def _set_aggregation_type(self , v , load=False):
        """
    Setter method for aggregation_type, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/aggregation_type (aggregation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggregation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggregation_type() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'COUNT': {} , u'AVERAGE': {} ,
                                                                           u'MINIMUM': {} , u'SUM': {} ,
                                                                           u'MAXIMUM': {}} , ) , is_leaf=True ,
                             yang_name="aggregation-type" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='aggregation-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """aggregation_type must be of a type compatible with aggregation-type""" ,
                'defined-type': "vnfd:aggregation-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'COUNT': {}, u'AVERAGE': {}, u'MINIMUM': {}, u'SUM': {}, u'MAXIMUM': {}},), is_leaf=True, yang_name="aggregation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='aggregation-type', is_config=True)""" ,
            })

        self.__aggregation_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_aggregation_type(self):
        self.__aggregation_type = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'COUNT': {} , u'AVERAGE': {} , u'MINIMUM': {} , u'SUM': {} ,
                                                      u'MAXIMUM': {}} , ) , is_leaf=True ,
            yang_name="aggregation-type" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='aggregation-type' , is_config=True)

    def _get_vdu_monitoring_param(self):
        """
    Getter method for vdu_monitoring_param, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_monitoring_param (container)
    """
        return self.__vdu_monitoring_param

    def _set_vdu_monitoring_param(self , v , load=False):
        """
    Setter method for vdu_monitoring_param, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_monitoring_param (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_monitoring_param is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_monitoring_param() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=yc_vdu_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_monitoring_param ,
                             is_container='container' , yang_name="vdu-monitoring-param" , parent=self ,
                             choice=(u'monitoring-type' , u'vdu-monitoring-param') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vdu_monitoring_param must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_vdu_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_monitoring_param, is_container='container', yang_name="vdu-monitoring-param", parent=self, choice=(u'monitoring-type', u'vdu-monitoring-param'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__vdu_monitoring_param = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vdu_monitoring_param(self):
        self.__vdu_monitoring_param = YANGDynClass(
            base=yc_vdu_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_monitoring_param ,
            is_container='container' , yang_name="vdu-monitoring-param" , parent=self ,
            choice=(u'monitoring-type' , u'vdu-monitoring-param') , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)

    def _get_vnf_metric(self):
        """
    Getter method for vnf_metric, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vnf_metric (container)
    """
        return self.__vnf_metric

    def _set_vnf_metric(self , v , load=False):
        """
    Setter method for vnf_metric, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vnf_metric (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_metric() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_vnf_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vnf_metric ,
                             is_container='container' , yang_name="vnf-metric" , parent=self ,
                             choice=(u'monitoring-type' , u'vnf-metric') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnf_metric must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_vnf_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vnf_metric, is_container='container', yang_name="vnf-metric", parent=self, choice=(u'monitoring-type', u'vnf-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__vnf_metric = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnf_metric(self):
        self.__vnf_metric = YANGDynClass(base=yc_vnf_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vnf_metric ,
                                         is_container='container' , yang_name="vnf-metric" , parent=self ,
                                         choice=(u'monitoring-type' , u'vnf-metric') , path_helper=self._path_helper ,
                                         extmethods=self._extmethods , register_paths=True , extensions=None ,
                                         namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                         yang_type='container' , is_config=True)

    def _get_vdu_metric(self):
        """
    Getter method for vdu_metric, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_metric (container)
    """
        return self.__vdu_metric

    def _set_vdu_metric(self , v , load=False):
        """
    Setter method for vdu_metric, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/vdu_metric (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_metric() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_vdu_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_metric ,
                             is_container='container' , yang_name="vdu-metric" , parent=self ,
                             choice=(u'monitoring-type' , u'vdu-metric') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vdu_metric must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_vdu_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_metric, is_container='container', yang_name="vdu-metric", parent=self, choice=(u'monitoring-type', u'vdu-metric'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__vdu_metric = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vdu_metric(self):
        self.__vdu_metric = YANGDynClass(base=yc_vdu_metric_vnfd__vnfd_catalog_vnfd_monitoring_param_vdu_metric ,
                                         is_container='container' , yang_name="vdu-metric" , parent=self ,
                                         choice=(u'monitoring-type' , u'vdu-metric') , path_helper=self._path_helper ,
                                         extmethods=self._extmethods , register_paths=True , extensions=None ,
                                         namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                         yang_type='container' , is_config=True)

    def _get_http_endpoint_ref(self):
        """
    Getter method for http_endpoint_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/http_endpoint_ref (leafref)
    """
        return self.__http_endpoint_ref

    def _set_http_endpoint_ref(self , v , load=False):
        """
    Setter method for http_endpoint_ref, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/http_endpoint_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_http_endpoint_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_http_endpoint_ref() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="http-endpoint-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """http_endpoint_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="http-endpoint-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__http_endpoint_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_http_endpoint_ref(self):
        self.__http_endpoint_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="http-endpoint-ref" ,
                                                parent=self , path_helper=self._path_helper ,
                                                extmethods=self._extmethods , register_paths=True ,
                                                namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                defining_module='vnfd' , yang_type='leafref' , is_config=True)

    def _get_json_query_method(self):
        """
    Getter method for json_query_method, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/json_query_method (manotypes:json-query-method)
    """
        return self.__json_query_method

    def _set_json_query_method(self , v , load=False):
        """
    Setter method for json_query_method, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/json_query_method (manotypes:json-query-method)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_json_query_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_json_query_method() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'NAMEKEY': {} , u'OBJECTPATH': {} ,
                                                                           u'JSONPATH': {}} , ) ,
                             default=unicode("NAMEKEY") , is_leaf=True , yang_name="json-query-method" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='manotypes:json-query-method' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """json_query_method must be of a type compatible with manotypes:json-query-method""" ,
                'defined-type': "manotypes:json-query-method" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'NAMEKEY': {}, u'OBJECTPATH': {}, u'JSONPATH': {}},), default=unicode("NAMEKEY"), is_leaf=True, yang_name="json-query-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='manotypes:json-query-method', is_config=True)""" ,
            })

        self.__json_query_method = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_json_query_method(self):
        self.__json_query_method = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'NAMEKEY': {} , u'OBJECTPATH': {} , u'JSONPATH': {}} , ) ,
            default=unicode("NAMEKEY") , is_leaf=True , yang_name="json-query-method" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='manotypes:json-query-method' , is_config=True)

    def _get_json_query_params(self):
        """
    Getter method for json_query_params, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/json_query_params (container)
    """
        return self.__json_query_params

    def _set_json_query_params(self , v , load=False):
        """
    Setter method for json_query_params, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/json_query_params (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_json_query_params is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_json_query_params() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_json_query_params_vnfd__vnfd_catalog_vnfd_monitoring_param_json_query_params ,
                             is_container='container' , yang_name="json-query-params" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """json_query_params must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_json_query_params_vnfd__vnfd_catalog_vnfd_monitoring_param_json_query_params, is_container='container', yang_name="json-query-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__json_query_params = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_json_query_params(self):
        self.__json_query_params = YANGDynClass(
            base=yc_json_query_params_vnfd__vnfd_catalog_vnfd_monitoring_param_json_query_params ,
            is_container='container' , yang_name="json-query-params" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/description (string)
    """
        return self.__description

    def _set_description(self , v , load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__description = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_group_tag(self):
        """
    Getter method for group_tag, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/group_tag (string)

    YANG Description: A tag to group monitoring parameters
    """
        return self.__group_tag

    def _set_group_tag(self , v , load=False):
        """
    Setter method for group_tag, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/group_tag (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_tag() directly.

    YANG Description: A tag to group monitoring parameters
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="group-tag" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """group_tag must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="group-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__group_tag = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_group_tag(self):
        self.__group_tag = YANGDynClass(base=unicode , is_leaf=True , yang_name="group-tag" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                        defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_widget_type(self):
        """
    Getter method for widget_type, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/widget_type (manotypes:widget-type)

    YANG Description: Defines the UI Display variant of measured counters.
    """
        return self.__widget_type

    def _set_widget_type(self , v , load=False):
        """
    Setter method for widget_type, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/widget_type (manotypes:widget-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_widget_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_widget_type() directly.

    YANG Description: Defines the UI Display variant of measured counters.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'BAR': {} , u'COUNTER': {} ,
                                                                           u'HISTOGRAM': {} , u'SLIDER': {} ,
                                                                           u'GAUGE': {} , u'TEXTBOX': {}} , ) ,
                             default=unicode("COUNTER") , is_leaf=True , yang_name="widget-type" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='manotypes:widget-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """widget_type must be of a type compatible with manotypes:widget-type""" ,
                'defined-type': "manotypes:widget-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'BAR': {}, u'COUNTER': {}, u'HISTOGRAM': {}, u'SLIDER': {}, u'GAUGE': {}, u'TEXTBOX': {}},), default=unicode("COUNTER"), is_leaf=True, yang_name="widget-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='manotypes:widget-type', is_config=True)""" ,
            })

        self.__widget_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_widget_type(self):
        self.__widget_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                   restriction_arg={u'BAR': {} , u'COUNTER': {} ,
                                                                                    u'HISTOGRAM': {} , u'SLIDER': {} ,
                                                                                    u'GAUGE': {} , u'TEXTBOX': {}} , ) ,
                                          default=unicode("COUNTER") , is_leaf=True , yang_name="widget-type" ,
                                          parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='manotypes:widget-type' , is_config=True)

    def _get_units(self):
        """
    Getter method for units, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/units (string)

    YANG Description: Measured Counter Units (e.g., Packets, Kbps, Mbps, etc.)
    """
        return self.__units

    def _set_units(self , v , load=False):
        """
    Setter method for units, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/units (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_units is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_units() directly.

    YANG Description: Measured Counter Units (e.g., Packets, Kbps, Mbps, etc.)
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="units" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """units must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="units", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__units = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_units(self):
        self.__units = YANGDynClass(base=unicode , is_leaf=True , yang_name="units" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                    yang_type='string' , is_config=True)

    def _get_value_type(self):
        """
    Getter method for value_type, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/value_type (param-value-type)
    """
        return self.__value_type

    def _set_value_type(self , v , load=False):
        """
    Setter method for value_type, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/value_type (param-value-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value_type() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'INT': {} , u'DECIMAL': {} ,
                                                                           u'STRING': {}} , ) , default=unicode("INT") ,
                             is_leaf=True , yang_name="value-type" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='param-value-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """value_type must be of a type compatible with param-value-type""" ,
                'defined-type': "vnfd:param-value-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'INT': {}, u'DECIMAL': {}, u'STRING': {}},), default=unicode("INT"), is_leaf=True, yang_name="value-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='param-value-type', is_config=True)""" ,
            })

        self.__value_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_value_type(self):
        self.__value_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                  restriction_arg={u'INT': {} , u'DECIMAL': {} ,
                                                                                   u'STRING': {}} , ) ,
                                         default=unicode("INT") , is_leaf=True , yang_name="value-type" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='param-value-type' , is_config=True)

    def _get_numeric_constraints(self):
        """
    Getter method for numeric_constraints, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/numeric_constraints (container)
    """
        return self.__numeric_constraints

    def _set_numeric_constraints(self , v , load=False):
        """
    Setter method for numeric_constraints, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/numeric_constraints (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numeric_constraints is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numeric_constraints() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=yc_numeric_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_numeric_constraints ,
                             is_container='container' , yang_name="numeric-constraints" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """numeric_constraints must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_numeric_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_numeric_constraints, is_container='container', yang_name="numeric-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__numeric_constraints = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_numeric_constraints(self):
        self.__numeric_constraints = YANGDynClass(
            base=yc_numeric_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_numeric_constraints ,
            is_container='container' , yang_name="numeric-constraints" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)

    def _get_text_constraints(self):
        """
    Getter method for text_constraints, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/text_constraints (container)
    """
        return self.__text_constraints

    def _set_text_constraints(self , v , load=False):
        """
    Setter method for text_constraints, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/text_constraints (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_text_constraints is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_text_constraints() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_text_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_text_constraints ,
                             is_container='container' , yang_name="text-constraints" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """text_constraints must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_text_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_text_constraints, is_container='container', yang_name="text-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__text_constraints = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_text_constraints(self):
        self.__text_constraints = YANGDynClass(
            base=yc_text_constraints_vnfd__vnfd_catalog_vnfd_monitoring_param_text_constraints ,
            is_container='container' , yang_name="text-constraints" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='container' ,
            is_config=True)

    def _get_value_integer(self):
        """
    Getter method for value_integer, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/value_integer (int64)

    YANG Description: Current value for an integer parameter
    """
        return self.__value_integer

    def _set_value_integer(self , v , load=False):
        """
    Setter method for value_integer, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/value_integer (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value_integer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value_integer() directly.

    YANG Description: Current value for an integer parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long , restriction_dict={
                'range': ['-9223372036854775808..9223372036854775807']} , int_size=64) , is_leaf=True ,
                             yang_name="value-integer" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='int64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """value_integer must be of a type compatible with int64""" ,
                'defined-type': "int64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="value-integer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='int64', is_config=True)""" ,
            })

        self.__value_integer = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_value_integer(self):
        self.__value_integer = YANGDynClass(base=RestrictedClassType(base_type=long , restriction_dict={
            'range': ['-9223372036854775808..9223372036854775807']} , int_size=64) , is_leaf=True ,
                                            yang_name="value-integer" , parent=self , path_helper=self._path_helper ,
                                            extmethods=self._extmethods , register_paths=True ,
                                            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                            yang_type='int64' , is_config=True)

    def _get_value_decimal(self):
        """
    Getter method for value_decimal, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/value_decimal (decimal64)

    YANG Description: Current value for a decimal parameter
    """
        return self.__value_decimal

    def _set_value_decimal(self , v , load=False):
        """
    Setter method for value_decimal, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/value_decimal (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value_decimal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value_decimal() directly.

    YANG Description: Current value for a decimal parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedPrecisionDecimalType(precision=4) , is_leaf=True ,
                             yang_name="value-decimal" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='decimal64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """value_decimal must be of a type compatible with decimal64""" ,
                'defined-type': "decimal64" ,
                'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value-decimal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='decimal64', is_config=True)""" ,
            })

        self.__value_decimal = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_value_decimal(self):
        self.__value_decimal = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4) , is_leaf=True ,
                                            yang_name="value-decimal" , parent=self , path_helper=self._path_helper ,
                                            extmethods=self._extmethods , register_paths=True ,
                                            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                            yang_type='decimal64' , is_config=True)

    def _get_value_string(self):
        """
    Getter method for value_string, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/value_string (string)

    YANG Description: Current value for a string parameter
    """
        return self.__value_string

    def _set_value_string(self , v , load=False):
        """
    Setter method for value_string, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param/value_string (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value_string is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value_string() directly.

    YANG Description: Current value for a string parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="value-string" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """value_string must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="value-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__value_string = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_value_string(self):
        self.__value_string = YANGDynClass(base=unicode , is_leaf=True , yang_name="value-string" , parent=self ,
                                           path_helper=self._path_helper , extmethods=self._extmethods ,
                                           register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                           defining_module='vnfd' , yang_type='string' , is_config=True)

    id = __builtin__.property(_get_id , _set_id)
    name = __builtin__.property(_get_name , _set_name)
    aggregation_type = __builtin__.property(_get_aggregation_type , _set_aggregation_type)
    vdu_monitoring_param = __builtin__.property(_get_vdu_monitoring_param , _set_vdu_monitoring_param)
    vnf_metric = __builtin__.property(_get_vnf_metric , _set_vnf_metric)
    vdu_metric = __builtin__.property(_get_vdu_metric , _set_vdu_metric)
    http_endpoint_ref = __builtin__.property(_get_http_endpoint_ref , _set_http_endpoint_ref)
    json_query_method = __builtin__.property(_get_json_query_method , _set_json_query_method)
    json_query_params = __builtin__.property(_get_json_query_params , _set_json_query_params)
    description = __builtin__.property(_get_description , _set_description)
    group_tag = __builtin__.property(_get_group_tag , _set_group_tag)
    widget_type = __builtin__.property(_get_widget_type , _set_widget_type)
    units = __builtin__.property(_get_units , _set_units)
    value_type = __builtin__.property(_get_value_type , _set_value_type)
    numeric_constraints = __builtin__.property(_get_numeric_constraints , _set_numeric_constraints)
    text_constraints = __builtin__.property(_get_text_constraints , _set_text_constraints)
    value_integer = __builtin__.property(_get_value_integer , _set_value_integer)
    value_decimal = __builtin__.property(_get_value_decimal , _set_value_decimal)
    value_string = __builtin__.property(_get_value_string , _set_value_string)

    __choices__ = {
        u'monitoring-type': {u'vdu-monitoring-param': [u'vdu_monitoring_param'] , u'vnf-metric': [u'vnf_metric'] ,
                             u'vdu-metric': [u'vdu_metric']}}
    _pyangbind_elements = {'id': id , 'name': name , 'aggregation_type': aggregation_type ,
                           'vdu_monitoring_param': vdu_monitoring_param , 'vnf_metric': vnf_metric ,
                           'vdu_metric': vdu_metric , 'http_endpoint_ref': http_endpoint_ref ,
                           'json_query_method': json_query_method , 'json_query_params': json_query_params ,
                           'description': description , 'group_tag': group_tag , 'widget_type': widget_type ,
                           'units': units , 'value_type': value_type , 'numeric_constraints': numeric_constraints ,
                           'text_constraints': text_constraints , 'value_integer': value_integer ,
                           'value_decimal': value_decimal , 'value_string': value_string , }


class yc_member_vdus_vnfd__vnfd_catalog_vnfd_placement_groups_member_vdus(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/placement-groups/member-vdus. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VDUs that are part of this placement group
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__member_vdu_ref' ,)

    _yang_name = 'member-vdus'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__member_vdu_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vdu-ref" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , is_keyval=True ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='leafref' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'placement-groups' , u'member-vdus']

    def _get_member_vdu_ref(self):
        """
    Getter method for member_vdu_ref, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/member_vdus/member_vdu_ref (leafref)
    """
        return self.__member_vdu_ref

    def _set_member_vdu_ref(self , v , load=False):
        """
    Setter method for member_vdu_ref, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/member_vdus/member_vdu_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vdu_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vdu_ref() directly.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="member-vdu-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """member_vdu_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="member-vdu-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='leafref', is_config=True)""" ,
            })

        self.__member_vdu_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_member_vdu_ref(self):
        self.__member_vdu_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vdu-ref" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , is_keyval=True ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='leafref' , is_config=True)

    member_vdu_ref = __builtin__.property(_get_member_vdu_ref , _set_member_vdu_ref)

    _pyangbind_elements = {'member_vdu_ref': member_vdu_ref , }


class yc_placement_groups_vnfd__vnfd_catalog_vnfd_placement_groups(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd/placement-groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of placement groups at VNF level
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__requirement' , '__strategy' , '__member_vdus' ,)

    _yang_name = 'placement-groups'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__member_vdus = YANGDynClass(
            base=YANGListType("member_vdu_ref" , yc_member_vdus_vnfd__vnfd_catalog_vnfd_placement_groups_member_vdus ,
                              yang_name="member-vdus" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='member-vdu-ref' , extensions=None) ,
            is_container='list' , yang_name="member-vdus" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__requirement = YANGDynClass(base=unicode , is_leaf=True , yang_name="requirement" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__strategy = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                restriction_arg={u'COLOCATION': {} ,
                                                                                 u'ISOLATION': {}} , ) ,
                                       default=unicode("COLOCATION") , is_leaf=True , yang_name="strategy" ,
                                       parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                       defining_module='vnfd' , yang_type='enumeration' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd' , u'placement-groups']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/name (string)

    YANG Description: Place group construct to define the compute resource placement strategy
in cloud environment
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Place group construct to define the compute resource placement strategy
in cloud environment
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                   defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_requirement(self):
        """
    Getter method for requirement, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/requirement (string)

    YANG Description: This is free text space used to describe the intent/rationale
behind this placement group. This is for human consumption only
    """
        return self.__requirement

    def _set_requirement(self , v , load=False):
        """
    Setter method for requirement, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/requirement (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_requirement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_requirement() directly.

    YANG Description: This is free text space used to describe the intent/rationale
behind this placement group. This is for human consumption only
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="requirement" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """requirement must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__requirement = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_requirement(self):
        self.__requirement = YANGDynClass(base=unicode , is_leaf=True , yang_name="requirement" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_strategy(self):
        """
    Getter method for strategy, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/strategy (enumeration)

    YANG Description: Strategy associated with this placement group
  Following values are possible
    - COLOCATION: Colocation strategy imply intent to share the physical
                  infrastructure (hypervisor/network) among all members
                  of this group.
    - ISOLATION: Isolation strategy imply intent to not share the physical
                 infrastructure (hypervisor/network) among the members
                 of this group.

    """
        return self.__strategy

    def _set_strategy(self , v , load=False):
        """
    Setter method for strategy, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/strategy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_strategy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_strategy() directly.

    YANG Description: Strategy associated with this placement group
  Following values are possible
    - COLOCATION: Colocation strategy imply intent to share the physical
                  infrastructure (hypervisor/network) among all members
                  of this group.
    - ISOLATION: Isolation strategy imply intent to not share the physical
                 infrastructure (hypervisor/network) among the members
                 of this group.

    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'COLOCATION': {} , u'ISOLATION': {}} , ) ,
                             default=unicode("COLOCATION") , is_leaf=True , yang_name="strategy" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """strategy must be of a type compatible with enumeration""" ,
                'defined-type': "vnfd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'COLOCATION': {}, u'ISOLATION': {}},), default=unicode("COLOCATION"), is_leaf=True, yang_name="strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__strategy = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_strategy(self):
        self.__strategy = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                restriction_arg={u'COLOCATION': {} ,
                                                                                 u'ISOLATION': {}} , ) ,
                                       default=unicode("COLOCATION") , is_leaf=True , yang_name="strategy" ,
                                       parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                       defining_module='vnfd' , yang_type='enumeration' , is_config=True)

    def _get_member_vdus(self):
        """
    Getter method for member_vdus, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/member_vdus (list)

    YANG Description: List of VDUs that are part of this placement group
    """
        return self.__member_vdus

    def _set_member_vdus(self , v , load=False):
        """
    Setter method for member_vdus, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups/member_vdus (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vdus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vdus() directly.

    YANG Description: List of VDUs that are part of this placement group
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("member_vdu_ref" ,
                                                   yc_member_vdus_vnfd__vnfd_catalog_vnfd_placement_groups_member_vdus ,
                                                   yang_name="member-vdus" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='member-vdu-ref' , extensions=None) , is_container='list' ,
                             yang_name="member-vdus" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """member_vdus must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("member_vdu_ref",yc_member_vdus_vnfd__vnfd_catalog_vnfd_placement_groups_member_vdus, yang_name="member-vdus", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vdu-ref', extensions=None), is_container='list', yang_name="member-vdus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__member_vdus = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_member_vdus(self):
        self.__member_vdus = YANGDynClass(
            base=YANGListType("member_vdu_ref" , yc_member_vdus_vnfd__vnfd_catalog_vnfd_placement_groups_member_vdus ,
                              yang_name="member-vdus" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='member-vdu-ref' , extensions=None) ,
            is_container='list' , yang_name="member-vdus" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    requirement = __builtin__.property(_get_requirement , _set_requirement)
    strategy = __builtin__.property(_get_strategy , _set_strategy)
    member_vdus = __builtin__.property(_get_member_vdus , _set_member_vdus)

    _pyangbind_elements = {'name': name , 'requirement': requirement , 'strategy': strategy ,
                           'member_vdus': member_vdus , }


class yc_vnfd_vnfd__vnfd_catalog_vnfd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog/vnfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__id' , '__name' , '__short_name' , '__vendor' , '__logo' , '__description' ,
    '__version' , '__vnf_configuration' , '__operational_status' , '__mgmt_interface' , '__internal_vld' ,
    '__ip_profiles' , '__connection_point' , '__vdu' , '__vdu_dependency' , '__service_function_chain' ,
    '__service_function_type' , '__http_endpoint' , '__scaling_group_descriptor' , '__monitoring_param' ,
    '__placement_groups' ,)

    _yang_name = 'vnfd'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnf_configuration = YANGDynClass(base=yc_vnf_configuration_vnfd__vnfd_catalog_vnfd_vnf_configuration ,
                                                is_container='container' , yang_name="vnf-configuration" , parent=self ,
                                                path_helper=self._path_helper , extmethods=self._extmethods ,
                                                register_paths=True , extensions=None ,
                                                namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                defining_module='vnfd' , yang_type='container' , is_config=True)
        self.__internal_vld = YANGDynClass(
            base=YANGListType("id" , yc_internal_vld_vnfd__vnfd_catalog_vnfd_internal_vld , yang_name="internal-vld" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='id' , extensions=None) , is_container='list' , yang_name="internal-vld" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='list' , is_config=True)
        self.__connection_point = YANGDynClass(
            base=YANGListType("name" , yc_connection_point_vnfd__vnfd_catalog_vnfd_connection_point ,
                              yang_name="connection-point" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="connection-point" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__vendor = YANGDynClass(base=unicode , is_leaf=True , yang_name="vendor" , parent=self ,
                                     path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                     yang_type='string' , is_config=True)
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__short_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__http_endpoint = YANGDynClass(
            base=YANGListType("path" , yc_http_endpoint_vnfd__vnfd_catalog_vnfd_http_endpoint ,
                              yang_name="http-endpoint" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='path' , extensions=None) ,
            is_container='list' , yang_name="http-endpoint" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__service_function_chain = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'SFF': {} , u'CLASSIFIER': {} , u'UNAWARE': {} , u'SF': {}} , ) ,
            default=unicode("UNAWARE") , is_leaf=True , yang_name="service-function-chain" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='enumeration' ,
            is_config=True)
        self.__operational_status = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'terminated': {} , u'upgrading': {} , u'terminate': {} ,
                                                      u'running': {} , u'failed': {} , u'init': {}} , ) , is_leaf=True ,
            yang_name="operational-status" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='vnf-operational-status' , is_config=True)
        self.__service_function_type = YANGDynClass(base=unicode , is_leaf=True , yang_name="service-function-type" ,
                                                    parent=self , path_helper=self._path_helper ,
                                                    extmethods=self._extmethods , register_paths=True ,
                                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                    defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__mgmt_interface = YANGDynClass(base=yc_mgmt_interface_vnfd__vnfd_catalog_vnfd_mgmt_interface ,
                                             is_container='container' , yang_name="mgmt-interface" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , extensions=None ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='container' , is_config=True)
        self.__placement_groups = YANGDynClass(
            base=YANGListType("name" , yc_placement_groups_vnfd__vnfd_catalog_vnfd_placement_groups ,
                              yang_name="placement-groups" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="placement-groups" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__vdu = YANGDynClass(
            base=YANGListType("id" , yc_vdu_vnfd__vnfd_catalog_vnfd_vdu , yang_name="vdu" , parent=self ,
                              is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='id' , extensions=None) , is_container='list' , yang_name="vdu" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__version = YANGDynClass(base=unicode , is_leaf=True , yang_name="version" , parent=self ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                      defining_module='vnfd' , yang_type='string' , is_config=True)
        self.__monitoring_param = YANGDynClass(
            base=YANGListType("id" , yc_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param ,
                              yang_name="monitoring-param" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='id' , extensions=None) , is_container='list' ,
            yang_name="monitoring-param" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='list' , is_config=True)
        self.__vdu_dependency = YANGDynClass(
            base=YANGListType("vdu_source_ref" , yc_vdu_dependency_vnfd__vnfd_catalog_vnfd_vdu_dependency ,
                              yang_name="vdu-dependency" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='vdu-source-ref' , extensions=None) ,
            is_container='list' , yang_name="vdu-dependency" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__scaling_group_descriptor = YANGDynClass(
            base=YANGListType("name" , yc_scaling_group_descriptor_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor ,
                              yang_name="scaling-group-descriptor" , parent=self , is_container='list' ,
                              user_ordered=False , path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="scaling-group-descriptor" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__logo = YANGDynClass(base=unicode , is_leaf=True , yang_name="logo" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)
        self.__ip_profiles = YANGDynClass(
            base=YANGListType("name" , yc_ip_profiles_vnfd__vnfd_catalog_vnfd_ip_profiles , yang_name="ip-profiles" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='name' , extensions=None) , is_container='list' , yang_name="ip-profiles" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='list' , is_config=True)
        self.__id = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_dict={'length': [u'1..63']}) ,
                                 is_leaf=True , yang_name="id" , parent=self , path_helper=self._path_helper ,
                                 extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                 yang_type='string' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog' , u'vnfd']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd_catalog/vnfd/id (string)

    YANG Description: Identifier for the VNFD.
    """
        return self.__id

    def _set_id(self , v , load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd_catalog/vnfd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the VNFD.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_dict={'length': [u'1..63']}) ,
                             is_leaf=True , yang_name="id" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..63']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_dict={'length': [u'1..63']}) ,
                                 is_leaf=True , yang_name="id" , parent=self , path_helper=self._path_helper ,
                                 extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                 yang_type='string' , is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd_catalog/vnfd/name (string)

    YANG Description: VNFD name.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd_catalog/vnfd/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: VNFD name.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)

    def _get_short_name(self):
        """
    Getter method for short_name, mapped from YANG variable /vnfd_catalog/vnfd/short_name (string)

    YANG Description: Short name to appear as label in the UI
    """
        return self.__short_name

    def _set_short_name(self , v , load=False):
        """
    Setter method for short_name, mapped from YANG variable /vnfd_catalog/vnfd/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.

    YANG Description: Short name to appear as label in the UI
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """short_name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__short_name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_short_name(self):
        self.__short_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                         defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_vendor(self):
        """
    Getter method for vendor, mapped from YANG variable /vnfd_catalog/vnfd/vendor (string)

    YANG Description: Vendor of the VNFD.
    """
        return self.__vendor

    def _set_vendor(self , v , load=False):
        """
    Setter method for vendor, mapped from YANG variable /vnfd_catalog/vnfd/vendor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor() directly.

    YANG Description: Vendor of the VNFD.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vendor" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vendor must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__vendor = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vendor(self):
        self.__vendor = YANGDynClass(base=unicode , is_leaf=True , yang_name="vendor" , parent=self ,
                                     path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                     yang_type='string' , is_config=True)

    def _get_logo(self):
        """
    Getter method for logo, mapped from YANG variable /vnfd_catalog/vnfd/logo (string)

    YANG Description: Vendor logo for the Virtual Network Function
    """
        return self.__logo

    def _set_logo(self , v , load=False):
        """
    Setter method for logo, mapped from YANG variable /vnfd_catalog/vnfd/logo (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logo is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logo() directly.

    YANG Description: Vendor logo for the Virtual Network Function
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="logo" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """logo must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="logo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__logo = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_logo(self):
        self.__logo = YANGDynClass(base=unicode , is_leaf=True , yang_name="logo" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                   yang_type='string' , is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd_catalog/vnfd/description (string)

    YANG Description: Description of the VNFD.
    """
        return self.__description

    def _set_description(self , v , load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd_catalog/vnfd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the VNFD.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__description = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                          defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_version(self):
        """
    Getter method for version, mapped from YANG variable /vnfd_catalog/vnfd/version (string)

    YANG Description: Version of the VNFD
    """
        return self.__version

    def _set_version(self , v , load=False):
        """
    Setter method for version, mapped from YANG variable /vnfd_catalog/vnfd/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Version of the VNFD
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="version" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """version must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__version = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(base=unicode , is_leaf=True , yang_name="version" , parent=self ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                      defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_vnf_configuration(self):
        """
    Getter method for vnf_configuration, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration (container)
    """
        return self.__vnf_configuration

    def _set_vnf_configuration(self , v , load=False):
        """
    Setter method for vnf_configuration, mapped from YANG variable /vnfd_catalog/vnfd/vnf_configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_configuration() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_vnf_configuration_vnfd__vnfd_catalog_vnfd_vnf_configuration ,
                             is_container='container' , yang_name="vnf-configuration" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnf_configuration must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_vnf_configuration_vnfd__vnfd_catalog_vnfd_vnf_configuration, is_container='container', yang_name="vnf-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__vnf_configuration = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnf_configuration(self):
        self.__vnf_configuration = YANGDynClass(base=yc_vnf_configuration_vnfd__vnfd_catalog_vnfd_vnf_configuration ,
                                                is_container='container' , yang_name="vnf-configuration" , parent=self ,
                                                path_helper=self._path_helper , extmethods=self._extmethods ,
                                                register_paths=True , extensions=None ,
                                                namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                defining_module='vnfd' , yang_type='container' , is_config=True)

    def _get_operational_status(self):
        """
    Getter method for operational_status, mapped from YANG variable /vnfd_catalog/vnfd/operational_status (vnf-operational-status)

    YANG Description: The operational status of the VNF
 init                : The VNF has just started.
 running             : The VNF is active in VM
 upgrading           : The VNF is being upgraded (EXPERIMENTAL)
 terminate           : The VNF is being terminated
 terminated          : The VNF is in the terminated state.
 failed              : The VNF  instantiation failed.

    """
        return self.__operational_status

    def _set_operational_status(self , v , load=False):
        """
    Setter method for operational_status, mapped from YANG variable /vnfd_catalog/vnfd/operational_status (vnf-operational-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operational_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operational_status() directly.

    YANG Description: The operational status of the VNF
 init                : The VNF has just started.
 running             : The VNF is active in VM
 upgrading           : The VNF is being upgraded (EXPERIMENTAL)
 terminate           : The VNF is being terminated
 terminated          : The VNF is in the terminated state.
 failed              : The VNF  instantiation failed.

    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'terminated': {} , u'upgrading': {} ,
                                                                           u'terminate': {} , u'running': {} ,
                                                                           u'failed': {} , u'init': {}} , ) ,
                             is_leaf=True , yang_name="operational-status" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='vnf-operational-status' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """operational_status must be of a type compatible with vnf-operational-status""" ,
                'defined-type': "vnfd:vnf-operational-status" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'terminated': {}, u'upgrading': {}, u'terminate': {}, u'running': {}, u'failed': {}, u'init': {}},), is_leaf=True, yang_name="operational-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='vnf-operational-status', is_config=True)""" ,
            })

        self.__operational_status = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_operational_status(self):
        self.__operational_status = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'terminated': {} , u'upgrading': {} , u'terminate': {} ,
                                                      u'running': {} , u'failed': {} , u'init': {}} , ) , is_leaf=True ,
            yang_name="operational-status" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='vnf-operational-status' , is_config=True)

    def _get_mgmt_interface(self):
        """
    Getter method for mgmt_interface, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface (container)

    YANG Description: Interface over which the VNF is managed.
    """
        return self.__mgmt_interface

    def _set_mgmt_interface(self , v , load=False):
        """
    Setter method for mgmt_interface, mapped from YANG variable /vnfd_catalog/vnfd/mgmt_interface (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_interface() directly.

    YANG Description: Interface over which the VNF is managed.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_mgmt_interface_vnfd__vnfd_catalog_vnfd_mgmt_interface ,
                             is_container='container' , yang_name="mgmt-interface" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """mgmt_interface must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_mgmt_interface_vnfd__vnfd_catalog_vnfd_mgmt_interface, is_container='container', yang_name="mgmt-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__mgmt_interface = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_mgmt_interface(self):
        self.__mgmt_interface = YANGDynClass(base=yc_mgmt_interface_vnfd__vnfd_catalog_vnfd_mgmt_interface ,
                                             is_container='container' , yang_name="mgmt-interface" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , extensions=None ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='container' , is_config=True)

    def _get_internal_vld(self):
        """
    Getter method for internal_vld, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld (list)

    YANG Description: List of Internal Virtual Link Descriptors (VLD).
The internal VLD describes the basic topology of
the connectivity such as E-LAN, E-Line, E-Tree.
between internal VNF components of the system.
    """
        return self.__internal_vld

    def _set_internal_vld(self , v , load=False):
        """
    Setter method for internal_vld, mapped from YANG variable /vnfd_catalog/vnfd/internal_vld (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_internal_vld is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_internal_vld() directly.

    YANG Description: List of Internal Virtual Link Descriptors (VLD).
The internal VLD describes the basic topology of
the connectivity such as E-LAN, E-Line, E-Tree.
between internal VNF components of the system.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("id" , yc_internal_vld_vnfd__vnfd_catalog_vnfd_internal_vld ,
                                                   yang_name="internal-vld" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper , yang_keys='id' ,
                                                   extensions=None) , is_container='list' , yang_name="internal-vld" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """internal_vld must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_internal_vld_vnfd__vnfd_catalog_vnfd_internal_vld, yang_name="internal-vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="internal-vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__internal_vld = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_internal_vld(self):
        self.__internal_vld = YANGDynClass(
            base=YANGListType("id" , yc_internal_vld_vnfd__vnfd_catalog_vnfd_internal_vld , yang_name="internal-vld" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='id' , extensions=None) , is_container='list' , yang_name="internal-vld" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='list' , is_config=True)

    def _get_ip_profiles(self):
        """
    Getter method for ip_profiles, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles (list)

    YANG Description: List of IP Profiles.
  IP Profile describes the IP characteristics for the Virtual-Link
    """
        return self.__ip_profiles

    def _set_ip_profiles(self , v , load=False):
        """
    Setter method for ip_profiles, mapped from YANG variable /vnfd_catalog/vnfd/ip_profiles (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_profiles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_profiles() directly.

    YANG Description: List of IP Profiles.
  IP Profile describes the IP characteristics for the Virtual-Link
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" , yc_ip_profiles_vnfd__vnfd_catalog_vnfd_ip_profiles ,
                                                   yang_name="ip-profiles" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="ip-profiles" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ip_profiles must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_ip_profiles_vnfd__vnfd_catalog_vnfd_ip_profiles, yang_name="ip-profiles", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ip-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__ip_profiles = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ip_profiles(self):
        self.__ip_profiles = YANGDynClass(
            base=YANGListType("name" , yc_ip_profiles_vnfd__vnfd_catalog_vnfd_ip_profiles , yang_name="ip-profiles" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='name' , extensions=None) , is_container='list' , yang_name="ip-profiles" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
            yang_type='list' , is_config=True)

    def _get_connection_point(self):
        """
    Getter method for connection_point, mapped from YANG variable /vnfd_catalog/vnfd/connection_point (list)

    YANG Description: List for external connection points. Each VNF has one
or more external connection points that connect the VNF
to other VNFs or to external networks. Each VNF exposes
connection points to the orchestrator, which can construct
network services by connecting the connection points
between different VNFs. The NFVO will use VLDs and VNFFGs
at the network service level to construct network services.
    """
        return self.__connection_point

    def _set_connection_point(self , v , load=False):
        """
    Setter method for connection_point, mapped from YANG variable /vnfd_catalog/vnfd/connection_point (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_point is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_point() directly.

    YANG Description: List for external connection points. Each VNF has one
or more external connection points that connect the VNF
to other VNFs or to external networks. Each VNF exposes
connection points to the orchestrator, which can construct
network services by connecting the connection points
between different VNFs. The NFVO will use VLDs and VNFFGs
at the network service level to construct network services.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=YANGListType("name" , yc_connection_point_vnfd__vnfd_catalog_vnfd_connection_point ,
                                               yang_name="connection-point" , parent=self , is_container='list' ,
                                               user_ordered=False , path_helper=self._path_helper , yang_keys='name' ,
                                               extensions=None) , is_container='list' , yang_name="connection-point" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """connection_point must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_connection_point_vnfd__vnfd_catalog_vnfd_connection_point, yang_name="connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__connection_point = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_connection_point(self):
        self.__connection_point = YANGDynClass(
            base=YANGListType("name" , yc_connection_point_vnfd__vnfd_catalog_vnfd_connection_point ,
                              yang_name="connection-point" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="connection-point" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    def _get_vdu(self):
        """
    Getter method for vdu, mapped from YANG variable /vnfd_catalog/vnfd/vdu (list)

    YANG Description: List of Virtual Deployment Units
    """
        return self.__vdu

    def _set_vdu(self , v , load=False):
        """
    Setter method for vdu, mapped from YANG variable /vnfd_catalog/vnfd/vdu (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu() directly.

    YANG Description: List of Virtual Deployment Units
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("id" , yc_vdu_vnfd__vnfd_catalog_vnfd_vdu , yang_name="vdu" ,
                                                   parent=self , is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='id' , extensions=None) ,
                             is_container='list' , yang_name="vdu" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vdu must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_vdu_vnfd__vnfd_catalog_vnfd_vdu, yang_name="vdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__vdu = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vdu(self):
        self.__vdu = YANGDynClass(
            base=YANGListType("id" , yc_vdu_vnfd__vnfd_catalog_vnfd_vdu , yang_name="vdu" , parent=self ,
                              is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='id' , extensions=None) , is_container='list' , yang_name="vdu" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    def _get_vdu_dependency(self):
        """
    Getter method for vdu_dependency, mapped from YANG variable /vnfd_catalog/vnfd/vdu_dependency (list)

    YANG Description: List of VDU dependencies.
    """
        return self.__vdu_dependency

    def _set_vdu_dependency(self , v , load=False):
        """
    Setter method for vdu_dependency, mapped from YANG variable /vnfd_catalog/vnfd/vdu_dependency (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_dependency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_dependency() directly.

    YANG Description: List of VDU dependencies.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("vdu_source_ref" ,
                                                   yc_vdu_dependency_vnfd__vnfd_catalog_vnfd_vdu_dependency ,
                                                   yang_name="vdu-dependency" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='vdu-source-ref' , extensions=None) , is_container='list' ,
                             yang_name="vdu-dependency" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vdu_dependency must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("vdu_source_ref",yc_vdu_dependency_vnfd__vnfd_catalog_vnfd_vdu_dependency, yang_name="vdu-dependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vdu-source-ref', extensions=None), is_container='list', yang_name="vdu-dependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__vdu_dependency = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vdu_dependency(self):
        self.__vdu_dependency = YANGDynClass(
            base=YANGListType("vdu_source_ref" , yc_vdu_dependency_vnfd__vnfd_catalog_vnfd_vdu_dependency ,
                              yang_name="vdu-dependency" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='vdu-source-ref' , extensions=None) ,
            is_container='list' , yang_name="vdu-dependency" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    def _get_service_function_chain(self):
        """
    Getter method for service_function_chain, mapped from YANG variable /vnfd_catalog/vnfd/service_function_chain (enumeration)

    YANG Description: Type of node in Service Function Chaining Architecture
    """
        return self.__service_function_chain

    def _set_service_function_chain(self , v , load=False):
        """
    Setter method for service_function_chain, mapped from YANG variable /vnfd_catalog/vnfd/service_function_chain (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_function_chain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_function_chain() directly.

    YANG Description: Type of node in Service Function Chaining Architecture
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'SFF': {} , u'CLASSIFIER': {} ,
                                                                           u'UNAWARE': {} , u'SF': {}} , ) ,
                             default=unicode("UNAWARE") , is_leaf=True , yang_name="service-function-chain" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """service_function_chain must be of a type compatible with enumeration""" ,
                'defined-type': "vnfd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'SFF': {}, u'CLASSIFIER': {}, u'UNAWARE': {}, u'SF': {}},), default=unicode("UNAWARE"), is_leaf=True, yang_name="service-function-chain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__service_function_chain = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_service_function_chain(self):
        self.__service_function_chain = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'SFF': {} , u'CLASSIFIER': {} , u'UNAWARE': {} , u'SF': {}} , ) ,
            default=unicode("UNAWARE") , is_leaf=True , yang_name="service-function-chain" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='enumeration' ,
            is_config=True)

    def _get_service_function_type(self):
        """
    Getter method for service_function_type, mapped from YANG variable /vnfd_catalog/vnfd/service_function_type (string)

    YANG Description: Type of Service Function.
NOTE: This needs to map with Service Function Type in ODL to
support VNFFG. Service Function Type is mandatory param in ODL
SFC. This is temporarily set to string for ease of use
    """
        return self.__service_function_type

    def _set_service_function_type(self , v , load=False):
        """
    Setter method for service_function_type, mapped from YANG variable /vnfd_catalog/vnfd/service_function_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_function_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_function_type() directly.

    YANG Description: Type of Service Function.
NOTE: This needs to map with Service Function Type in ODL to
support VNFFG. Service Function Type is mandatory param in ODL
SFC. This is temporarily set to string for ease of use
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="service-function-type" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """service_function_type must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="service-function-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__service_function_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_service_function_type(self):
        self.__service_function_type = YANGDynClass(base=unicode , is_leaf=True , yang_name="service-function-type" ,
                                                    parent=self , path_helper=self._path_helper ,
                                                    extmethods=self._extmethods , register_paths=True ,
                                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                                    defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_http_endpoint(self):
        """
    Getter method for http_endpoint, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint (list)

    YANG Description: List of http endpoints to be used by monitoring params
    """
        return self.__http_endpoint

    def _set_http_endpoint(self , v , load=False):
        """
    Setter method for http_endpoint, mapped from YANG variable /vnfd_catalog/vnfd/http_endpoint (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_http_endpoint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_http_endpoint() directly.

    YANG Description: List of http endpoints to be used by monitoring params
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("path" , yc_http_endpoint_vnfd__vnfd_catalog_vnfd_http_endpoint ,
                                                   yang_name="http-endpoint" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='path' , extensions=None) , is_container='list' ,
                             yang_name="http-endpoint" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """http_endpoint must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("path",yc_http_endpoint_vnfd__vnfd_catalog_vnfd_http_endpoint, yang_name="http-endpoint", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='path', extensions=None), is_container='list', yang_name="http-endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__http_endpoint = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_http_endpoint(self):
        self.__http_endpoint = YANGDynClass(
            base=YANGListType("path" , yc_http_endpoint_vnfd__vnfd_catalog_vnfd_http_endpoint ,
                              yang_name="http-endpoint" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='path' , extensions=None) ,
            is_container='list' , yang_name="http-endpoint" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    def _get_scaling_group_descriptor(self):
        """
    Getter method for scaling_group_descriptor, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor (list)

    YANG Description: scaling group descriptor within the VNF.
The scaling group defines a group of VDUs,
and the ratio of VDUs in the VNF
that is used as target for scaling action
    """
        return self.__scaling_group_descriptor

    def _set_scaling_group_descriptor(self , v , load=False):
        """
    Setter method for scaling_group_descriptor, mapped from YANG variable /vnfd_catalog/vnfd/scaling_group_descriptor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_group_descriptor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_group_descriptor() directly.

    YANG Description: scaling group descriptor within the VNF.
The scaling group defines a group of VDUs,
and the ratio of VDUs in the VNF
that is used as target for scaling action
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" ,
                                                   yc_scaling_group_descriptor_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor ,
                                                   yang_name="scaling-group-descriptor" , parent=self ,
                                                   is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
                             is_container='list' , yang_name="scaling-group-descriptor" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scaling_group_descriptor must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_scaling_group_descriptor_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor, yang_name="scaling-group-descriptor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-group-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__scaling_group_descriptor = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scaling_group_descriptor(self):
        self.__scaling_group_descriptor = YANGDynClass(
            base=YANGListType("name" , yc_scaling_group_descriptor_vnfd__vnfd_catalog_vnfd_scaling_group_descriptor ,
                              yang_name="scaling-group-descriptor" , parent=self , is_container='list' ,
                              user_ordered=False , path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="scaling-group-descriptor" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    def _get_monitoring_param(self):
        """
    Getter method for monitoring_param, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param (list)

    YANG Description: List of monitoring parameters at the network service level
    """
        return self.__monitoring_param

    def _set_monitoring_param(self , v , load=False):
        """
    Setter method for monitoring_param, mapped from YANG variable /vnfd_catalog/vnfd/monitoring_param (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitoring_param is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitoring_param() directly.

    YANG Description: List of monitoring parameters at the network service level
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("id" , yc_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param ,
                                                   yang_name="monitoring-param" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper , yang_keys='id' ,
                                                   extensions=None) , is_container='list' ,
                             yang_name="monitoring-param" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """monitoring_param must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param, yang_name="monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__monitoring_param = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_monitoring_param(self):
        self.__monitoring_param = YANGDynClass(
            base=YANGListType("id" , yc_monitoring_param_vnfd__vnfd_catalog_vnfd_monitoring_param ,
                              yang_name="monitoring-param" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='id' , extensions=None) , is_container='list' ,
            yang_name="monitoring-param" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
            defining_module='vnfd' , yang_type='list' , is_config=True)

    def _get_placement_groups(self):
        """
    Getter method for placement_groups, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups (list)

    YANG Description: List of placement groups at VNF level
    """
        return self.__placement_groups

    def _set_placement_groups(self , v , load=False):
        """
    Setter method for placement_groups, mapped from YANG variable /vnfd_catalog/vnfd/placement_groups (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_placement_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_placement_groups() directly.

    YANG Description: List of placement groups at VNF level
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=YANGListType("name" , yc_placement_groups_vnfd__vnfd_catalog_vnfd_placement_groups ,
                                               yang_name="placement-groups" , parent=self , is_container='list' ,
                                               user_ordered=False , path_helper=self._path_helper , yang_keys='name' ,
                                               extensions=None) , is_container='list' , yang_name="placement-groups" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """placement_groups must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_placement_groups_vnfd__vnfd_catalog_vnfd_placement_groups, yang_name="placement-groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="placement-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__placement_groups = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_placement_groups(self):
        self.__placement_groups = YANGDynClass(
            base=YANGListType("name" , yc_placement_groups_vnfd__vnfd_catalog_vnfd_placement_groups ,
                              yang_name="placement-groups" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="placement-groups" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    id = __builtin__.property(_get_id , _set_id)
    name = __builtin__.property(_get_name , _set_name)
    short_name = __builtin__.property(_get_short_name , _set_short_name)
    vendor = __builtin__.property(_get_vendor , _set_vendor)
    logo = __builtin__.property(_get_logo , _set_logo)
    description = __builtin__.property(_get_description , _set_description)
    version = __builtin__.property(_get_version , _set_version)
    vnf_configuration = __builtin__.property(_get_vnf_configuration , _set_vnf_configuration)
    operational_status = __builtin__.property(_get_operational_status , _set_operational_status)
    mgmt_interface = __builtin__.property(_get_mgmt_interface , _set_mgmt_interface)
    internal_vld = __builtin__.property(_get_internal_vld , _set_internal_vld)
    ip_profiles = __builtin__.property(_get_ip_profiles , _set_ip_profiles)
    connection_point = __builtin__.property(_get_connection_point , _set_connection_point)
    vdu = __builtin__.property(_get_vdu , _set_vdu)
    vdu_dependency = __builtin__.property(_get_vdu_dependency , _set_vdu_dependency)
    service_function_chain = __builtin__.property(_get_service_function_chain , _set_service_function_chain)
    service_function_type = __builtin__.property(_get_service_function_type , _set_service_function_type)
    http_endpoint = __builtin__.property(_get_http_endpoint , _set_http_endpoint)
    scaling_group_descriptor = __builtin__.property(_get_scaling_group_descriptor , _set_scaling_group_descriptor)
    monitoring_param = __builtin__.property(_get_monitoring_param , _set_monitoring_param)
    placement_groups = __builtin__.property(_get_placement_groups , _set_placement_groups)

    _pyangbind_elements = {'id': id , 'name': name , 'short_name': short_name , 'vendor': vendor , 'logo': logo ,
                           'description': description , 'version': version , 'vnf_configuration': vnf_configuration ,
                           'operational_status': operational_status , 'mgmt_interface': mgmt_interface ,
                           'internal_vld': internal_vld , 'ip_profiles': ip_profiles ,
                           'connection_point': connection_point , 'vdu': vdu , 'vdu_dependency': vdu_dependency ,
                           'service_function_chain': service_function_chain ,
                           'service_function_type': service_function_type , 'http_endpoint': http_endpoint ,
                           'scaling_group_descriptor': scaling_group_descriptor , 'monitoring_param': monitoring_param ,
                           'placement_groups': placement_groups , }


class yc_vnfd_catalog_vnfd__vnfd_catalog(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd-catalog. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Virtual Network Function Descriptor (VNFD).
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__schema_version' , '__vnfd' ,)

    _yang_name = 'vnfd-catalog'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnfd = YANGDynClass(
            base=YANGListType("id" , yc_vnfd_vnfd__vnfd_catalog_vnfd , yang_name="vnfd" , parent=self ,
                              is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='id' , extensions=None) , is_container='list' , yang_name="vnfd" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)
        self.__schema_version = YANGDynClass(base=unicode , default=unicode("v3.0") , is_leaf=True ,
                                             yang_name="schema-version" , parent=self , path_helper=self._path_helper ,
                                             extmethods=self._extmethods , register_paths=True ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'vnfd-catalog']

    def _get_schema_version(self):
        """
    Getter method for schema_version, mapped from YANG variable /vnfd_catalog/schema_version (string)

    YANG Description: Schema version for the VNFD. If unspecified, it assumes v3.0
    """
        return self.__schema_version

    def _set_schema_version(self , v , load=False):
        """
    Setter method for schema_version, mapped from YANG variable /vnfd_catalog/schema_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_schema_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_schema_version() directly.

    YANG Description: Schema version for the VNFD. If unspecified, it assumes v3.0
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , default=unicode("v3.0") , is_leaf=True , yang_name="schema-version" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                             defining_module='vnfd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """schema_version must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, default=unicode("v3.0"), is_leaf=True, yang_name="schema-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='string', is_config=True)""" ,
            })

        self.__schema_version = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_schema_version(self):
        self.__schema_version = YANGDynClass(base=unicode , default=unicode("v3.0") , is_leaf=True ,
                                             yang_name="schema-version" , parent=self , path_helper=self._path_helper ,
                                             extmethods=self._extmethods , register_paths=True ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' ,
                                             defining_module='vnfd' , yang_type='string' , is_config=True)

    def _get_vnfd(self):
        """
    Getter method for vnfd, mapped from YANG variable /vnfd_catalog/vnfd (list)
    """
        return self.__vnfd

    def _set_vnfd(self , v , load=False):
        """
    Setter method for vnfd, mapped from YANG variable /vnfd_catalog/vnfd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=YANGListType("id" , yc_vnfd_vnfd__vnfd_catalog_vnfd , yang_name="vnfd" , parent=self ,
                                               is_container='list' , user_ordered=False ,
                                               path_helper=self._path_helper , yang_keys='id' , extensions=None) ,
                             is_container='list' , yang_name="vnfd" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_vnfd_vnfd__vnfd_catalog_vnfd, yang_name="vnfd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='list', is_config=True)""" ,
            })

        self.__vnfd = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd(self):
        self.__vnfd = YANGDynClass(
            base=YANGListType("id" , yc_vnfd_vnfd__vnfd_catalog_vnfd , yang_name="vnfd" , parent=self ,
                              is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='id' , extensions=None) , is_container='list' , yang_name="vnfd" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' , yang_type='list' ,
            is_config=True)

    schema_version = __builtin__.property(_get_schema_version , _set_schema_version)
    vnfd = __builtin__.property(_get_vnfd , _set_vnfd)

    _pyangbind_elements = {'schema_version': schema_version , 'vnfd': vnfd , }


class vnfd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd - based on the path /vnfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__vnfd_catalog' ,)

    _yang_name = 'vnfd'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnfd_catalog = YANGDynClass(base=yc_vnfd_catalog_vnfd__vnfd_catalog , is_container='container' ,
                                           yang_name="vnfd-catalog" , parent=self , path_helper=self._path_helper ,
                                           extmethods=self._extmethods , register_paths=True , extensions=None ,
                                           namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                           yang_type='container' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return []

    def _get_vnfd_catalog(self):
        """
    Getter method for vnfd_catalog, mapped from YANG variable /vnfd_catalog (container)

    YANG Description: Virtual Network Function Descriptor (VNFD).
    """
        return self.__vnfd_catalog

    def _set_vnfd_catalog(self , v , load=False):
        """
    Setter method for vnfd_catalog, mapped from YANG variable /vnfd_catalog (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_catalog is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_catalog() directly.

    YANG Description: Virtual Network Function Descriptor (VNFD).
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_vnfd_catalog_vnfd__vnfd_catalog , is_container='container' ,
                             yang_name="vnfd-catalog" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_catalog must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_vnfd_catalog_vnfd__vnfd_catalog, is_container='container', yang_name="vnfd-catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd', defining_module='vnfd', yang_type='container', is_config=True)""" ,
            })

        self.__vnfd_catalog = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_catalog(self):
        self.__vnfd_catalog = YANGDynClass(base=yc_vnfd_catalog_vnfd__vnfd_catalog , is_container='container' ,
                                           yang_name="vnfd-catalog" , parent=self , path_helper=self._path_helper ,
                                           extmethods=self._extmethods , register_paths=True , extensions=None ,
                                           namespace='urn:ietf:params:xml:ns:yang:nfvo:vnfd' , defining_module='vnfd' ,
                                           yang_type='container' , is_config=True)

    vnfd_catalog = __builtin__.property(_get_vnfd_catalog , _set_vnfd_catalog)

    _pyangbind_elements = {'vnfd_catalog': vnfd_catalog , }


class ietf_inet_types(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-inet-types - based on the path /ietf-inet-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of generally useful derived
YANG data types for Internet addresses and related things.

Copyright (c) 2013 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 6991; see
the RFC itself for full legal notices.
  """
    _pyangbind_elements = {}


class yc_connection_point_nsd__nsd_catalog_nsd_connection_point(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/connection-point. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List for external connection points.
Each NS has one or more external connection
points. As the name implies that external
connection points are used for connecting
the NS to other NS or to external networks.
Each NS exposes these connection points to
the orchestrator. The orchestrator can
construct network service chains by
connecting the connection points between
different NS.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__floating_ip_required' , '__type' , '__vld_id_ref' ,
                 '__member_vnf_index_ref' , '__vnfd_id_ref' , '__vnfd_connection_point_ref' ,)

    _yang_name = 'connection-point'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnfd_connection_point_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                        yang_name="vnfd-connection-point-ref" , parent=self ,
                                                        choice=(u'connection' , u'vnfd-connection-point-ref') ,
                                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                                        register_paths=True ,
                                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                        defining_module='nsd' , yang_type='leafref' , is_config=True)
        self.__floating_ip_required = YANGDynClass(base=YANGBool , is_leaf=True , yang_name="floating-ip-required" ,
                                                   parent=self , path_helper=self._path_helper ,
                                                   extmethods=self._extmethods , register_paths=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='boolean' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)
        self.__vnfd_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                                          choice=(u'connection' , u'vnfd-connection-point-ref') ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='leafref' , is_config=True)
        self.__member_vnf_index_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" ,
                                                   parent=self , choice=(u'connection' , u'vnfd-connection-point-ref') ,
                                                   path_helper=self._path_helper , extmethods=self._extmethods ,
                                                   register_paths=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='leafref' , is_config=True)
        self.__vld_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vld-id-ref" , parent=self ,
                                         choice=(u'connection' , u'vld-ref') , path_helper=self._path_helper ,
                                         extmethods=self._extmethods , register_paths=True ,
                                         namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                         yang_type='leafref' , is_config=True)
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                            restriction_arg={u'VPORT': {}} , ) , is_leaf=True ,
                                   yang_name="type" , parent=self , path_helper=self._path_helper ,
                                   extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='manotypes:connection-point-type' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'connection-point']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/connection_point/name (string)

    YANG Description: Name of the connection point.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/connection_point/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the connection point.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_floating_ip_required(self):
        """
    Getter method for floating_ip_required, mapped from YANG variable /nsd_catalog/nsd/connection_point/floating_ip_required (boolean)

    YANG Description: Boolean parameter to indicate whether the CP must be exposed.
A public IP address will be allocated to this CP if exposed is true.
The default is false meaning a floating IP address is not required.
It must be explicitly asked for a floating IP address to be allocated.
    """
        return self.__floating_ip_required

    def _set_floating_ip_required(self , v , load=False):
        """
    Setter method for floating_ip_required, mapped from YANG variable /nsd_catalog/nsd/connection_point/floating_ip_required (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_floating_ip_required is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_floating_ip_required() directly.

    YANG Description: Boolean parameter to indicate whether the CP must be exposed.
A public IP address will be allocated to this CP if exposed is true.
The default is false meaning a floating IP address is not required.
It must be explicitly asked for a floating IP address to be allocated.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , is_leaf=True , yang_name="floating-ip-required" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """floating_ip_required must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""" ,
            })

        self.__floating_ip_required = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_floating_ip_required(self):
        self.__floating_ip_required = YANGDynClass(base=YANGBool , is_leaf=True , yang_name="floating-ip-required" ,
                                                   parent=self , path_helper=self._path_helper ,
                                                   extmethods=self._extmethods , register_paths=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='boolean' , is_config=True)

    def _get_type(self):
        """
    Getter method for type, mapped from YANG variable /nsd_catalog/nsd/connection_point/type (manotypes:connection-point-type)

    YANG Description: Type of the connection point.
    """
        return self.__type

    def _set_type(self , v , load=False):
        """
    Setter method for type, mapped from YANG variable /nsd_catalog/nsd/connection_point/type (manotypes:connection-point-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the connection point.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'VPORT': {}} , ) , is_leaf=True ,
                             yang_name="type" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='manotypes:connection-point-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """type must be of a type compatible with manotypes:connection-point-type""" ,
                'defined-type': "manotypes:connection-point-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'VPORT': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='manotypes:connection-point-type', is_config=True)""" ,
            })

        self.__type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                            restriction_arg={u'VPORT': {}} , ) , is_leaf=True ,
                                   yang_name="type" , parent=self , path_helper=self._path_helper ,
                                   extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='manotypes:connection-point-type' , is_config=True)

    def _get_vld_id_ref(self):
        """
    Getter method for vld_id_ref, mapped from YANG variable /nsd_catalog/nsd/connection_point/vld_id_ref (leafref)

    YANG Description: ID reference to a VLD in the NS
    """
        return self.__vld_id_ref

    def _set_vld_id_ref(self , v , load=False):
        """
    Setter method for vld_id_ref, mapped from YANG variable /nsd_catalog/nsd/connection_point/vld_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vld_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vld_id_ref() directly.

    YANG Description: ID reference to a VLD in the NS
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vld-id-ref" , parent=self ,
                             choice=(u'connection' , u'vld-ref') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vld_id_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vld-id-ref", parent=self, choice=(u'connection', u'vld-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vld_id_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vld_id_ref(self):
        self.__vld_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vld-id-ref" , parent=self ,
                                         choice=(u'connection' , u'vld-ref') , path_helper=self._path_helper ,
                                         extmethods=self._extmethods , register_paths=True ,
                                         namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                         yang_type='leafref' , is_config=True)

    def _get_member_vnf_index_ref(self):
        """
    Getter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/connection_point/member_vnf_index_ref (leafref)

    YANG Description: Reference to member-vnf within constituent-vnfd
    """
        return self.__member_vnf_index_ref

    def _set_member_vnf_index_ref(self , v , load=False):
        """
    Setter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/connection_point/member_vnf_index_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index_ref() directly.

    YANG Description: Reference to member-vnf within constituent-vnfd
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" , parent=self ,
                             choice=(u'connection' , u'vnfd-connection-point-ref') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """member_vnf_index_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, choice=(u'connection', u'vnfd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__member_vnf_index_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_member_vnf_index_ref(self):
        self.__member_vnf_index_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" ,
                                                   parent=self , choice=(u'connection' , u'vnfd-connection-point-ref') ,
                                                   path_helper=self._path_helper , extmethods=self._extmethods ,
                                                   register_paths=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_vnfd_id_ref(self):
        """
    Getter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/connection_point/vnfd_id_ref (leafref)

    YANG Description: A reference to a vnfd. This is a leafref to path:
   ../../nsd:constituent-vnfd
   + [nsd:id = current()/../nsd:id-ref]
   + /nsd:vnfd-id-ref
    """
        return self.__vnfd_id_ref

    def _set_vnfd_id_ref(self , v , load=False):
        """
    Setter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/connection_point/vnfd_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id_ref() directly.

    YANG Description: A reference to a vnfd. This is a leafref to path:
   ../../nsd:constituent-vnfd
   + [nsd:id = current()/../nsd:id-ref]
   + /nsd:vnfd-id-ref
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                             choice=(u'connection' , u'vnfd-connection-point-ref') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_id_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnfd-id-ref", parent=self, choice=(u'connection', u'vnfd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vnfd_id_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_id_ref(self):
        self.__vnfd_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                                          choice=(u'connection' , u'vnfd-connection-point-ref') ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_vnfd_connection_point_ref(self):
        """
    Getter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/connection_point/vnfd_connection_point_ref (leafref)

    YANG Description: A reference to a connection point name
   in a vnfd. This is a leafref to path:
       /vnfd:vnfd-catalog/vnfd:vnfd
       + [vnfd:id = current()/../nsd:vnfd-id-ref]
       + /vnfd:connection-point/vnfd:name
    """
        return self.__vnfd_connection_point_ref

    def _set_vnfd_connection_point_ref(self , v , load=False):
        """
    Setter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/connection_point/vnfd_connection_point_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_connection_point_ref() directly.

    YANG Description: A reference to a connection point name
   in a vnfd. This is a leafref to path:
       /vnfd:vnfd-catalog/vnfd:vnfd
       + [vnfd:id = current()/../nsd:vnfd-id-ref]
       + /vnfd:connection-point/vnfd:name
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnfd-connection-point-ref" , parent=self ,
                             choice=(u'connection' , u'vnfd-connection-point-ref') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_connection_point_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, choice=(u'connection', u'vnfd-connection-point-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vnfd_connection_point_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_connection_point_ref(self):
        self.__vnfd_connection_point_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                        yang_name="vnfd-connection-point-ref" , parent=self ,
                                                        choice=(u'connection' , u'vnfd-connection-point-ref') ,
                                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                                        register_paths=True ,
                                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                        defining_module='nsd' , yang_type='leafref' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    floating_ip_required = __builtin__.property(_get_floating_ip_required , _set_floating_ip_required)
    type = __builtin__.property(_get_type , _set_type)
    vld_id_ref = __builtin__.property(_get_vld_id_ref , _set_vld_id_ref)
    member_vnf_index_ref = __builtin__.property(_get_member_vnf_index_ref , _set_member_vnf_index_ref)
    vnfd_id_ref = __builtin__.property(_get_vnfd_id_ref , _set_vnfd_id_ref)
    vnfd_connection_point_ref = __builtin__.property(_get_vnfd_connection_point_ref , _set_vnfd_connection_point_ref)

    __choices__ = {u'connection': {u'vld-ref': [u'vld_id_ref'] ,
                                   u'vnfd-connection-point-ref': [u'member_vnf_index_ref' , u'vnfd_id_ref' ,
                                                                  u'vnfd_connection_point_ref']}}
    _pyangbind_elements = {'name': name , 'floating_ip_required': floating_ip_required , 'type': type ,
                           'vld_id_ref': vld_id_ref , 'member_vnf_index_ref': member_vnf_index_ref ,
                           'vnfd_id_ref': vnfd_id_ref , 'vnfd_connection_point_ref': vnfd_connection_point_ref , }


class yc_scaling_criteria_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy_scaling_criteria(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/scaling-group-descriptor/scaling-policy/scaling-criteria. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: list of conditions to be met for generating scaling
  requests
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__name' , '__scale_in_threshold' , '__scale_in_relational_operation' ,
    '__scale_out_threshold' , '__scale_out_relational_operation' , '__ns_monitoring_param_ref' ,)

    _yang_name = 'scaling-criteria'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)
        self.__ns_monitoring_param_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                      yang_name="ns-monitoring-param-ref" , parent=self ,
                                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                                      register_paths=True ,
                                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                      defining_module='nsd' , yang_type='leafref' , is_config=True)
        self.__scale_out_threshold = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="scale-out-threshold" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint64' ,
            is_config=True)
        self.__scale_in_threshold = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="scale-in-threshold" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint64' ,
            is_config=True)
        self.__scale_out_relational_operation = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'GE': {} , u'LE': {} , u'EQ': {} , u'LT': {} , u'GT': {}} , ) ,
            default=unicode("GE") , is_leaf=True , yang_name="scale-out-relational-operation" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='manotypes:relational-operation-type' , is_config=True)
        self.__scale_in_relational_operation = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'GE': {} , u'LE': {} , u'EQ': {} , u'LT': {} , u'GT': {}} , ) ,
            default=unicode("LE") , is_leaf=True , yang_name="scale-in-relational-operation" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='manotypes:relational-operation-type' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'scaling-group-descriptor' , u'scaling-policy' , u'scaling-criteria']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/name (string)
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_scale_in_threshold(self):
        """
    Getter method for scale_in_threshold, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_in_threshold (uint64)

    YANG Description: Value below which scale-in requests are generated
    """
        return self.__scale_in_threshold

    def _set_scale_in_threshold(self , v , load=False):
        """
    Setter method for scale_in_threshold, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_in_threshold (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_in_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_in_threshold() directly.

    YANG Description: Value below which scale-in requests are generated
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="scale-in-threshold" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scale_in_threshold must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="scale-in-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint64', is_config=True)""" ,
            })

        self.__scale_in_threshold = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scale_in_threshold(self):
        self.__scale_in_threshold = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="scale-in-threshold" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint64' ,
            is_config=True)

    def _get_scale_in_relational_operation(self):
        """
    Getter method for scale_in_relational_operation, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_in_relational_operation (manotypes:relational-operation-type)

    YANG Description: The relational operator used to compare the monitoring param
against the scale-in-threshold.
    """
        return self.__scale_in_relational_operation

    def _set_scale_in_relational_operation(self , v , load=False):
        """
    Setter method for scale_in_relational_operation, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_in_relational_operation (manotypes:relational-operation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_in_relational_operation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_in_relational_operation() directly.

    YANG Description: The relational operator used to compare the monitoring param
against the scale-in-threshold.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'GE': {} , u'LE': {} , u'EQ': {} ,
                                                                           u'LT': {} , u'GT': {}} , ) ,
                             default=unicode("LE") , is_leaf=True , yang_name="scale-in-relational-operation" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='manotypes:relational-operation-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scale_in_relational_operation must be of a type compatible with manotypes:relational-operation-type""" ,
                'defined-type': "manotypes:relational-operation-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=unicode("LE"), is_leaf=True, yang_name="scale-in-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='manotypes:relational-operation-type', is_config=True)""" ,
            })

        self.__scale_in_relational_operation = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scale_in_relational_operation(self):
        self.__scale_in_relational_operation = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'GE': {} , u'LE': {} , u'EQ': {} , u'LT': {} , u'GT': {}} , ) ,
            default=unicode("LE") , is_leaf=True , yang_name="scale-in-relational-operation" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='manotypes:relational-operation-type' , is_config=True)

    def _get_scale_out_threshold(self):
        """
    Getter method for scale_out_threshold, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_out_threshold (uint64)

    YANG Description: Value above which scale-out requests are generated
    """
        return self.__scale_out_threshold

    def _set_scale_out_threshold(self , v , load=False):
        """
    Setter method for scale_out_threshold, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_out_threshold (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_out_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_out_threshold() directly.

    YANG Description: Value above which scale-out requests are generated
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True ,
                             yang_name="scale-out-threshold" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scale_out_threshold must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="scale-out-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint64', is_config=True)""" ,
            })

        self.__scale_out_threshold = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scale_out_threshold(self):
        self.__scale_out_threshold = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="scale-out-threshold" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint64' ,
            is_config=True)

    def _get_scale_out_relational_operation(self):
        """
    Getter method for scale_out_relational_operation, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_out_relational_operation (manotypes:relational-operation-type)

    YANG Description: The relational operator used to compare the monitoring param
against the scale-out-threshold.
    """
        return self.__scale_out_relational_operation

    def _set_scale_out_relational_operation(self , v , load=False):
        """
    Setter method for scale_out_relational_operation, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/scale_out_relational_operation (manotypes:relational-operation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_out_relational_operation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_out_relational_operation() directly.

    YANG Description: The relational operator used to compare the monitoring param
against the scale-out-threshold.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'GE': {} , u'LE': {} , u'EQ': {} ,
                                                                           u'LT': {} , u'GT': {}} , ) ,
                             default=unicode("GE") , is_leaf=True , yang_name="scale-out-relational-operation" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='manotypes:relational-operation-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scale_out_relational_operation must be of a type compatible with manotypes:relational-operation-type""" ,
                'defined-type': "manotypes:relational-operation-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'GE': {}, u'LE': {}, u'EQ': {}, u'LT': {}, u'GT': {}},), default=unicode("GE"), is_leaf=True, yang_name="scale-out-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='manotypes:relational-operation-type', is_config=True)""" ,
            })

        self.__scale_out_relational_operation = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scale_out_relational_operation(self):
        self.__scale_out_relational_operation = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'GE': {} , u'LE': {} , u'EQ': {} , u'LT': {} , u'GT': {}} , ) ,
            default=unicode("GE") , is_leaf=True , yang_name="scale-out-relational-operation" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='manotypes:relational-operation-type' , is_config=True)

    def _get_ns_monitoring_param_ref(self):
        """
    Getter method for ns_monitoring_param_ref, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/ns_monitoring_param_ref (leafref)

    YANG Description: Reference to the NS level monitoring parameter
that is aggregated
    """
        return self.__ns_monitoring_param_ref

    def _set_ns_monitoring_param_ref(self , v , load=False):
        """
    Setter method for ns_monitoring_param_ref, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria/ns_monitoring_param_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ns_monitoring_param_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ns_monitoring_param_ref() directly.

    YANG Description: Reference to the NS level monitoring parameter
that is aggregated
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="ns-monitoring-param-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ns_monitoring_param_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="ns-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__ns_monitoring_param_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ns_monitoring_param_ref(self):
        self.__ns_monitoring_param_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                      yang_name="ns-monitoring-param-ref" , parent=self ,
                                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                                      register_paths=True ,
                                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                      defining_module='nsd' , yang_type='leafref' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    scale_in_threshold = __builtin__.property(_get_scale_in_threshold , _set_scale_in_threshold)
    scale_in_relational_operation = __builtin__.property(_get_scale_in_relational_operation ,
                                                         _set_scale_in_relational_operation)
    scale_out_threshold = __builtin__.property(_get_scale_out_threshold , _set_scale_out_threshold)
    scale_out_relational_operation = __builtin__.property(_get_scale_out_relational_operation ,
                                                          _set_scale_out_relational_operation)
    ns_monitoring_param_ref = __builtin__.property(_get_ns_monitoring_param_ref , _set_ns_monitoring_param_ref)

    _pyangbind_elements = {'name': name , 'scale_in_threshold': scale_in_threshold ,
                           'scale_in_relational_operation': scale_in_relational_operation ,
                           'scale_out_threshold': scale_out_threshold ,
                           'scale_out_relational_operation': scale_out_relational_operation ,
                           'ns_monitoring_param_ref': ns_monitoring_param_ref , }


class yc_scaling_policy_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/scaling-group-descriptor/scaling-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__name' , '__scaling_type' , '__enabled' , '__scale_in_operation_type' ,
    '__scale_out_operation_type' , '__threshold_time' , '__cooldown_time' , '__scaling_criteria' ,)

    _yang_name = 'scaling-policy'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)
        self.__scale_out_operation_type = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'AND': {'value': 1} , u'OR': {'value': 2}} , ) ,
            default=unicode("OR") , is_leaf=True , yang_name="scale-out-operation-type" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='manotypes:scaling-criteria-operation' , is_config=True)
        self.__scale_in_operation_type = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'AND': {'value': 1} , u'OR': {'value': 2}} , ) ,
            default=unicode("AND") , is_leaf=True , yang_name="scale-in-operation-type" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='manotypes:scaling-criteria-operation' , is_config=True)
        self.__enabled = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="enabled" ,
                                      parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                      defining_module='nsd' , yang_type='boolean' , is_config=True)
        self.__cooldown_time = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="cooldown-time" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)
        self.__scaling_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                    restriction_arg={u'automatic': {'value': 2} ,
                                                                                     u'manual': {'value': 1}} , ) ,
                                           is_leaf=True , yang_name="scaling-type" , parent=self ,
                                           path_helper=self._path_helper , extmethods=self._extmethods ,
                                           register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                           defining_module='nsd' , yang_type='manotypes:scaling-policy-type' ,
                                           is_config=True)
        self.__threshold_time = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="threshold-time" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)
        self.__scaling_criteria = YANGDynClass(base=YANGListType("name" ,
                                                                 yc_scaling_criteria_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy_scaling_criteria ,
                                                                 yang_name="scaling-criteria" , parent=self ,
                                                                 is_container='list' , user_ordered=False ,
                                                                 path_helper=self._path_helper , yang_keys='name' ,
                                                                 extensions=None) , is_container='list' ,
                                               yang_name="scaling-criteria" , parent=self ,
                                               path_helper=self._path_helper , extmethods=self._extmethods ,
                                               register_paths=True , extensions=None ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                               defining_module='nsd' , yang_type='list' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'scaling-group-descriptor' , u'scaling-policy']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/name (string)

    YANG Description: Name of the scaling policy
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the scaling policy
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_scaling_type(self):
        """
    Getter method for scaling_type, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_type (manotypes:scaling-policy-type)

    YANG Description: Type of scaling
    """
        return self.__scaling_type

    def _set_scaling_type(self , v , load=False):
        """
    Setter method for scaling_type, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_type (manotypes:scaling-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_type() directly.

    YANG Description: Type of scaling
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'automatic': {'value': 2} ,
                                                                           u'manual': {'value': 1}} , ) , is_leaf=True ,
                             yang_name="scaling-type" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='manotypes:scaling-policy-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scaling_type must be of a type compatible with manotypes:scaling-policy-type""" ,
                'defined-type': "manotypes:scaling-policy-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'automatic': {'value': 2}, u'manual': {'value': 1}},), is_leaf=True, yang_name="scaling-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='manotypes:scaling-policy-type', is_config=True)""" ,
            })

        self.__scaling_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scaling_type(self):
        self.__scaling_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                    restriction_arg={u'automatic': {'value': 2} ,
                                                                                     u'manual': {'value': 1}} , ) ,
                                           is_leaf=True , yang_name="scaling-type" , parent=self ,
                                           path_helper=self._path_helper , extmethods=self._extmethods ,
                                           register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                           defining_module='nsd' , yang_type='manotypes:scaling-policy-type' ,
                                           is_config=True)

    def _get_enabled(self):
        """
    Getter method for enabled, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/enabled (boolean)

    YANG Description: Specifies if the scaling policy can be applied
    """
        return self.__enabled

    def _set_enabled(self , v , load=False):
        """
    Setter method for enabled, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Specifies if the scaling policy can be applied
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="enabled" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """enabled must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""" ,
            })

        self.__enabled = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_enabled(self):
        self.__enabled = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="enabled" ,
                                      parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                      defining_module='nsd' , yang_type='boolean' , is_config=True)

    def _get_scale_in_operation_type(self):
        """
    Getter method for scale_in_operation_type, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scale_in_operation_type (manotypes:scaling-criteria-operation)

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale in threshold condition has been met.
Defaults to AND
    """
        return self.__scale_in_operation_type

    def _set_scale_in_operation_type(self , v , load=False):
        """
    Setter method for scale_in_operation_type, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scale_in_operation_type (manotypes:scaling-criteria-operation)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_in_operation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_in_operation_type() directly.

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale in threshold condition has been met.
Defaults to AND
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'AND': {'value': 1} ,
                                                                           u'OR': {'value': 2}} , ) ,
                             default=unicode("AND") , is_leaf=True , yang_name="scale-in-operation-type" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='manotypes:scaling-criteria-operation' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scale_in_operation_type must be of a type compatible with manotypes:scaling-criteria-operation""" ,
                'defined-type': "manotypes:scaling-criteria-operation" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {'value': 1}, u'OR': {'value': 2}},), default=unicode("AND"), is_leaf=True, yang_name="scale-in-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='manotypes:scaling-criteria-operation', is_config=True)""" ,
            })

        self.__scale_in_operation_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scale_in_operation_type(self):
        self.__scale_in_operation_type = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'AND': {'value': 1} , u'OR': {'value': 2}} , ) ,
            default=unicode("AND") , is_leaf=True , yang_name="scale-in-operation-type" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='manotypes:scaling-criteria-operation' , is_config=True)

    def _get_scale_out_operation_type(self):
        """
    Getter method for scale_out_operation_type, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scale_out_operation_type (manotypes:scaling-criteria-operation)

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale out threshold condition has been met.
Defauls to OR
    """
        return self.__scale_out_operation_type

    def _set_scale_out_operation_type(self , v , load=False):
        """
    Setter method for scale_out_operation_type, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scale_out_operation_type (manotypes:scaling-criteria-operation)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_out_operation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_out_operation_type() directly.

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale out threshold condition has been met.
Defauls to OR
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'AND': {'value': 1} ,
                                                                           u'OR': {'value': 2}} , ) ,
                             default=unicode("OR") , is_leaf=True , yang_name="scale-out-operation-type" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='manotypes:scaling-criteria-operation' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scale_out_operation_type must be of a type compatible with manotypes:scaling-criteria-operation""" ,
                'defined-type': "manotypes:scaling-criteria-operation" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'AND': {'value': 1}, u'OR': {'value': 2}},), default=unicode("OR"), is_leaf=True, yang_name="scale-out-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='manotypes:scaling-criteria-operation', is_config=True)""" ,
            })

        self.__scale_out_operation_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scale_out_operation_type(self):
        self.__scale_out_operation_type = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'AND': {'value': 1} , u'OR': {'value': 2}} , ) ,
            default=unicode("OR") , is_leaf=True , yang_name="scale-out-operation-type" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='manotypes:scaling-criteria-operation' , is_config=True)

    def _get_threshold_time(self):
        """
    Getter method for threshold_time, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/threshold_time (uint32)

    YANG Description: The duration for which the criteria must hold true
    """
        return self.__threshold_time

    def _set_threshold_time(self , v , load=False):
        """
    Setter method for threshold_time, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/threshold_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold_time() directly.

    YANG Description: The duration for which the criteria must hold true
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , is_leaf=True , yang_name="threshold-time" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """threshold_time must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="threshold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""" ,
            })

        self.__threshold_time = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_threshold_time(self):
        self.__threshold_time = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="threshold-time" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)

    def _get_cooldown_time(self):
        """
    Getter method for cooldown_time, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/cooldown_time (uint32)

    YANG Description: The duration after a scaling-in/scaling-out action has been
triggered, for which there will be no further optional
    """
        return self.__cooldown_time

    def _set_cooldown_time(self , v , load=False):
        """
    Setter method for cooldown_time, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/cooldown_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cooldown_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cooldown_time() directly.

    YANG Description: The duration after a scaling-in/scaling-out action has been
triggered, for which there will be no further optional
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , is_leaf=True , yang_name="cooldown-time" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """cooldown_time must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cooldown-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""" ,
            })

        self.__cooldown_time = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_cooldown_time(self):
        self.__cooldown_time = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="cooldown-time" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)

    def _get_scaling_criteria(self):
        """
    Getter method for scaling_criteria, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria (list)

    YANG Description: list of conditions to be met for generating scaling
  requests
    """
        return self.__scaling_criteria

    def _set_scaling_criteria(self , v , load=False):
        """
    Setter method for scaling_criteria, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy/scaling_criteria (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_criteria is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_criteria() directly.

    YANG Description: list of conditions to be met for generating scaling
  requests
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" ,
                                                   yc_scaling_criteria_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy_scaling_criteria ,
                                                   yang_name="scaling-criteria" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="scaling-criteria" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scaling_criteria must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_scaling_criteria_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy_scaling_criteria, yang_name="scaling-criteria", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-criteria", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__scaling_criteria = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scaling_criteria(self):
        self.__scaling_criteria = YANGDynClass(base=YANGListType("name" ,
                                                                 yc_scaling_criteria_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy_scaling_criteria ,
                                                                 yang_name="scaling-criteria" , parent=self ,
                                                                 is_container='list' , user_ordered=False ,
                                                                 path_helper=self._path_helper , yang_keys='name' ,
                                                                 extensions=None) , is_container='list' ,
                                               yang_name="scaling-criteria" , parent=self ,
                                               path_helper=self._path_helper , extmethods=self._extmethods ,
                                               register_paths=True , extensions=None ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                               defining_module='nsd' , yang_type='list' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    scaling_type = __builtin__.property(_get_scaling_type , _set_scaling_type)
    enabled = __builtin__.property(_get_enabled , _set_enabled)
    scale_in_operation_type = __builtin__.property(_get_scale_in_operation_type , _set_scale_in_operation_type)
    scale_out_operation_type = __builtin__.property(_get_scale_out_operation_type , _set_scale_out_operation_type)
    threshold_time = __builtin__.property(_get_threshold_time , _set_threshold_time)
    cooldown_time = __builtin__.property(_get_cooldown_time , _set_cooldown_time)
    scaling_criteria = __builtin__.property(_get_scaling_criteria , _set_scaling_criteria)

    _pyangbind_elements = {'name': name , 'scaling_type': scaling_type , 'enabled': enabled ,
                           'scale_in_operation_type': scale_in_operation_type ,
                           'scale_out_operation_type': scale_out_operation_type , 'threshold_time': threshold_time ,
                           'cooldown_time': cooldown_time , 'scaling_criteria': scaling_criteria , }


class yc_vnfd_member_nsd__nsd_catalog_nsd_scaling_group_descriptor_vnfd_member(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/scaling-group-descriptor/vnfd-member. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VNFs in this scaling group
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__member_vnf_index_ref' , '__count' ,)

    _yang_name = 'vnfd-member'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            default=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32)(
                1) , is_leaf=True , yang_name="count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)
        self.__member_vnf_index_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" ,
                                                   parent=self , path_helper=self._path_helper ,
                                                   extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='leafref' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'scaling-group-descriptor' , u'vnfd-member']

    def _get_member_vnf_index_ref(self):
        """
    Getter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/vnfd_member/member_vnf_index_ref (leafref)

    YANG Description: member VNF index of this member VNF
    """
        return self.__member_vnf_index_ref

    def _set_member_vnf_index_ref(self , v , load=False):
        """
    Setter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/vnfd_member/member_vnf_index_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index_ref() directly.

    YANG Description: member VNF index of this member VNF
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """member_vnf_index_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__member_vnf_index_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_member_vnf_index_ref(self):
        self.__member_vnf_index_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" ,
                                                   parent=self , path_helper=self._path_helper ,
                                                   extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_count(self):
        """
    Getter method for count, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/vnfd_member/count (uint32)

    YANG Description: count of this member VNF  within this scaling group.
The count allows to define  the number of instances
when a scaling action targets this scaling group
    """
        return self.__count

    def _set_count(self , v , load=False):
        """
    Setter method for count, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/vnfd_member/count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.

    YANG Description: count of this member VNF  within this scaling group.
The count allows to define  the number of instances
when a scaling action targets this scaling group
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , default=RestrictedClassType(base_type=long ,
                                                                                                 restriction_dict={
                                                                                                     'range': [
                                                                                                         '0..4294967295']} ,
                                                                                                 int_size=32)(1) ,
                             is_leaf=True , yang_name="count" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """count must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""" ,
            })

        self.__count = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_count(self):
        self.__count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            default=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32)(
                1) , is_leaf=True , yang_name="count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)

    member_vnf_index_ref = __builtin__.property(_get_member_vnf_index_ref , _set_member_vnf_index_ref)
    count = __builtin__.property(_get_count , _set_count)

    _pyangbind_elements = {'member_vnf_index_ref': member_vnf_index_ref , 'count': count , }


class yc_scaling_config_action_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_config_action(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/scaling-group-descriptor/scaling-config-action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of scaling config actions
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__trigger' , '__ns_service_primitive_name_ref' ,)

    _yang_name = 'scaling-config-action'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__trigger = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                               restriction_arg={u'pre-scale-out': {'value': 3} ,
                                                                                u'pre-scale-in': {'value': 1} ,
                                                                                u'post-scale-in': {'value': 2} ,
                                                                                u'post-scale-out': {'value': 4}} , ) ,
                                      is_leaf=True , yang_name="trigger" , parent=self , path_helper=self._path_helper ,
                                      extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                      yang_type='manotypes:scaling-trigger' , is_config=True)
        self.__ns_service_primitive_name_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                            yang_name="ns-service-primitive-name-ref" , parent=self ,
                                                            path_helper=self._path_helper ,
                                                            extmethods=self._extmethods , register_paths=True ,
                                                            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                            defining_module='nsd' , yang_type='leafref' ,
                                                            is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'scaling-group-descriptor' , u'scaling-config-action']

    def _get_trigger(self):
        """
    Getter method for trigger, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_config_action/trigger (manotypes:scaling-trigger)

    YANG Description: scaling trigger
    """
        return self.__trigger

    def _set_trigger(self , v , load=False):
        """
    Setter method for trigger, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_config_action/trigger (manotypes:scaling-trigger)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trigger is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trigger() directly.

    YANG Description: scaling trigger
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'pre-scale-out': {'value': 3} ,
                                                                           u'pre-scale-in': {'value': 1} ,
                                                                           u'post-scale-in': {'value': 2} ,
                                                                           u'post-scale-out': {'value': 4}} , ) ,
                             is_leaf=True , yang_name="trigger" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='manotypes:scaling-trigger' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """trigger must be of a type compatible with manotypes:scaling-trigger""" ,
                'defined-type': "manotypes:scaling-trigger" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'pre-scale-out': {'value': 3}, u'pre-scale-in': {'value': 1}, u'post-scale-in': {'value': 2}, u'post-scale-out': {'value': 4}},), is_leaf=True, yang_name="trigger", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='manotypes:scaling-trigger', is_config=True)""" ,
            })

        self.__trigger = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_trigger(self):
        self.__trigger = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                               restriction_arg={u'pre-scale-out': {'value': 3} ,
                                                                                u'pre-scale-in': {'value': 1} ,
                                                                                u'post-scale-in': {'value': 2} ,
                                                                                u'post-scale-out': {'value': 4}} , ) ,
                                      is_leaf=True , yang_name="trigger" , parent=self , path_helper=self._path_helper ,
                                      extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                      yang_type='manotypes:scaling-trigger' , is_config=True)

    def _get_ns_service_primitive_name_ref(self):
        """
    Getter method for ns_service_primitive_name_ref, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_config_action/ns_service_primitive_name_ref (leafref)

    YANG Description: Reference to the NS service primitive
    """
        return self.__ns_service_primitive_name_ref

    def _set_ns_service_primitive_name_ref(self , v , load=False):
        """
    Setter method for ns_service_primitive_name_ref, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_config_action/ns_service_primitive_name_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ns_service_primitive_name_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ns_service_primitive_name_ref() directly.

    YANG Description: Reference to the NS service primitive
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="ns-service-primitive-name-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ns_service_primitive_name_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="ns-service-primitive-name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__ns_service_primitive_name_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ns_service_primitive_name_ref(self):
        self.__ns_service_primitive_name_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                            yang_name="ns-service-primitive-name-ref" , parent=self ,
                                                            path_helper=self._path_helper ,
                                                            extmethods=self._extmethods , register_paths=True ,
                                                            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                            defining_module='nsd' , yang_type='leafref' ,
                                                            is_config=True)

    trigger = __builtin__.property(_get_trigger , _set_trigger)
    ns_service_primitive_name_ref = __builtin__.property(_get_ns_service_primitive_name_ref ,
                                                         _set_ns_service_primitive_name_ref)

    _pyangbind_elements = {'trigger': trigger , 'ns_service_primitive_name_ref': ns_service_primitive_name_ref , }


class yc_scaling_group_descriptor_nsd__nsd_catalog_nsd_scaling_group_descriptor(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/scaling-group-descriptor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: scaling group descriptor within this network service.
The scaling group defines a group of VNFs,
and the ratio of VNFs in the network service
that is used as target for scaling action
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__name' , '__scaling_policy' , '__vnfd_member' , '__min_instance_count' ,
    '__max_instance_count' , '__scaling_config_action' ,)

    _yang_name = 'scaling-group-descriptor'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)
        self.__max_instance_count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            default=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32)(
                10) , is_leaf=True , yang_name="max-instance-count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)
        self.__min_instance_count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            default=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32)(
                0) , is_leaf=True , yang_name="min-instance-count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)
        self.__scaling_policy = YANGDynClass(
            base=YANGListType("name" , yc_scaling_policy_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy ,
                              yang_name="scaling-policy" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="scaling-policy" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__scaling_config_action = YANGDynClass(base=YANGListType("trigger" ,
                                                                      yc_scaling_config_action_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_config_action ,
                                                                      yang_name="scaling-config-action" , parent=self ,
                                                                      is_container='list' , user_ordered=False ,
                                                                      path_helper=self._path_helper ,
                                                                      yang_keys='trigger' , extensions=None) ,
                                                    is_container='list' , yang_name="scaling-config-action" ,
                                                    parent=self , path_helper=self._path_helper ,
                                                    extmethods=self._extmethods , register_paths=True ,
                                                    extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                    defining_module='nsd' , yang_type='list' , is_config=True)
        self.__vnfd_member = YANGDynClass(base=YANGListType("member_vnf_index_ref" ,
                                                            yc_vnfd_member_nsd__nsd_catalog_nsd_scaling_group_descriptor_vnfd_member ,
                                                            yang_name="vnfd-member" , parent=self ,
                                                            is_container='list' , user_ordered=False ,
                                                            path_helper=self._path_helper ,
                                                            yang_keys='member-vnf-index-ref' , extensions=None) ,
                                          is_container='list' , yang_name="vnfd-member" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , extensions=None ,
                                          namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                          yang_type='list' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'scaling-group-descriptor']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/name (string)

    YANG Description: Name of this scaling group.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of this scaling group.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_scaling_policy(self):
        """
    Getter method for scaling_policy, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy (list)
    """
        return self.__scaling_policy

    def _set_scaling_policy(self , v , load=False):
        """
    Setter method for scaling_policy, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_policy (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_policy() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" ,
                                                   yc_scaling_policy_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy ,
                                                   yang_name="scaling-policy" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="scaling-policy" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scaling_policy must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_scaling_policy_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy, yang_name="scaling-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__scaling_policy = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scaling_policy(self):
        self.__scaling_policy = YANGDynClass(
            base=YANGListType("name" , yc_scaling_policy_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_policy ,
                              yang_name="scaling-policy" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="scaling-policy" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    def _get_vnfd_member(self):
        """
    Getter method for vnfd_member, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/vnfd_member (list)

    YANG Description: List of VNFs in this scaling group
    """
        return self.__vnfd_member

    def _set_vnfd_member(self , v , load=False):
        """
    Setter method for vnfd_member, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/vnfd_member (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_member is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_member() directly.

    YANG Description: List of VNFs in this scaling group
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("member_vnf_index_ref" ,
                                                   yc_vnfd_member_nsd__nsd_catalog_nsd_scaling_group_descriptor_vnfd_member ,
                                                   yang_name="vnfd-member" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='member-vnf-index-ref' , extensions=None) ,
                             is_container='list' , yang_name="vnfd-member" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_member must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("member_vnf_index_ref",yc_vnfd_member_nsd__nsd_catalog_nsd_scaling_group_descriptor_vnfd_member, yang_name="vnfd-member", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref', extensions=None), is_container='list', yang_name="vnfd-member", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__vnfd_member = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_member(self):
        self.__vnfd_member = YANGDynClass(base=YANGListType("member_vnf_index_ref" ,
                                                            yc_vnfd_member_nsd__nsd_catalog_nsd_scaling_group_descriptor_vnfd_member ,
                                                            yang_name="vnfd-member" , parent=self ,
                                                            is_container='list' , user_ordered=False ,
                                                            path_helper=self._path_helper ,
                                                            yang_keys='member-vnf-index-ref' , extensions=None) ,
                                          is_container='list' , yang_name="vnfd-member" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , extensions=None ,
                                          namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                          yang_type='list' , is_config=True)

    def _get_min_instance_count(self):
        """
    Getter method for min_instance_count, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/min_instance_count (uint32)

    YANG Description: Minimum instances of the scaling group which are allowed.
These instances are created by default when the network service
is instantiated.
    """
        return self.__min_instance_count

    def _set_min_instance_count(self , v , load=False):
        """
    Setter method for min_instance_count, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/min_instance_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_instance_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_instance_count() directly.

    YANG Description: Minimum instances of the scaling group which are allowed.
These instances are created by default when the network service
is instantiated.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , default=RestrictedClassType(base_type=long ,
                                                                                                 restriction_dict={
                                                                                                     'range': [
                                                                                                         '0..4294967295']} ,
                                                                                                 int_size=32)(0) ,
                             is_leaf=True , yang_name="min-instance-count" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """min_instance_count must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="min-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""" ,
            })

        self.__min_instance_count = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_min_instance_count(self):
        self.__min_instance_count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            default=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32)(
                0) , is_leaf=True , yang_name="min-instance-count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)

    def _get_max_instance_count(self):
        """
    Getter method for max_instance_count, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/max_instance_count (uint32)

    YANG Description: Maximum instances of this scaling group that are allowed
in a single network service. The network service scaling
will fail, when the number of service group instances
exceed the max-instance-count specified.
    """
        return self.__max_instance_count

    def _set_max_instance_count(self , v , load=False):
        """
    Setter method for max_instance_count, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/max_instance_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_instance_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_instance_count() directly.

    YANG Description: Maximum instances of this scaling group that are allowed
in a single network service. The network service scaling
will fail, when the number of service group instances
exceed the max-instance-count specified.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , default=RestrictedClassType(base_type=long ,
                                                                                                 restriction_dict={
                                                                                                     'range': [
                                                                                                         '0..4294967295']} ,
                                                                                                 int_size=32)(10) ,
                             is_leaf=True , yang_name="max-instance-count" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """max_instance_count must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(10), is_leaf=True, yang_name="max-instance-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""" ,
            })

        self.__max_instance_count = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_max_instance_count(self):
        self.__max_instance_count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            default=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32)(
                10) , is_leaf=True , yang_name="max-instance-count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)

    def _get_scaling_config_action(self):
        """
    Getter method for scaling_config_action, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_config_action (list)

    YANG Description: List of scaling config actions
    """
        return self.__scaling_config_action

    def _set_scaling_config_action(self , v , load=False):
        """
    Setter method for scaling_config_action, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor/scaling_config_action (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_config_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_config_action() directly.

    YANG Description: List of scaling config actions
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("trigger" ,
                                                   yc_scaling_config_action_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_config_action ,
                                                   yang_name="scaling-config-action" , parent=self ,
                                                   is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='trigger' ,
                                                   extensions=None) , is_container='list' ,
                             yang_name="scaling-config-action" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scaling_config_action must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("trigger",yc_scaling_config_action_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_config_action, yang_name="scaling-config-action", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='trigger', extensions=None), is_container='list', yang_name="scaling-config-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__scaling_config_action = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scaling_config_action(self):
        self.__scaling_config_action = YANGDynClass(base=YANGListType("trigger" ,
                                                                      yc_scaling_config_action_nsd__nsd_catalog_nsd_scaling_group_descriptor_scaling_config_action ,
                                                                      yang_name="scaling-config-action" , parent=self ,
                                                                      is_container='list' , user_ordered=False ,
                                                                      path_helper=self._path_helper ,
                                                                      yang_keys='trigger' , extensions=None) ,
                                                    is_container='list' , yang_name="scaling-config-action" ,
                                                    parent=self , path_helper=self._path_helper ,
                                                    extmethods=self._extmethods , register_paths=True ,
                                                    extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                    defining_module='nsd' , yang_type='list' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    scaling_policy = __builtin__.property(_get_scaling_policy , _set_scaling_policy)
    vnfd_member = __builtin__.property(_get_vnfd_member , _set_vnfd_member)
    min_instance_count = __builtin__.property(_get_min_instance_count , _set_min_instance_count)
    max_instance_count = __builtin__.property(_get_max_instance_count , _set_max_instance_count)
    scaling_config_action = __builtin__.property(_get_scaling_config_action , _set_scaling_config_action)

    _pyangbind_elements = {'name': name , 'scaling_policy': scaling_policy , 'vnfd_member': vnfd_member ,
                           'min_instance_count': min_instance_count , 'max_instance_count': max_instance_count ,
                           'scaling_config_action': scaling_config_action , }


class yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vnffgd_rsp_vnfd_connection_point_ref(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vnffgd/rsp/vnfd-connection-point-ref. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of references to connection points.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__member_vnf_index_ref' , '__order' , '__vnfd_id_ref' ,
                 '__vnfd_ingress_connection_point_ref' , '__vnfd_egress_connection_point_ref' ,)

    _yang_name = 'vnfd-connection-point-ref'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnfd_ingress_connection_point_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                                yang_name="vnfd-ingress-connection-point-ref" ,
                                                                parent=self , path_helper=self._path_helper ,
                                                                extmethods=self._extmethods , register_paths=True ,
                                                                namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                                defining_module='nsd' , yang_type='string' ,
                                                                is_config=True)
        self.__member_vnf_index_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" ,
                                                   parent=self , path_helper=self._path_helper ,
                                                   extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='leafref' , is_config=True)
        self.__order = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="order" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint8' , is_config=True)
        self.__vnfd_egress_connection_point_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                               yang_name="vnfd-egress-connection-point-ref" ,
                                                               parent=self , path_helper=self._path_helper ,
                                                               extmethods=self._extmethods , register_paths=True ,
                                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                               defining_module='nsd' , yang_type='string' ,
                                                               is_config=True)
        self.__vnfd_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='leafref' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'vnffgd' , u'rsp' , u'vnfd-connection-point-ref']

    def _get_member_vnf_index_ref(self):
        """
    Getter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/member_vnf_index_ref (leafref)

    YANG Description: Reference to member-vnf within constituent-vnfds
    """
        return self.__member_vnf_index_ref

    def _set_member_vnf_index_ref(self , v , load=False):
        """
    Setter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/member_vnf_index_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index_ref() directly.

    YANG Description: Reference to member-vnf within constituent-vnfds
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """member_vnf_index_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__member_vnf_index_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_member_vnf_index_ref(self):
        self.__member_vnf_index_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" ,
                                                   parent=self , path_helper=self._path_helper ,
                                                   extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_order(self):
        """
    Getter method for order, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/order (uint8)

    YANG Description: A number that denotes the order of a VNF in a chain
    """
        return self.__order

    def _set_order(self , v , load=False):
        """
    Setter method for order, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/order (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_order is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_order() directly.

    YANG Description: A number that denotes the order of a VNF in a chain
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} ,
                                                          int_size=8) , is_leaf=True , yang_name="order" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='uint8' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """order must be of a type compatible with uint8""" ,
                'defined-type': "uint8" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="order", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint8', is_config=True)""" ,
            })

        self.__order = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_order(self):
        self.__order = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="order" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint8' , is_config=True)

    def _get_vnfd_id_ref(self):
        """
    Getter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/vnfd_id_ref (leafref)

    YANG Description: A reference to a vnfd. This is a
   leafref to path:
       ../../../../nsd:constituent-vnfd
       + [nsd:id = current()/../nsd:id-ref]
       + /nsd:vnfd-id-ref
    """
        return self.__vnfd_id_ref

    def _set_vnfd_id_ref(self , v , load=False):
        """
    Setter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/vnfd_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id_ref() directly.

    YANG Description: A reference to a vnfd. This is a
   leafref to path:
       ../../../../nsd:constituent-vnfd
       + [nsd:id = current()/../nsd:id-ref]
       + /nsd:vnfd-id-ref
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_id_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vnfd_id_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_id_ref(self):
        self.__vnfd_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_vnfd_ingress_connection_point_ref(self):
        """
    Getter method for vnfd_ingress_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/vnfd_ingress_connection_point_ref (string)

    YANG Description: A reference to a connection point name
   in a vnfd. This is a leafref to path:
       /vnfd:vnfd-catalog/vnfd:vnfd
       + [vnfd:id = current()/../nsd:vnfd-id-ref]
       + /vnfd:connection-point/vnfd:name
   NOTE: An issue with confd is preventing the
   use of xpath. Seems to be an issue with leafref
   to leafref, whose target is in a different module.
   Once that is resolved this will switched to use
   leafref
    """
        return self.__vnfd_ingress_connection_point_ref

    def _set_vnfd_ingress_connection_point_ref(self , v , load=False):
        """
    Setter method for vnfd_ingress_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/vnfd_ingress_connection_point_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_ingress_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_ingress_connection_point_ref() directly.

    YANG Description: A reference to a connection point name
   in a vnfd. This is a leafref to path:
       /vnfd:vnfd-catalog/vnfd:vnfd
       + [vnfd:id = current()/../nsd:vnfd-id-ref]
       + /vnfd:connection-point/vnfd:name
   NOTE: An issue with confd is preventing the
   use of xpath. Seems to be an issue with leafref
   to leafref, whose target is in a different module.
   Once that is resolved this will switched to use
   leafref
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnfd-ingress-connection-point-ref" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_ingress_connection_point_ref must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnfd-ingress-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__vnfd_ingress_connection_point_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_ingress_connection_point_ref(self):
        self.__vnfd_ingress_connection_point_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                                yang_name="vnfd-ingress-connection-point-ref" ,
                                                                parent=self , path_helper=self._path_helper ,
                                                                extmethods=self._extmethods , register_paths=True ,
                                                                namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                                defining_module='nsd' , yang_type='string' ,
                                                                is_config=True)

    def _get_vnfd_egress_connection_point_ref(self):
        """
    Getter method for vnfd_egress_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/vnfd_egress_connection_point_ref (string)

    YANG Description: A reference to a connection point name
   in a vnfd. This is a leafref to path:
       /vnfd:vnfd-catalog/vnfd:vnfd
       + [vnfd:id = current()/../nsd:vnfd-id-ref]
       + /vnfd:connection-point/vnfd:name
   NOTE: An issue with confd is preventing the
   use of xpath. Seems to be an issue with leafref
   to leafref, whose target is in a different module.
   Once that is resolved this will switched to use
   leafref
    """
        return self.__vnfd_egress_connection_point_ref

    def _set_vnfd_egress_connection_point_ref(self , v , load=False):
        """
    Setter method for vnfd_egress_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref/vnfd_egress_connection_point_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_egress_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_egress_connection_point_ref() directly.

    YANG Description: A reference to a connection point name
   in a vnfd. This is a leafref to path:
       /vnfd:vnfd-catalog/vnfd:vnfd
       + [vnfd:id = current()/../nsd:vnfd-id-ref]
       + /vnfd:connection-point/vnfd:name
   NOTE: An issue with confd is preventing the
   use of xpath. Seems to be an issue with leafref
   to leafref, whose target is in a different module.
   Once that is resolved this will switched to use
   leafref
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnfd-egress-connection-point-ref" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_egress_connection_point_ref must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnfd-egress-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__vnfd_egress_connection_point_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_egress_connection_point_ref(self):
        self.__vnfd_egress_connection_point_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                               yang_name="vnfd-egress-connection-point-ref" ,
                                                               parent=self , path_helper=self._path_helper ,
                                                               extmethods=self._extmethods , register_paths=True ,
                                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                               defining_module='nsd' , yang_type='string' ,
                                                               is_config=True)

    member_vnf_index_ref = __builtin__.property(_get_member_vnf_index_ref , _set_member_vnf_index_ref)
    order = __builtin__.property(_get_order , _set_order)
    vnfd_id_ref = __builtin__.property(_get_vnfd_id_ref , _set_vnfd_id_ref)
    vnfd_ingress_connection_point_ref = __builtin__.property(_get_vnfd_ingress_connection_point_ref ,
                                                             _set_vnfd_ingress_connection_point_ref)
    vnfd_egress_connection_point_ref = __builtin__.property(_get_vnfd_egress_connection_point_ref ,
                                                            _set_vnfd_egress_connection_point_ref)

    _pyangbind_elements = {'member_vnf_index_ref': member_vnf_index_ref , 'order': order , 'vnfd_id_ref': vnfd_id_ref ,
                           'vnfd_ingress_connection_point_ref': vnfd_ingress_connection_point_ref ,
                           'vnfd_egress_connection_point_ref': vnfd_egress_connection_point_ref , }


class yc_rsp_nsd__nsd_catalog_nsd_vnffgd_rsp(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vnffgd/rsp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Rendered Service Paths (RSP).
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__id' , '__name' , '__vnfd_connection_point_ref' ,)

    _yang_name = 'rsp'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnfd_connection_point_ref = YANGDynClass(base=YANGListType("member_vnf_index_ref" ,
                                                                          yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vnffgd_rsp_vnfd_connection_point_ref ,
                                                                          yang_name="vnfd-connection-point-ref" ,
                                                                          parent=self , is_container='list' ,
                                                                          user_ordered=False ,
                                                                          path_helper=self._path_helper ,
                                                                          yang_keys='member-vnf-index-ref' ,
                                                                          extensions=None) , is_container='list' ,
                                                        yang_name="vnfd-connection-point-ref" , parent=self ,
                                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                                        register_paths=True , extensions=None ,
                                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                        defining_module='nsd' , yang_type='list' , is_config=True)
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                 defining_module='nsd' , yang_type='string' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'vnffgd' , u'rsp']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/id (string)

    YANG Description: Identifier for the RSP.
    """
        return self.__id

    def _set_id(self , v , load=False):
        """
    Setter method for id, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the RSP.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                 defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/name (string)

    YANG Description: RSP name.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: RSP name.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)

    def _get_vnfd_connection_point_ref(self):
        """
    Getter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref (list)

    YANG Description: A list of references to connection points.
    """
        return self.__vnfd_connection_point_ref

    def _set_vnfd_connection_point_ref(self , v , load=False):
        """
    Setter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp/vnfd_connection_point_ref (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_connection_point_ref() directly.

    YANG Description: A list of references to connection points.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("member_vnf_index_ref" ,
                                                   yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vnffgd_rsp_vnfd_connection_point_ref ,
                                                   yang_name="vnfd-connection-point-ref" , parent=self ,
                                                   is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='member-vnf-index-ref' ,
                                                   extensions=None) , is_container='list' ,
                             yang_name="vnfd-connection-point-ref" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_connection_point_ref must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("member_vnf_index_ref",yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vnffgd_rsp_vnfd_connection_point_ref, yang_name="vnfd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref', extensions=None), is_container='list', yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__vnfd_connection_point_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_connection_point_ref(self):
        self.__vnfd_connection_point_ref = YANGDynClass(base=YANGListType("member_vnf_index_ref" ,
                                                                          yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vnffgd_rsp_vnfd_connection_point_ref ,
                                                                          yang_name="vnfd-connection-point-ref" ,
                                                                          parent=self , is_container='list' ,
                                                                          user_ordered=False ,
                                                                          path_helper=self._path_helper ,
                                                                          yang_keys='member-vnf-index-ref' ,
                                                                          extensions=None) , is_container='list' ,
                                                        yang_name="vnfd-connection-point-ref" , parent=self ,
                                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                                        register_paths=True , extensions=None ,
                                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                        defining_module='nsd' , yang_type='list' , is_config=True)

    id = __builtin__.property(_get_id , _set_id)
    name = __builtin__.property(_get_name , _set_name)
    vnfd_connection_point_ref = __builtin__.property(_get_vnfd_connection_point_ref , _set_vnfd_connection_point_ref)

    _pyangbind_elements = {'id': id , 'name': name , 'vnfd_connection_point_ref': vnfd_connection_point_ref , }


class yc_match_attributes_nsd__nsd_catalog_nsd_vnffgd_classifier_match_attributes(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vnffgd/classifier/match-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of match attributes.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__id' , '__ip_proto' , '__source_ip_address' , '__destination_ip_address' ,
    '__source_port' , '__destination_port' ,)

    _yang_name = 'match-attributes'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__source_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                                      RestrictedClassType(base_type=unicode , restriction_dict={
                                                          'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                                is_leaf=True , yang_name="source-ip-address" , parent=self ,
                                                path_helper=self._path_helper , extmethods=self._extmethods ,
                                                register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                defining_module='nsd' , yang_type='inet:ip-address' , is_config=True)
        self.__destination_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                                           RestrictedClassType(base_type=unicode , restriction_dict={
                                                               'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                                     is_leaf=True , yang_name="destination-ip-address" , parent=self ,
                                                     path_helper=self._path_helper , extmethods=self._extmethods ,
                                                     register_paths=True ,
                                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                     defining_module='nsd' , yang_type='inet:ip-address' ,
                                                     is_config=True)
        self.__source_port = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
            restriction_dict={'range': [u'0..65535']}) , is_leaf=True , yang_name="source-port" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='inet:port-number' , is_config=True)
        self.__ip_proto = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="ip-proto" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint8' , is_config=True)
        self.__destination_port = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
            restriction_dict={'range': [u'0..65535']}) , is_leaf=True , yang_name="destination-port" , parent=self ,
                                               path_helper=self._path_helper , extmethods=self._extmethods ,
                                               register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                               defining_module='nsd' , yang_type='inet:port-number' , is_config=True)
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                 defining_module='nsd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'vnffgd' , u'classifier' , u'match-attributes']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/id (string)

    YANG Description: Identifier for the classifier match attribute rule.
    """
        return self.__id

    def _set_id(self , v , load=False):
        """
    Setter method for id, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the classifier match attribute rule.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                 defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_ip_proto(self):
        """
    Getter method for ip_proto, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/ip_proto (uint8)

    YANG Description: IP Protocol.
    """
        return self.__ip_proto

    def _set_ip_proto(self , v , load=False):
        """
    Setter method for ip_proto, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/ip_proto (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_proto is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_proto() directly.

    YANG Description: IP Protocol.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} ,
                                                          int_size=8) , is_leaf=True , yang_name="ip-proto" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='uint8' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ip_proto must be of a type compatible with uint8""" ,
                'defined-type': "uint8" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ip-proto", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint8', is_config=True)""" ,
            })

        self.__ip_proto = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ip_proto(self):
        self.__ip_proto = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="ip-proto" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint8' , is_config=True)

    def _get_source_ip_address(self):
        """
    Getter method for source_ip_address, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/source_ip_address (inet:ip-address)

    YANG Description: Source IP address.
    """
        return self.__source_ip_address

    def _set_source_ip_address(self , v , load=False):
        """
    Setter method for source_ip_address, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/source_ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_ip_address() directly.

    YANG Description: Source IP address.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=[RestrictedClassType(base_type=unicode , restriction_dict={
                'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                       RestrictedClassType(base_type=unicode , restriction_dict={
                                           'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                             is_leaf=True , yang_name="source-ip-address" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='inet:ip-address' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """source_ip_address must be of a type compatible with inet:ip-address""" ,
                'defined-type': "inet:ip-address" ,
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="source-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)""" ,
            })

        self.__source_ip_address = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_source_ip_address(self):
        self.__source_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                                      RestrictedClassType(base_type=unicode , restriction_dict={
                                                          'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                                is_leaf=True , yang_name="source-ip-address" , parent=self ,
                                                path_helper=self._path_helper , extmethods=self._extmethods ,
                                                register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                defining_module='nsd' , yang_type='inet:ip-address' , is_config=True)

    def _get_destination_ip_address(self):
        """
    Getter method for destination_ip_address, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/destination_ip_address (inet:ip-address)

    YANG Description: Destination IP address.
    """
        return self.__destination_ip_address

    def _set_destination_ip_address(self , v , load=False):
        """
    Setter method for destination_ip_address, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/destination_ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_ip_address() directly.

    YANG Description: Destination IP address.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=[RestrictedClassType(base_type=unicode , restriction_dict={
                'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                       RestrictedClassType(base_type=unicode , restriction_dict={
                                           'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                             is_leaf=True , yang_name="destination-ip-address" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='inet:ip-address' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """destination_ip_address must be of a type compatible with inet:ip-address""" ,
                'defined-type': "inet:ip-address" ,
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="destination-ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)""" ,
            })

        self.__destination_ip_address = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_destination_ip_address(self):
        self.__destination_ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                                           RestrictedClassType(base_type=unicode , restriction_dict={
                                                               'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                                     is_leaf=True , yang_name="destination-ip-address" , parent=self ,
                                                     path_helper=self._path_helper , extmethods=self._extmethods ,
                                                     register_paths=True ,
                                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                     defining_module='nsd' , yang_type='inet:ip-address' ,
                                                     is_config=True)

    def _get_source_port(self):
        """
    Getter method for source_port, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/source_port (inet:port-number)

    YANG Description: Source port number.
    """
        return self.__source_port

    def _set_source_port(self , v , load=False):
        """
    Setter method for source_port, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/source_port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_port() directly.

    YANG Description: Source port number.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(
                base_type=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
                restriction_dict={'range': [u'0..65535']}) , is_leaf=True , yang_name="source-port" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='inet:port-number' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """source_port must be of a type compatible with inet:port-number""" ,
                'defined-type': "inet:port-number" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="source-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='inet:port-number', is_config=True)""" ,
            })

        self.__source_port = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_source_port(self):
        self.__source_port = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
            restriction_dict={'range': [u'0..65535']}) , is_leaf=True , yang_name="source-port" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='inet:port-number' , is_config=True)

    def _get_destination_port(self):
        """
    Getter method for destination_port, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/destination_port (inet:port-number)

    YANG Description: Destination port number.
    """
        return self.__destination_port

    def _set_destination_port(self , v , load=False):
        """
    Setter method for destination_port, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes/destination_port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination_port() directly.

    YANG Description: Destination port number.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(
                base_type=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
                restriction_dict={'range': [u'0..65535']}) , is_leaf=True , yang_name="destination-port" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='inet:port-number' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """destination_port must be of a type compatible with inet:port-number""" ,
                'defined-type': "inet:port-number" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': [u'0..65535']}), is_leaf=True, yang_name="destination-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='inet:port-number', is_config=True)""" ,
            })

        self.__destination_port = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_destination_port(self):
        self.__destination_port = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..65535']} , int_size=16) ,
            restriction_dict={'range': [u'0..65535']}) , is_leaf=True , yang_name="destination-port" , parent=self ,
                                               path_helper=self._path_helper , extmethods=self._extmethods ,
                                               register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                               defining_module='nsd' , yang_type='inet:port-number' , is_config=True)

    id = __builtin__.property(_get_id , _set_id)
    ip_proto = __builtin__.property(_get_ip_proto , _set_ip_proto)
    source_ip_address = __builtin__.property(_get_source_ip_address , _set_source_ip_address)
    destination_ip_address = __builtin__.property(_get_destination_ip_address , _set_destination_ip_address)
    source_port = __builtin__.property(_get_source_port , _set_source_port)
    destination_port = __builtin__.property(_get_destination_port , _set_destination_port)

    _pyangbind_elements = {'id': id , 'ip_proto': ip_proto , 'source_ip_address': source_ip_address ,
                           'destination_ip_address': destination_ip_address , 'source_port': source_port ,
                           'destination_port': destination_port , }


class yc_classifier_nsd__nsd_catalog_nsd_vnffgd_classifier(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vnffgd/classifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of classifier rules.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__id' , '__name' , '__rsp_id_ref' , '__match_attributes' ,
                 '__member_vnf_index_ref' , '__vnfd_id_ref' , '__vnfd_connection_point_ref' ,)

    _yang_name = 'classifier'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnfd_connection_point_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                        yang_name="vnfd-connection-point-ref" , parent=self ,
                                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                                        register_paths=True ,
                                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                        defining_module='nsd' , yang_type='string' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)
        self.__vnfd_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='leafref' , is_config=True)
        self.__member_vnf_index_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" ,
                                                   parent=self , path_helper=self._path_helper ,
                                                   extmethods=self._extmethods , register_paths=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='leafref' , is_config=True)
        self.__rsp_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="rsp-id-ref" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                         defining_module='nsd' , yang_type='leafref' , is_config=True)
        self.__match_attributes = YANGDynClass(
            base=YANGListType("id" , yc_match_attributes_nsd__nsd_catalog_nsd_vnffgd_classifier_match_attributes ,
                              yang_name="match-attributes" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='id' , extensions=None) , is_container='list' ,
            yang_name="match-attributes" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='list' , is_config=True)
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                 defining_module='nsd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'vnffgd' , u'classifier']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/id (string)

    YANG Description: Identifier for the classifier rule.
    """
        return self.__id

    def _set_id(self , v , load=False):
        """
    Setter method for id, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the classifier rule.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                 defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/name (string)

    YANG Description: Name of the classifier.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the classifier.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)

    def _get_rsp_id_ref(self):
        """
    Getter method for rsp_id_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/rsp_id_ref (leafref)

    YANG Description: A reference to the RSP.
    """
        return self.__rsp_id_ref

    def _set_rsp_id_ref(self , v , load=False):
        """
    Setter method for rsp_id_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/rsp_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rsp_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rsp_id_ref() directly.

    YANG Description: A reference to the RSP.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="rsp-id-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """rsp_id_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="rsp-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__rsp_id_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_rsp_id_ref(self):
        self.__rsp_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="rsp-id-ref" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                         defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_match_attributes(self):
        """
    Getter method for match_attributes, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes (list)

    YANG Description: List of match attributes.
    """
        return self.__match_attributes

    def _set_match_attributes(self , v , load=False):
        """
    Setter method for match_attributes, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/match_attributes (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_match_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_match_attributes() directly.

    YANG Description: List of match attributes.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("id" ,
                                                   yc_match_attributes_nsd__nsd_catalog_nsd_vnffgd_classifier_match_attributes ,
                                                   yang_name="match-attributes" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper , yang_keys='id' ,
                                                   extensions=None) , is_container='list' ,
                             yang_name="match-attributes" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """match_attributes must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_match_attributes_nsd__nsd_catalog_nsd_vnffgd_classifier_match_attributes, yang_name="match-attributes", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="match-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__match_attributes = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_match_attributes(self):
        self.__match_attributes = YANGDynClass(
            base=YANGListType("id" , yc_match_attributes_nsd__nsd_catalog_nsd_vnffgd_classifier_match_attributes ,
                              yang_name="match-attributes" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='id' , extensions=None) , is_container='list' ,
            yang_name="match-attributes" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='list' , is_config=True)

    def _get_member_vnf_index_ref(self):
        """
    Getter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/member_vnf_index_ref (leafref)

    YANG Description: Reference to member-vnf within constituent-vnfds
    """
        return self.__member_vnf_index_ref

    def _set_member_vnf_index_ref(self , v , load=False):
        """
    Setter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/member_vnf_index_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index_ref() directly.

    YANG Description: Reference to member-vnf within constituent-vnfds
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """member_vnf_index_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__member_vnf_index_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_member_vnf_index_ref(self):
        self.__member_vnf_index_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" ,
                                                   parent=self , path_helper=self._path_helper ,
                                                   extmethods=self._extmethods , register_paths=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_vnfd_id_ref(self):
        """
    Getter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/vnfd_id_ref (leafref)

    YANG Description: A reference to a vnfd. This is a
   leafref to path:
       ../../../nsd:constituent-vnfd
       + [nsd:id = current()/../nsd:id-ref]
       + /nsd:vnfd-id-ref
    """
        return self.__vnfd_id_ref

    def _set_vnfd_id_ref(self , v , load=False):
        """
    Setter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/vnfd_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id_ref() directly.

    YANG Description: A reference to a vnfd. This is a
   leafref to path:
       ../../../nsd:constituent-vnfd
       + [nsd:id = current()/../nsd:id-ref]
       + /nsd:vnfd-id-ref
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_id_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vnfd_id_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_id_ref(self):
        self.__vnfd_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_vnfd_connection_point_ref(self):
        """
    Getter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/vnfd_connection_point_ref (string)

    YANG Description: A reference to a connection point name
   in a vnfd. This is a leafref to path:
       /vnfd:vnfd-catalog/vnfd:vnfd
       + [vnfd:id = current()/../nsd:vnfd-id-ref]
       + /vnfd:connection-point/vnfd:name
   NOTE: An issue with confd is preventing the
   use of xpath. Seems to be an issue with leafref
   to leafref, whose target is in a different module.
   Once that is resolved this will switched to use
   leafref
    """
        return self.__vnfd_connection_point_ref

    def _set_vnfd_connection_point_ref(self , v , load=False):
        """
    Setter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier/vnfd_connection_point_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_connection_point_ref() directly.

    YANG Description: A reference to a connection point name
   in a vnfd. This is a leafref to path:
       /vnfd:vnfd-catalog/vnfd:vnfd
       + [vnfd:id = current()/../nsd:vnfd-id-ref]
       + /vnfd:connection-point/vnfd:name
   NOTE: An issue with confd is preventing the
   use of xpath. Seems to be an issue with leafref
   to leafref, whose target is in a different module.
   Once that is resolved this will switched to use
   leafref
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnfd-connection-point-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_connection_point_ref must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__vnfd_connection_point_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_connection_point_ref(self):
        self.__vnfd_connection_point_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                        yang_name="vnfd-connection-point-ref" , parent=self ,
                                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                                        register_paths=True ,
                                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                        defining_module='nsd' , yang_type='string' , is_config=True)

    id = __builtin__.property(_get_id , _set_id)
    name = __builtin__.property(_get_name , _set_name)
    rsp_id_ref = __builtin__.property(_get_rsp_id_ref , _set_rsp_id_ref)
    match_attributes = __builtin__.property(_get_match_attributes , _set_match_attributes)
    member_vnf_index_ref = __builtin__.property(_get_member_vnf_index_ref , _set_member_vnf_index_ref)
    vnfd_id_ref = __builtin__.property(_get_vnfd_id_ref , _set_vnfd_id_ref)
    vnfd_connection_point_ref = __builtin__.property(_get_vnfd_connection_point_ref , _set_vnfd_connection_point_ref)

    _pyangbind_elements = {'id': id , 'name': name , 'rsp_id_ref': rsp_id_ref , 'match_attributes': match_attributes ,
                           'member_vnf_index_ref': member_vnf_index_ref , 'vnfd_id_ref': vnfd_id_ref ,
                           'vnfd_connection_point_ref': vnfd_connection_point_ref , }


class yc_vnffgd_nsd__nsd_catalog_nsd_vnffgd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vnffgd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VNF Forwarding Graph Descriptors (VNFFGD).
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__id' , '__name' , '__short_name' , '__vendor' , '__description' , '__version' ,
    '__rsp' , '__classifier' ,)

    _yang_name = 'vnffgd'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vendor = YANGDynClass(base=unicode , is_leaf=True , yang_name="vendor" , parent=self ,
                                     path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                     yang_type='string' , is_config=True)
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='string' , is_config=True)
        self.__short_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                         defining_module='nsd' , yang_type='string' , is_config=True)
        self.__classifier = YANGDynClass(
            base=YANGListType("id" , yc_classifier_nsd__nsd_catalog_nsd_vnffgd_classifier , yang_name="classifier" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='id' , extensions=None) , is_container='list' , yang_name="classifier" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='list' , is_config=True)
        self.__version = YANGDynClass(base=unicode , is_leaf=True , yang_name="version" , parent=self ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                      defining_module='nsd' , yang_type='string' , is_config=True)
        self.__rsp = YANGDynClass(
            base=YANGListType("id" , yc_rsp_nsd__nsd_catalog_nsd_vnffgd_rsp , yang_name="rsp" , parent=self ,
                              is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='id' , extensions=None) , is_container='list' , yang_name="rsp" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                 defining_module='nsd' , yang_type='string' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'vnffgd']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd_catalog/nsd/vnffgd/id (string)

    YANG Description: Identifier for the FGD.
    """
        return self.__id

    def _set_id(self , v , load=False):
        """
    Setter method for id, mapped from YANG variable /nsd_catalog/nsd/vnffgd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the FGD.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                         " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
                })

        self.__id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                 defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/vnffgd/name (string)

    YANG Description: FGD name.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/vnffgd/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: FGD name.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)

    def _get_short_name(self):
        """
    Getter method for short_name, mapped from YANG variable /nsd_catalog/nsd/vnffgd/short_name (string)

    YANG Description: Short name to appear as label in the UI
    """
        return self.__short_name

    def _set_short_name(self , v , load=False):
        """
    Setter method for short_name, mapped from YANG variable /nsd_catalog/nsd/vnffgd/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.

    YANG Description: Short name to appear as label in the UI
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """short_name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__short_name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_short_name(self):
        self.__short_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                         defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_vendor(self):
        """
    Getter method for vendor, mapped from YANG variable /nsd_catalog/nsd/vnffgd/vendor (string)

    YANG Description: Provider of the FGD.
    """
        return self.__vendor

    def _set_vendor(self , v , load=False):
        """
    Setter method for vendor, mapped from YANG variable /nsd_catalog/nsd/vnffgd/vendor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor() directly.

    YANG Description: Provider of the FGD.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vendor" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vendor must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__vendor = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vendor(self):
        self.__vendor = YANGDynClass(base=unicode , is_leaf=True , yang_name="vendor" , parent=self ,
                                     path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                     yang_type='string' , is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd_catalog/nsd/vnffgd/description (string)

    YANG Description: Description of the FGD.
    """
        return self.__description

    def _set_description(self , v , load=False):
        """
    Setter method for description, mapped from YANG variable /nsd_catalog/nsd/vnffgd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the FGD.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__description = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_version(self):
        """
    Getter method for version, mapped from YANG variable /nsd_catalog/nsd/vnffgd/version (string)

    YANG Description: Version of the FGD
    """
        return self.__version

    def _set_version(self , v , load=False):
        """
    Setter method for version, mapped from YANG variable /nsd_catalog/nsd/vnffgd/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Version of the FGD
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="version" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """version must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__version = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(base=unicode , is_leaf=True , yang_name="version" , parent=self ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                      defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_rsp(self):
        """
    Getter method for rsp, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp (list)

    YANG Description: List of Rendered Service Paths (RSP).
    """
        return self.__rsp

    def _set_rsp(self , v , load=False):
        """
    Setter method for rsp, mapped from YANG variable /nsd_catalog/nsd/vnffgd/rsp (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rsp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rsp() directly.

    YANG Description: List of Rendered Service Paths (RSP).
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("id" , yc_rsp_nsd__nsd_catalog_nsd_vnffgd_rsp , yang_name="rsp" ,
                                                   parent=self , is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='id' , extensions=None) ,
                             is_container='list' , yang_name="rsp" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """rsp must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_rsp_nsd__nsd_catalog_nsd_vnffgd_rsp, yang_name="rsp", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="rsp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__rsp = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_rsp(self):
        self.__rsp = YANGDynClass(
            base=YANGListType("id" , yc_rsp_nsd__nsd_catalog_nsd_vnffgd_rsp , yang_name="rsp" , parent=self ,
                              is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='id' , extensions=None) , is_container='list' , yang_name="rsp" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    def _get_classifier(self):
        """
    Getter method for classifier, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier (list)

    YANG Description: List of classifier rules.
    """
        return self.__classifier

    def _set_classifier(self , v , load=False):
        """
    Setter method for classifier, mapped from YANG variable /nsd_catalog/nsd/vnffgd/classifier (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_classifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_classifier() directly.

    YANG Description: List of classifier rules.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("id" , yc_classifier_nsd__nsd_catalog_nsd_vnffgd_classifier ,
                                                   yang_name="classifier" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper , yang_keys='id' ,
                                                   extensions=None) , is_container='list' , yang_name="classifier" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """classifier must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_classifier_nsd__nsd_catalog_nsd_vnffgd_classifier, yang_name="classifier", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="classifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__classifier = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_classifier(self):
        self.__classifier = YANGDynClass(
            base=YANGListType("id" , yc_classifier_nsd__nsd_catalog_nsd_vnffgd_classifier , yang_name="classifier" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='id' , extensions=None) , is_container='list' , yang_name="classifier" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='list' , is_config=True)

    id = __builtin__.property(_get_id , _set_id)
    name = __builtin__.property(_get_name , _set_name)
    short_name = __builtin__.property(_get_short_name , _set_short_name)
    vendor = __builtin__.property(_get_vendor , _set_vendor)
    description = __builtin__.property(_get_description , _set_description)
    version = __builtin__.property(_get_version , _set_version)
    rsp = __builtin__.property(_get_rsp , _set_rsp)
    classifier = __builtin__.property(_get_classifier , _set_classifier)

    _pyangbind_elements = {'id': id , 'name': name , 'short_name': short_name , 'vendor': vendor ,
                           'description': description , 'version': version , 'rsp': rsp , 'classifier': classifier , }


class yc_dns_server_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dns_server(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ip-profiles/ip-profile-params/dns-server. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__address' ,)

    _yang_name = 'dns-server'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                            RestrictedClassType(base_type=unicode , restriction_dict={
                                                'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                      is_leaf=True , yang_name="address" , parent=self , path_helper=self._path_helper ,
                                      extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                      yang_type='inet:ip-address' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'ip-profiles' , u'ip-profile-params' , u'dns-server']

    def _get_address(self):
        """
    Getter method for address, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dns_server/address (inet:ip-address)

    YANG Description: List of DNS Servers associated with IP Profile
    """
        return self.__address

    def _set_address(self , v , load=False):
        """
    Setter method for address, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dns_server/address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: List of DNS Servers associated with IP Profile
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=[RestrictedClassType(base_type=unicode , restriction_dict={
                'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                       RestrictedClassType(base_type=unicode , restriction_dict={
                                           'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                             is_leaf=True , yang_name="address" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='inet:ip-address' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """address must be of a type compatible with inet:ip-address""" ,
                'defined-type': "inet:ip-address" ,
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)""" ,
            })

        self.__address = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_address(self):
        self.__address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                            RestrictedClassType(base_type=unicode , restriction_dict={
                                                'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                      is_leaf=True , yang_name="address" , parent=self , path_helper=self._path_helper ,
                                      extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                      namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                      yang_type='inet:ip-address' , is_config=True)

    address = __builtin__.property(_get_address , _set_address)

    _pyangbind_elements = {'address': address , }


class yc_dhcp_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dhcp_params(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ip-profiles/ip-profile-params/dhcp-params. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__enabled' , '__start_address' , '__count' ,)

    _yang_name = 'dhcp-params'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__start_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                                  RestrictedClassType(base_type=unicode , restriction_dict={
                                                      'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                            is_leaf=True , yang_name="start-address" , parent=self ,
                                            path_helper=self._path_helper , extmethods=self._extmethods ,
                                            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                            defining_module='nsd' , yang_type='inet:ip-address' , is_config=True)
        self.__count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)
        self.__enabled = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="enabled" ,
                                      parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                      defining_module='nsd' , yang_type='boolean' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'ip-profiles' , u'ip-profile-params' , u'dhcp-params']

    def _get_enabled(self):
        """
    Getter method for enabled, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dhcp_params/enabled (boolean)

    YANG Description: This flag indicates if DHCP is enabled or not
    """
        return self.__enabled

    def _set_enabled(self , v , load=False):
        """
    Setter method for enabled, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dhcp_params/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This flag indicates if DHCP is enabled or not
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="enabled" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """enabled must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""" ,
            })

        self.__enabled = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_enabled(self):
        self.__enabled = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="enabled" ,
                                      parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                      defining_module='nsd' , yang_type='boolean' , is_config=True)

    def _get_start_address(self):
        """
    Getter method for start_address, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dhcp_params/start_address (inet:ip-address)

    YANG Description: Start IP address of the IP-Address range associated with DHCP domain
    """
        return self.__start_address

    def _set_start_address(self , v , load=False):
        """
    Setter method for start_address, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dhcp_params/start_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_address() directly.

    YANG Description: Start IP address of the IP-Address range associated with DHCP domain
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=[RestrictedClassType(base_type=unicode , restriction_dict={
                'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                       RestrictedClassType(base_type=unicode , restriction_dict={
                                           'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                             is_leaf=True , yang_name="start-address" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='inet:ip-address' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """start_address must be of a type compatible with inet:ip-address""" ,
                'defined-type': "inet:ip-address" ,
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="start-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)""" ,
            })

        self.__start_address = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_start_address(self):
        self.__start_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                                  RestrictedClassType(base_type=unicode , restriction_dict={
                                                      'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                            is_leaf=True , yang_name="start-address" , parent=self ,
                                            path_helper=self._path_helper , extmethods=self._extmethods ,
                                            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                            defining_module='nsd' , yang_type='inet:ip-address' , is_config=True)

    def _get_count(self):
        """
    Getter method for count, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dhcp_params/count (uint32)

    YANG Description: Size of the DHCP pool associated with DHCP domain
    """
        return self.__count

    def _set_count(self , v , load=False):
        """
    Setter method for count, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dhcp_params/count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.

    YANG Description: Size of the DHCP pool associated with DHCP domain
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , is_leaf=True , yang_name="count" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """count must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""" ,
            })

        self.__count = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_count(self):
        self.__count = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="count" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)

    enabled = __builtin__.property(_get_enabled , _set_enabled)
    start_address = __builtin__.property(_get_start_address , _set_start_address)
    count = __builtin__.property(_get_count , _set_count)

    _pyangbind_elements = {'enabled': enabled , 'start_address': start_address , 'count': count , }


class yc_ip_profile_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ip-profiles/ip-profile-params. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__ip_version' , '__subnet_address' , '__gateway_address' , '__security_group' ,
    '__dns_server' , '__dhcp_params' , '__subnet_prefix_pool' ,)

    _yang_name = 'ip-profile-params'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__dhcp_params = YANGDynClass(
            base=yc_dhcp_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dhcp_params ,
            is_container='container' , yang_name="dhcp-params" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='container' ,
            is_config=True)
        self.__dns_server = YANGDynClass(
            base=YANGListType("address" , yc_dns_server_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dns_server ,
                              yang_name="dns-server" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='address' , extensions=None) ,
            is_container='list' , yang_name="dns-server" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__gateway_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                                    RestrictedClassType(base_type=unicode , restriction_dict={
                                                        'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                              is_leaf=True , yang_name="gateway-address" , parent=self ,
                                              path_helper=self._path_helper , extmethods=self._extmethods ,
                                              register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                              defining_module='nsd' , yang_type='inet:ip-address' , is_config=True)
        self.__subnet_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}) ,
                                                   RestrictedClassType(base_type=unicode , restriction_dict={
                                                       'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}) , ] ,
                                             is_leaf=True , yang_name="subnet-address" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                             defining_module='nsd' , yang_type='inet:ip-prefix' , is_config=True)
        self.__subnet_prefix_pool = YANGDynClass(base=unicode , is_leaf=True , yang_name="subnet-prefix-pool" ,
                                                 parent=self , path_helper=self._path_helper ,
                                                 extmethods=self._extmethods , register_paths=True ,
                                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                 defining_module='nsd' , yang_type='string' , is_config=True)
        self.__security_group = YANGDynClass(base=unicode , is_leaf=True , yang_name="security-group" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                             defining_module='nsd' , yang_type='string' , is_config=True)
        self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                  restriction_arg={u'unknown': {'value': 0} ,
                                                                                   u'ipv4': {'value': 1} ,
                                                                                   u'ipv6': {'value': 2}} , ) ,
                                         default=unicode("ipv4") , is_leaf=True , yang_name="ip-version" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                         defining_module='nsd' , yang_type='inet:ip-version' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'ip-profiles' , u'ip-profile-params']

    def _get_ip_version(self):
        """
    Getter method for ip_version, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/ip_version (inet:ip-version)
    """
        return self.__ip_version

    def _set_ip_version(self , v , load=False):
        """
    Setter method for ip_version, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/ip_version (inet:ip-version)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_version() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'unknown': {'value': 0} ,
                                                                           u'ipv4': {'value': 1} ,
                                                                           u'ipv6': {'value': 2}} , ) ,
                             default=unicode("ipv4") , is_leaf=True , yang_name="ip-version" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='inet:ip-version' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ip_version must be of a type compatible with inet:ip-version""" ,
                'defined-type': "inet:ip-version" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'unknown': {'value': 0}, u'ipv4': {'value': 1}, u'ipv6': {'value': 2}},), default=unicode("ipv4"), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='inet:ip-version', is_config=True)""" ,
            })

        self.__ip_version = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ip_version(self):
        self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                  restriction_arg={u'unknown': {'value': 0} ,
                                                                                   u'ipv4': {'value': 1} ,
                                                                                   u'ipv6': {'value': 2}} , ) ,
                                         default=unicode("ipv4") , is_leaf=True , yang_name="ip-version" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                         defining_module='nsd' , yang_type='inet:ip-version' , is_config=True)

    def _get_subnet_address(self):
        """
    Getter method for subnet_address, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/subnet_address (inet:ip-prefix)

    YANG Description: Subnet IP prefix associated with IP Profile
    """
        return self.__subnet_address

    def _set_subnet_address(self , v , load=False):
        """
    Setter method for subnet_address, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/subnet_address (inet:ip-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subnet_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subnet_address() directly.

    YANG Description: Subnet IP prefix associated with IP Profile
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=[RestrictedClassType(base_type=unicode , restriction_dict={
                'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}) ,
                                       RestrictedClassType(base_type=unicode , restriction_dict={
                                           'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}) , ] ,
                             is_leaf=True , yang_name="subnet-address" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='inet:ip-prefix' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """subnet_address must be of a type compatible with inet:ip-prefix""" ,
                'defined-type': "inet:ip-prefix" ,
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="subnet-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='inet:ip-prefix', is_config=True)""" ,
            })

        self.__subnet_address = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_subnet_address(self):
        self.__subnet_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}) ,
                                                   RestrictedClassType(base_type=unicode , restriction_dict={
                                                       'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}) , ] ,
                                             is_leaf=True , yang_name="subnet-address" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                             defining_module='nsd' , yang_type='inet:ip-prefix' , is_config=True)

    def _get_gateway_address(self):
        """
    Getter method for gateway_address, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/gateway_address (inet:ip-address)

    YANG Description: IP Address of the default gateway associated with IP Profile
    """
        return self.__gateway_address

    def _set_gateway_address(self , v , load=False):
        """
    Setter method for gateway_address, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/gateway_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway_address() directly.

    YANG Description: IP Address of the default gateway associated with IP Profile
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=[RestrictedClassType(base_type=unicode , restriction_dict={
                'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                       RestrictedClassType(base_type=unicode , restriction_dict={
                                           'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                             is_leaf=True , yang_name="gateway-address" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='inet:ip-address' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """gateway_address must be of a type compatible with inet:ip-address""" ,
                'defined-type': "inet:ip-address" ,
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)""" ,
            })

        self.__gateway_address = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_gateway_address(self):
        self.__gateway_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                                    RestrictedClassType(base_type=unicode , restriction_dict={
                                                        'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                              is_leaf=True , yang_name="gateway-address" , parent=self ,
                                              path_helper=self._path_helper , extmethods=self._extmethods ,
                                              register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                              defining_module='nsd' , yang_type='inet:ip-address' , is_config=True)

    def _get_security_group(self):
        """
    Getter method for security_group, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/security_group (string)

    YANG Description: Name of the security group
    """
        return self.__security_group

    def _set_security_group(self , v , load=False):
        """
    Setter method for security_group, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/security_group (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security_group() directly.

    YANG Description: Name of the security group
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="security-group" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """security_group must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="security-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__security_group = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_security_group(self):
        self.__security_group = YANGDynClass(base=unicode , is_leaf=True , yang_name="security-group" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                             defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_dns_server(self):
        """
    Getter method for dns_server, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dns_server (list)
    """
        return self.__dns_server

    def _set_dns_server(self , v , load=False):
        """
    Setter method for dns_server, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dns_server (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns_server() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("address" ,
                                                   yc_dns_server_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dns_server ,
                                                   yang_name="dns-server" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='address' , extensions=None) , is_container='list' ,
                             yang_name="dns-server" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """dns_server must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("address",yc_dns_server_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dns_server, yang_name="dns-server", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='address', extensions=None), is_container='list', yang_name="dns-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__dns_server = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_dns_server(self):
        self.__dns_server = YANGDynClass(
            base=YANGListType("address" , yc_dns_server_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dns_server ,
                              yang_name="dns-server" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='address' , extensions=None) ,
            is_container='list' , yang_name="dns-server" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    def _get_dhcp_params(self):
        """
    Getter method for dhcp_params, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dhcp_params (container)
    """
        return self.__dhcp_params

    def _set_dhcp_params(self , v , load=False):
        """
    Setter method for dhcp_params, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/dhcp_params (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_params is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_params() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_dhcp_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dhcp_params ,
                             is_container='container' , yang_name="dhcp-params" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """dhcp_params must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_dhcp_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dhcp_params, is_container='container', yang_name="dhcp-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='container', is_config=True)""" ,
            })

        self.__dhcp_params = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_dhcp_params(self):
        self.__dhcp_params = YANGDynClass(
            base=yc_dhcp_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params_dhcp_params ,
            is_container='container' , yang_name="dhcp-params" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='container' ,
            is_config=True)

    def _get_subnet_prefix_pool(self):
        """
    Getter method for subnet_prefix_pool, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/subnet_prefix_pool (string)

    YANG Description: VIM Specific reference to pre-created subnet prefix
    """
        return self.__subnet_prefix_pool

    def _set_subnet_prefix_pool(self , v , load=False):
        """
    Setter method for subnet_prefix_pool, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params/subnet_prefix_pool (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subnet_prefix_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subnet_prefix_pool() directly.

    YANG Description: VIM Specific reference to pre-created subnet prefix
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="subnet-prefix-pool" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """subnet_prefix_pool must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="subnet-prefix-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__subnet_prefix_pool = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_subnet_prefix_pool(self):
        self.__subnet_prefix_pool = YANGDynClass(base=unicode , is_leaf=True , yang_name="subnet-prefix-pool" ,
                                                 parent=self , path_helper=self._path_helper ,
                                                 extmethods=self._extmethods , register_paths=True ,
                                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                 defining_module='nsd' , yang_type='string' , is_config=True)

    ip_version = __builtin__.property(_get_ip_version , _set_ip_version)
    subnet_address = __builtin__.property(_get_subnet_address , _set_subnet_address)
    gateway_address = __builtin__.property(_get_gateway_address , _set_gateway_address)
    security_group = __builtin__.property(_get_security_group , _set_security_group)
    dns_server = __builtin__.property(_get_dns_server , _set_dns_server)
    dhcp_params = __builtin__.property(_get_dhcp_params , _set_dhcp_params)
    subnet_prefix_pool = __builtin__.property(_get_subnet_prefix_pool , _set_subnet_prefix_pool)

    _pyangbind_elements = {'ip_version': ip_version , 'subnet_address': subnet_address ,
                           'gateway_address': gateway_address , 'security_group': security_group ,
                           'dns_server': dns_server , 'dhcp_params': dhcp_params ,
                           'subnet_prefix_pool': subnet_prefix_pool , }


class yc_ip_profiles_nsd__nsd_catalog_nsd_ip_profiles(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/ip-profiles. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of IP Profiles.
  IP Profile describes the IP characteristics for the Virtual-Link
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__description' , '__ip_profile_params' ,)

    _yang_name = 'ip-profiles'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__ip_profile_params = YANGDynClass(
            base=yc_ip_profile_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params , is_container='container' ,
            yang_name="ip-profile-params" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='container' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'ip-profiles']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/name (string)

    YANG Description: Name of the IP-Profile
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the IP-Profile
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/description (string)

    YANG Description: Description for IP profile
    """
        return self.__description

    def _set_description(self , v , load=False):
        """
    Setter method for description, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description for IP profile
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__description = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_ip_profile_params(self):
        """
    Getter method for ip_profile_params, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params (container)
    """
        return self.__ip_profile_params

    def _set_ip_profile_params(self , v , load=False):
        """
    Setter method for ip_profile_params, mapped from YANG variable /nsd_catalog/nsd/ip_profiles/ip_profile_params (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_profile_params is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_profile_params() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_ip_profile_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params ,
                             is_container='container' , yang_name="ip-profile-params" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ip_profile_params must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_ip_profile_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params, is_container='container', yang_name="ip-profile-params", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='container', is_config=True)""" ,
            })

        self.__ip_profile_params = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ip_profile_params(self):
        self.__ip_profile_params = YANGDynClass(
            base=yc_ip_profile_params_nsd__nsd_catalog_nsd_ip_profiles_ip_profile_params , is_container='container' ,
            yang_name="ip-profile-params" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='container' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    description = __builtin__.property(_get_description , _set_description)
    ip_profile_params = __builtin__.property(_get_ip_profile_params , _set_ip_profile_params)
	_pyangbind_elements = {'name': name , 'description': description , 'ip_profile_params': ip_profile_params}


class yc_parameter_nsd__nsd_catalog_nsd_initial_service_primitive_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/initial-service-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__value' ,)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)
        self.__value = YANGDynClass(base=unicode , is_leaf=True , yang_name="value" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                    yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'initial-service-primitive' , u'parameter']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/initial_service_primitive/parameter/name (string)
    """
        return self.__name

    def _set_name(self , v , load=False):
            """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/initial_service_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """

    parent = getattr(self , "_parent" , None)
    if parent is not None and load is False:
        raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v , "_utype"):
        v = v._utype(v)
    try:
        t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                         path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                         is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                         yang_type='string' , is_config=True)
    except (TypeError , ValueError):
        raise ValueError({
            'error-string': """name must be of a type compatible with string""" ,
            'defined-type': "string" ,
            'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
        })

    self.__name = t
    if hasattr(self , '_set'):
        self._set()


def _unset_name(self):
    self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                               path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                               is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                               defining_module='nsd' , yang_type='string' , is_config=True)


def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /nsd_catalog/nsd/initial_service_primitive/parameter/value (string)

    YANG Description: Value of the configuration primitive.
    """
    return self.__value


def _set_value(self , v , load=False):
    """
    Setter method for value, mapped from YANG variable /nsd_catalog/nsd/initial_service_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value of the configuration primitive.
    """
    if hasattr(v , "_utype"):
        v = v._utype(v)
    try:
        t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="value" , parent=self ,
                         path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                         namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='string' ,
                         is_config=True)
    except (TypeError , ValueError):
        raise ValueError({
            'error-string': """value must be of a type compatible with string""" ,
            'defined-type': "string" ,
            'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
        })

    self.__value = t
    if hasattr(self , '_set'):
        self._set()


def _unset_value(self):
    self.__value = YANGDynClass(base=unicode , is_leaf=True , yang_name="value" , parent=self ,
                                path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                yang_type='string' , is_config=True)


name = __builtin__.property(_get_name , _set_name)
value = __builtin__.property(_get_value , _set_value)

_pyangbind_elements = {'name': name , 'value': value , }


class yc_initial_service_primitive_nsd__nsd_catalog_nsd_initial_service_primitive(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/initial-service-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Initial set of service primitives for NSD.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__seq' , '__name' , '__user_defined_script' , '__parameter' ,)

    _yang_name = 'initial-service-primitive'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__user_defined_script = YANGDynClass(base=unicode , is_leaf=True , yang_name="user-defined-script" ,
                                                  parent=self , path_helper=self._path_helper ,
                                                  extmethods=self._extmethods , register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                  defining_module='nsd' , yang_type='string' , is_config=True)
        self.__parameter = YANGDynClass(
            base=YANGListType("name" , yc_parameter_nsd__nsd_catalog_nsd_initial_service_primitive_parameter ,
                              yang_name="parameter" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="parameter" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)
        self.__seq = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="seq" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , is_keyval=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint64' ,
            is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
                        all_attr = True
            for e in self._pyangbind_elements:
                    if
            not hasattr(args[0] , e):
            all_attr = False
            break
        if not all_attr:
            raise ValueError("Supplied object did not have the correct attributes")
        for e in self._pyangbind_elements:
            nobj = getattr(args[0] , e)
            if nobj._changed() is False:
                continue
            setmethod = getattr(self , "_set_%s" % e)
            if load is None:
                setmethod(getattr(args[0] , e))
            else:
                setmethod(getattr(args[0] , e) , load=load)


def _path(self):
    if hasattr(self , "_parent"):
        return self._parent._path() + [self._yang_name]
    else:
        return [u'nsd-catalog' , u'nsd' , u'initial-service-primitive']


def _get_seq(self):
    """
    Getter method for seq, mapped from YANG variable /nsd_catalog/nsd/initial_service_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
            return self.__seq


def _set_seq(self , v , load=False):
    """
    Setter method for seq, mapped from YANG variable /nsd_catalog/nsd/initial_service_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
    parent = getattr(self , "_parent" , None)
    if parent is not None and load is False:
        raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v , "_utype"):
        v = v._utype(v)
    try:
        t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                      restriction_dict={'range': ['0..18446744073709551615']} ,
                                                      int_size=64) , is_leaf=True , yang_name="seq" , parent=self ,
                         path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                         is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                         yang_type='uint64' , is_config=True)
    except (TypeError , ValueError):
        raise ValueError({
            'error-string': """seq must be of a type compatible with uint64""" ,
            'defined-type': "uint64" ,
            'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint64', is_config=True)""" ,
        })

    self.__seq = t
    if hasattr(self , '_set'):
        self._set()


def _unset_seq(self):
    self.__seq = YANGDynClass(
        base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                 int_size=64) , is_leaf=True , yang_name="seq" , parent=self ,
        path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , is_keyval=True ,
        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint64' , is_config=True)


def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/initial_service_primitive/name (string)

    YANG Description: Name of the configuration primitive.
    """
    return self.__name


def _set_name(self , v , load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/initial_service_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive.
    """
    if hasattr(v , "_utype"):
        v = v._utype(v)
    try:
        t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                         path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                         namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='string' ,
                         is_config=True)
    except (TypeError , ValueError):
        raise ValueError({
            'error-string': """name must be of a type compatible with string""" ,
            'defined-type': "string" ,
            'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
        })

    self.__name = t
    if hasattr(self , '_set'):
        self._set()


def _unset_name(self):
    self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                               path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                               namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                               yang_type='string' , is_config=True)


def _get_user_defined_script(self):
    """
    Getter method for user_defined_script, mapped from YANG variable /nsd_catalog/nsd/initial_service_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
    return self.__user_defined_script


def _set_user_defined_script(self , v , load=False):
    """
    Setter method for user_defined_script, mapped from YANG variable /nsd_catalog/nsd/initial_service_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
    if hasattr(v , "_utype"):
        v = v._utype(v)
    try:
        t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="user-defined-script" , parent=self ,
                         path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                         namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='string' ,
                         is_config=True)
    except (TypeError , ValueError):
        raise ValueError({
            'error-string': """user_defined_script must be of a type compatible with string""" ,
            'defined-type': "string" ,
            'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
        })

    self.__user_defined_script = t
    if hasattr(self , '_set'):
        self._set()


def _unset_user_defined_script(self):
    self.__user_defined_script = YANGDynClass(base=unicode , is_leaf=True , yang_name="user-defined-script" ,
                                              parent=self , path_helper=self._path_helper ,
                                              extmethods=self._extmethods , register_paths=True ,
                                              namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                              yang_type='string' , is_config=True)


def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /nsd_catalog/nsd/initial_service_primitive/parameter (list)
    """
    return self.__parameter


def _set_parameter(self , v , load=False):
    """
    Setter method for parameter, mapped from YANG variable /nsd_catalog/nsd/initial_service_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.
    """
    if hasattr(v , "_utype"):
        v = v._utype(v)
    try:
        t = YANGDynClass(v , base=YANGListType("name" ,
                                               yc_parameter_nsd__nsd_catalog_nsd_initial_service_primitive_parameter ,
                                               yang_name="parameter" , parent=self , is_container='list' ,
                                               user_ordered=False , path_helper=self._path_helper , yang_keys='name' ,
                                               extensions=None) , is_container='list' , yang_name="parameter" ,
                         parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                         register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                         defining_module='nsd' , yang_type='list' , is_config=True)
    except (TypeError , ValueError):
        raise ValueError({
            'error-string': """parameter must be of a type compatible with list""" ,
            'defined-type': "list" ,
            'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_nsd__nsd_catalog_nsd_initial_service_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
        })

    self.__parameter = t
    if hasattr(self , '_set'):
        self._set()


def _unset_parameter(self):
    self.__parameter = YANGDynClass(
        base=YANGListType("name" , yc_parameter_nsd__nsd_catalog_nsd_initial_service_primitive_parameter ,
                          yang_name="parameter" , parent=self , is_container='list' , user_ordered=False ,
                          path_helper=self._path_helper , yang_keys='name' , extensions=None) , is_container='list' ,
        yang_name="parameter" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
        register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
        defining_module='nsd' , yang_type='list' , is_config=True)


seq = __builtin__.property(_get_seq , _set_seq)
name = __builtin__.property(_get_name , _set_name)
user_defined_script = __builtin__.property(_get_user_defined_script , _set_user_defined_script)
parameter = __builtin__.property(_get_parameter , _set_parameter)

_pyangbind_elements = {'seq': seq , 'name': name , 'user_defined_script': user_defined_script ,
                       'parameter': parameter , }


class yc_parameter_nsd__nsd_catalog_nsd_terminate_service_primitive_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/terminate-service-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__value' ,)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)
        self.__value = YANGDynClass(base=unicode , is_leaf=True , yang_name="value" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                    yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'terminate-service-primitive' , u'parameter']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/terminate_service_primitive/parameter/name (string)
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/terminate_service_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd_catalog/nsd/terminate_service_primitive/parameter/value (string)

    YANG Description: Value of the configuration primitive.
    """
        return self.__value

    def _set_value(self , v , load=False):
        """
    Setter method for value, mapped from YANG variable /nsd_catalog/nsd/terminate_service_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value of the configuration primitive.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="value" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__value = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=unicode , is_leaf=True , yang_name="value" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                    yang_type='string' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    value = __builtin__.property(_get_value , _set_value)

    _pyangbind_elements = {'name': name , 'value': value , }


class yc_terminate_service_primitive_nsd__nsd_catalog_nsd_terminate_service_primitive(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/terminate-service-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Set of service primitives during
termination for NSD.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__seq' , '__name' , '__user_defined_script' , '__parameter' ,)

    _yang_name = 'terminate-service-primitive'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__user_defined_script = YANGDynClass(base=unicode , is_leaf=True , yang_name="user-defined-script" ,
                                                  parent=self , path_helper=self._path_helper ,
                                                  extmethods=self._extmethods , register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                  defining_module='nsd' , yang_type='string' , is_config=True)
        self.__parameter = YANGDynClass(
            base=YANGListType("name" , yc_parameter_nsd__nsd_catalog_nsd_terminate_service_primitive_parameter ,
                              yang_name="parameter" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="parameter" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)
        self.__seq = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="seq" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , is_keyval=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint64' ,
            is_config=True)

        load = kwargs.pop("load" , None)
        if args:
                if
        len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")

    all_attr = True
    for e in self._pyangbind_elements:
        if not hasattr(args[0] , e):
            all_attr = False
            break
    if not all_attr:
            raise ValueError("Supplied object did not have the correct attributes")
    for e in self._pyangbind_elements:
        nobj = getattr(args[0] , e)
        if nobj._changed() is False:
            continue
        setmethod = getattr(self , "_set_%s" % e)
        if load is None:
            setmethod(getattr(args[0] , e))
        else:
            setmethod(getattr(args[0] , e) , load=load)


def _path(self):
    if hasattr(self , "_parent"):
        return self._parent._path() + [self._yang_name]
    else:
        return [u'nsd-catalog' , u'nsd' , u'terminate-service-primitive']


def _get_seq(self):
    """
    Getter method for seq, mapped from YANG variable /nsd_catalog/nsd/terminate_service_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
    return self.__seq


def _set_seq(self , v , load=False):
    """
    Setter method for seq, mapped from YANG variable /nsd_catalog/nsd/terminate_service_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
    parent = getattr(self , "_parent" , None)
    if parent is not None and load is False:
        raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v , "_utype"):
        v = v._utype(v)
    try:
        t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                      restriction_dict={'range': ['0..18446744073709551615']} ,
                                                      int_size=64) , is_leaf=True , yang_name="seq" , parent=self ,
                         path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                         is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                         yang_type='uint64' , is_config=True)
    except (TypeError , ValueError):
        raise ValueError({
            'error-string': """seq must be of a type compatible with uint64""" ,
            'defined-type': "uint64" ,
            'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint64', is_config=True)""" ,
        })

    self.__seq = t
    if hasattr(self , '_set'):
        self._set()


def _unset_seq(self):
    self.__seq = YANGDynClass(
        base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                 int_size=64) , is_leaf=True , yang_name="seq" , parent=self ,
        path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , is_keyval=True ,
        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint64' , is_config=True)


def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/terminate_service_primitive/name (string)

    YANG Description: Name of the configuration primitive.
    """
    return self.__name


def _set_name(self , v , load=False):
    """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/terminate_service_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive.
    """
    if hasattr(v , "_utype"):
        v = v._utype(v)
    try:
        t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                         path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                         namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='string' ,
                         is_config=True)
    except (TypeError , ValueError):
        raise ValueError({
            'error-string': """name must be of a type compatible with string""" ,
            'defined-type': "string" ,
            'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
        })

    self.__name = t
    if hasattr(self , '_set'):
        self._set()


def _unset_name(self):
    self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                               path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                               namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                               yang_type='string' , is_config=True)


def _get_user_defined_script(self):
    """
    Getter method for user_defined_script, mapped from YANG variable /nsd_catalog/nsd/terminate_service_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
    return self.__user_defined_script


def _set_user_defined_script(self , v , load=False):
    """
    Setter method for user_defined_script, mapped from YANG variable /nsd_catalog/nsd/terminate_service_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
    if hasattr(v , "_utype"):
        v = v._utype(v)
    try:
        t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="user-defined-script" , parent=self ,
                         path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                         namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='string' ,
                         is_config=True)
    except (TypeError , ValueError):
        raise ValueError({
            'error-string': """user_defined_script must be of a type compatible with string""" ,
            'defined-type': "string" ,
            'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
        })

    self.__user_defined_script = t
    if hasattr(self , '_set'):
        self._set()


def _unset_user_defined_script(self):
    self.__user_defined_script = YANGDynClass(base=unicode , is_leaf=True , yang_name="user-defined-script" ,
                                              parent=self , path_helper=self._path_helper ,
                                              extmethods=self._extmethods , register_paths=True ,
                                              namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                              yang_type='string' , is_config=True)


def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /nsd_catalog/nsd/terminate_service_primitive/parameter (list)
    """
    return self.__parameter


def _set_parameter(self , v , load=False):
    """
    Setter method for parameter, mapped from YANG variable /nsd_catalog/nsd/terminate_service_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.
    """
    if hasattr(v , "_utype"):
        v = v._utype(v)
    try:
        t = YANGDynClass(v , base=YANGListType("name" ,
                                               yc_parameter_nsd__nsd_catalog_nsd_terminate_service_primitive_parameter ,
                                               yang_name="parameter" , parent=self , is_container='list' ,
                                               user_ordered=False , path_helper=self._path_helper , yang_keys='name' ,
                                               extensions=None) , is_container='list' , yang_name="parameter" ,
                         parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                         register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                         defining_module='nsd' , yang_type='list' , is_config=True)
    except (TypeError , ValueError):
        raise ValueError({
            'error-string': """parameter must be of a type compatible with list""" ,
            'defined-type': "list" ,
            'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_nsd__nsd_catalog_nsd_terminate_service_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
        })

    self.__parameter = t
    if hasattr(self , '_set'):
        self._set()


def _unset_parameter(self):
    self.__parameter = YANGDynClass(
        base=YANGListType("name" , yc_parameter_nsd__nsd_catalog_nsd_terminate_service_primitive_parameter ,
                          yang_name="parameter" , parent=self , is_container='list' , user_ordered=False ,
                          path_helper=self._path_helper , yang_keys='name' , extensions=None) , is_container='list' ,
        yang_name="parameter" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
        register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
        defining_module='nsd' , yang_type='list' , is_config=True)


seq = __builtin__.property(_get_seq , _set_seq)
name = __builtin__.property(_get_name , _set_name)
user_defined_script = __builtin__.property(_get_user_defined_script , _set_user_defined_script)
parameter = __builtin__.property(_get_parameter , _set_parameter)

_pyangbind_elements = {'seq': seq , 'name': name , 'user_defined_script': user_defined_script ,
                       'parameter': parameter , }


class yc_input_parameter_xpath_nsd__nsd_catalog_nsd_input_parameter_xpath(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/input-parameter-xpath. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of xpaths to parameters inside the NSD
the can be customized during the instantiation.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__xpath' , '__label' , '__default_value' ,)

    _yang_name = 'input-parameter-xpath'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__xpath = YANGDynClass(base=unicode , is_leaf=True , yang_name="xpath" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                    defining_module='nsd' , yang_type='string' , is_config=True)
        self.__default_value = YANGDynClass(base=unicode , is_leaf=True , yang_name="default-value" , parent=self ,
                                            path_helper=self._path_helper , extmethods=self._extmethods ,
                                            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                            defining_module='nsd' , yang_type='string' , is_config=True)
        self.__label = YANGDynClass(base=unicode , is_leaf=True , yang_name="label" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                    yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'input-parameter-xpath']

    def _get_xpath(self):
        """
    Getter method for xpath, mapped from YANG variable /nsd_catalog/nsd/input_parameter_xpath/xpath (string)

    YANG Description: An xpath that specifies the element in a descriptor.
    """
        return self.__xpath

    def _set_xpath(self , v , load=False):
        """
    Setter method for xpath, mapped from YANG variable /nsd_catalog/nsd/input_parameter_xpath/xpath (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_xpath is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_xpath() directly.

    YANG Description: An xpath that specifies the element in a descriptor.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="xpath" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """xpath must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="xpath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__xpath = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_xpath(self):
        self.__xpath = YANGDynClass(base=unicode , is_leaf=True , yang_name="xpath" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                    defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_label(self):
        """
    Getter method for label, mapped from YANG variable /nsd_catalog/nsd/input_parameter_xpath/label (string)

    YANG Description: A descriptive string
    """
        return self.__label

    def _set_label(self , v , load=False):
        """
    Setter method for label, mapped from YANG variable /nsd_catalog/nsd/input_parameter_xpath/label (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_label() directly.

    YANG Description: A descriptive string
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="label" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """label must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__label = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_label(self):
        self.__label = YANGDynClass(base=unicode , is_leaf=True , yang_name="label" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                    yang_type='string' , is_config=True)

    def _get_default_value(self):
        """
    Getter method for default_value, mapped from YANG variable /nsd_catalog/nsd/input_parameter_xpath/default_value (string)

    YANG Description: Default Value for the Input Parameter
    """
        return self.__default_value

    def _set_default_value(self , v , load=False):
        """
    Setter method for default_value, mapped from YANG variable /nsd_catalog/nsd/input_parameter_xpath/default_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_value() directly.

    YANG Description: Default Value for the Input Parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="default-value" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """default_value must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__default_value = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_default_value(self):
        self.__default_value = YANGDynClass(base=unicode , is_leaf=True , yang_name="default-value" , parent=self ,
                                            path_helper=self._path_helper , extmethods=self._extmethods ,
                                            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                            defining_module='nsd' , yang_type='string' , is_config=True)

    xpath = __builtin__.property(_get_xpath , _set_xpath)
    label = __builtin__.property(_get_label , _set_label)
    default_value = __builtin__.property(_get_default_value , _set_default_value)

    _pyangbind_elements = {'xpath': xpath , 'label': label , 'default_value': default_value , }


class yc_range_nsd__nsd_catalog_nsd_parameter_pool_range(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/parameter-pool/range. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Create a range of values to populate the pool with
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__start_value' , '__end_value' ,)

    _yang_name = 'range'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__start_value = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="start-value" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)
        self.__end_value = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="end-value" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'parameter-pool' , u'range']

    def _get_start_value(self):
        """
    Getter method for start_value, mapped from YANG variable /nsd_catalog/nsd/parameter_pool/range/start_value (uint32)

    YANG Description: Generated pool values start at this value
    """
        return self.__start_value

    def _set_start_value(self , v , load=False):
        """
    Setter method for start_value, mapped from YANG variable /nsd_catalog/nsd/parameter_pool/range/start_value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_value() directly.

    YANG Description: Generated pool values start at this value
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , is_leaf=True , yang_name="start-value" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """start_value must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="start-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""" ,
            })

        self.__start_value = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_start_value(self):
        self.__start_value = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="start-value" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)

    def _get_end_value(self):
        """
    Getter method for end_value, mapped from YANG variable /nsd_catalog/nsd/parameter_pool/range/end_value (uint32)

    YANG Description: Generated pool values stop at this value
    """
        return self.__end_value

    def _set_end_value(self , v , load=False):
        """
    Setter method for end_value, mapped from YANG variable /nsd_catalog/nsd/parameter_pool/range/end_value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end_value() directly.

    YANG Description: Generated pool values stop at this value
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , is_leaf=True , yang_name="end-value" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """end_value must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="end-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""" ,
            })

        self.__end_value = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_end_value(self):
        self.__end_value = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="end-value" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)

    start_value = __builtin__.property(_get_start_value , _set_start_value)
    end_value = __builtin__.property(_get_end_value , _set_end_value)

    _pyangbind_elements = {'start_value': start_value , 'end_value': end_value , }


class yc_parameter_pool_nsd__nsd_catalog_nsd_parameter_pool(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/parameter-pool. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Pool of parameter values which must be
pulled from during configuration
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__range' ,)

    _yang_name = 'parameter-pool'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__range = YANGDynClass(base=yc_range_nsd__nsd_catalog_nsd_parameter_pool_range , is_container='container' ,
                                    yang_name="range" , parent=self , path_helper=self._path_helper ,
                                    extmethods=self._extmethods , register_paths=True , extensions=None ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                    yang_type='container' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'parameter-pool']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/parameter_pool/name (string)

    YANG Description: Name of the configuration value pool
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/parameter_pool/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration value pool
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_range(self):
        """
    Getter method for range, mapped from YANG variable /nsd_catalog/nsd/parameter_pool/range (container)

    YANG Description: Create a range of values to populate the pool with
    """
        return self.__range

    def _set_range(self , v , load=False):
        """
    Setter method for range, mapped from YANG variable /nsd_catalog/nsd/parameter_pool/range (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_range() directly.

    YANG Description: Create a range of values to populate the pool with
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_range_nsd__nsd_catalog_nsd_parameter_pool_range , is_container='container' ,
                             yang_name="range" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """range must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_range_nsd__nsd_catalog_nsd_parameter_pool_range, is_container='container', yang_name="range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='container', is_config=True)""" ,
            })

        self.__range = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_range(self):
        self.__range = YANGDynClass(base=yc_range_nsd__nsd_catalog_nsd_parameter_pool_range , is_container='container' ,
                                    yang_name="range" , parent=self , path_helper=self._path_helper ,
                                    extmethods=self._extmethods , register_paths=True , extensions=None ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                    yang_type='container' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    range = __builtin__.property(_get_range , _set_range)

    _pyangbind_elements = {'name': name , 'range': range , }


class yc_key_pair_nsd__nsd_catalog_nsd_key_pair(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/key-pair. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Used to configure the list of public keys to be injected as part
of ns instantiation
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__key' ,)

    _yang_name = 'key-pair'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)
        self.__key = YANGDynClass(base=unicode , is_leaf=True , yang_name="key" , parent=self ,
                                  path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                  yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'key-pair']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/key_pair/name (string)

    YANG Description: Name of this key pair
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/key_pair/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of this key pair
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd_catalog/nsd/key_pair/key (string)

    YANG Description: Key associated with this key pair
    """
        return self.__key

    def _set_key(self , v , load=False):
        """
    Setter method for key, mapped from YANG variable /nsd_catalog/nsd/key_pair/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key associated with this key pair
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="key" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__key = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=unicode , is_leaf=True , yang_name="key" , parent=self ,
                                  path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                  yang_type='string' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    key = __builtin__.property(_get_key , _set_key)

    _pyangbind_elements = {'name': name , 'key': key , }


class yc_key_pair_nsd__nsd_catalog_nsd_user_key_pair(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/user/key-pair. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Used to configure the list of public keys to be injected as part
of ns instantiation
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__key' ,)

    _yang_name = 'key-pair'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)
        self.__key = YANGDynClass(base=unicode , is_leaf=True , yang_name="key" , parent=self ,
                                  path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                  yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'user' , u'key-pair']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/user/key_pair/name (string)

    YANG Description: Name of this key pair
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/user/key_pair/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of this key pair
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd_catalog/nsd/user/key_pair/key (string)

    YANG Description: Key associated with this key pair
    """
        return self.__key

    def _set_key(self , v , load=False):
        """
    Setter method for key, mapped from YANG variable /nsd_catalog/nsd/user/key_pair/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Key associated with this key pair
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="key" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__key = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=unicode , is_leaf=True , yang_name="key" , parent=self ,
                                  path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                  yang_type='string' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    key = __builtin__.property(_get_key , _set_key)

    _pyangbind_elements = {'name': name , 'key': key , }


class yc_user_nsd__nsd_catalog_nsd_user(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/user. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of users to be added through cloud-config
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__user_info' , '__key_pair' ,)

    _yang_name = 'user'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__user_info = YANGDynClass(base=unicode , is_leaf=True , yang_name="user-info" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                        defining_module='nsd' , yang_type='string' , is_config=True)
        self.__key_pair = YANGDynClass(
            base=YANGListType("name" , yc_key_pair_nsd__nsd_catalog_nsd_user_key_pair , yang_name="key-pair" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='name' , extensions=None) , is_container='list' , yang_name="key-pair" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='list' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'user']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/user/name (string)

    YANG Description: Name of the user
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/user/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the user
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_user_info(self):
        """
    Getter method for user_info, mapped from YANG variable /nsd_catalog/nsd/user/user_info (string)

    YANG Description: The user name's real name
    """
        return self.__user_info

    def _set_user_info(self , v , load=False):
        """
    Setter method for user_info, mapped from YANG variable /nsd_catalog/nsd/user/user_info (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_info() directly.

    YANG Description: The user name's real name
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="user-info" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """user_info must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="user-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__user_info = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_user_info(self):
        self.__user_info = YANGDynClass(base=unicode , is_leaf=True , yang_name="user-info" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                        defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_key_pair(self):
        """
    Getter method for key_pair, mapped from YANG variable /nsd_catalog/nsd/user/key_pair (list)

    YANG Description: Used to configure the list of public keys to be injected as part
of ns instantiation
    """
        return self.__key_pair

    def _set_key_pair(self , v , load=False):
        """
    Setter method for key_pair, mapped from YANG variable /nsd_catalog/nsd/user/key_pair (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_pair is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_pair() directly.

    YANG Description: Used to configure the list of public keys to be injected as part
of ns instantiation
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" , yc_key_pair_nsd__nsd_catalog_nsd_user_key_pair ,
                                                   yang_name="key-pair" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="key-pair" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """key_pair must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_key_pair_nsd__nsd_catalog_nsd_user_key_pair, yang_name="key-pair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="key-pair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__key_pair = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_key_pair(self):
        self.__key_pair = YANGDynClass(
            base=YANGListType("name" , yc_key_pair_nsd__nsd_catalog_nsd_user_key_pair , yang_name="key-pair" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='name' , extensions=None) , is_container='list' , yang_name="key-pair" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='list' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    user_info = __builtin__.property(_get_user_info , _set_user_info)
    key_pair = __builtin__.property(_get_key_pair , _set_key_pair)

    _pyangbind_elements = {'name': name , 'user_info': user_info , 'key_pair': key_pair , }


class yc_provider_network_nsd__nsd_catalog_nsd_vld_provider_network(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vld/provider-network. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the provider network.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__physical_network' , '__segmentation_id' ,)

    _yang_name = 'provider-network'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__segmentation_id = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="segmentation_id" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)
        self.__physical_network = YANGDynClass(base=unicode , is_leaf=True , yang_name="physical-network" ,
                                               parent=self , path_helper=self._path_helper ,
                                               extmethods=self._extmethods , register_paths=True ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                               defining_module='nsd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'vld' , u'provider-network']

    def _get_physical_network(self):
        """
    Getter method for physical_network, mapped from YANG variable /nsd_catalog/nsd/vld/provider_network/physical_network (string)

    YANG Description: Name of the physical network on which the provider
network is built.
    """
        return self.__physical_network

    def _set_physical_network(self , v , load=False):
        """
    Setter method for physical_network, mapped from YANG variable /nsd_catalog/nsd/vld/provider_network/physical_network (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_network() directly.

    YANG Description: Name of the physical network on which the provider
network is built.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="physical-network" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """physical_network must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="physical-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__physical_network = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_physical_network(self):
        self.__physical_network = YANGDynClass(base=unicode , is_leaf=True , yang_name="physical-network" ,
                                               parent=self , path_helper=self._path_helper ,
                                               extmethods=self._extmethods , register_paths=True ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                               defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_segmentation_id(self):
        """
    Getter method for segmentation_id, mapped from YANG variable /nsd_catalog/nsd/vld/provider_network/segmentation_id (uint32)

    YANG Description: ID of segregated virtual networks
    """
        return self.__segmentation_id

    def _set_segmentation_id(self , v , load=False):
        """
    Setter method for segmentation_id, mapped from YANG variable /nsd_catalog/nsd/vld/provider_network/segmentation_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_segmentation_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_segmentation_id() directly.

    YANG Description: ID of segregated virtual networks
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , is_leaf=True , yang_name="segmentation_id" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """segmentation_id must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""" ,
            })

        self.__segmentation_id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_segmentation_id(self):
        self.__segmentation_id = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="segmentation_id" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint32' , is_config=True)

    physical_network = __builtin__.property(_get_physical_network , _set_physical_network)
    segmentation_id = __builtin__.property(_get_segmentation_id , _set_segmentation_id)

    _pyangbind_elements = {'physical_network': physical_network , 'segmentation_id': segmentation_id , }


class yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vld_vnfd_connection_point_ref(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vld/vnfd-connection-point-ref. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of references to connection points.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__member_vnf_index_ref' , '__vnfd_connection_point_ref' , '__vnfd_id_ref' ,
    '__ip_address' ,)

    _yang_name = 'vnfd-connection-point-ref'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnfd_connection_point_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                        yang_name="vnfd-connection-point-ref" , parent=self ,
                                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                                        register_paths=True , is_keyval=True ,
                                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                        defining_module='nsd' , yang_type='leafref' , is_config=True)
        self.__member_vnf_index_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" ,
                                                   parent=self , path_helper=self._path_helper ,
                                                   extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='leafref' , is_config=True)
        self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                               RestrictedClassType(base_type=unicode , restriction_dict={
                                                   'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                         is_leaf=True , yang_name="ip-address" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                         defining_module='nsd' , yang_type='inet:ip-address' , is_config=True)
        self.__vnfd_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='leafref' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'vld' , u'vnfd-connection-point-ref']

    def _get_member_vnf_index_ref(self):
        """
    Getter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref/member_vnf_index_ref (leafref)

    YANG Description: Reference to member-vnf within constituent-vnfds
    """
        return self.__member_vnf_index_ref

    def _set_member_vnf_index_ref(self , v , load=False):
        """
    Setter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref/member_vnf_index_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index_ref() directly.

    YANG Description: Reference to member-vnf within constituent-vnfds
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """member_vnf_index_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__member_vnf_index_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_member_vnf_index_ref(self):
        self.__member_vnf_index_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" ,
                                                   parent=self , path_helper=self._path_helper ,
                                                   extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_vnfd_connection_point_ref(self):
        """
    Getter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref/vnfd_connection_point_ref (leafref)

    YANG Description: A reference to a connection point name
    """
        return self.__vnfd_connection_point_ref

    def _set_vnfd_connection_point_ref(self , v , load=False):
        """
    Setter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref/vnfd_connection_point_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_connection_point_ref() directly.

    YANG Description: A reference to a connection point name
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnfd-connection-point-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_connection_point_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vnfd_connection_point_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_connection_point_ref(self):
        self.__vnfd_connection_point_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                        yang_name="vnfd-connection-point-ref" , parent=self ,
                                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                                        register_paths=True , is_keyval=True ,
                                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                        defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_vnfd_id_ref(self):
        """
    Getter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref/vnfd_id_ref (leafref)

    YANG Description: A reference to a VNFD
    """
        return self.__vnfd_id_ref

    def _set_vnfd_id_ref(self , v , load=False):
        """
    Setter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref/vnfd_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id_ref() directly.

    YANG Description: A reference to a VNFD
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_id_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vnfd_id_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_id_ref(self):
        self.__vnfd_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_ip_address(self):
        """
    Getter method for ip_address, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref/ip_address (inet:ip-address)

    YANG Description: IP address of the connection point
    """
        return self.__ip_address

    def _set_ip_address(self , v , load=False):
        """
    Setter method for ip_address, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref/ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.

    YANG Description: IP address of the connection point
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=[RestrictedClassType(base_type=unicode , restriction_dict={
                'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                       RestrictedClassType(base_type=unicode , restriction_dict={
                                           'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                             is_leaf=True , yang_name="ip-address" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='inet:ip-address' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ip_address must be of a type compatible with inet:ip-address""" ,
                'defined-type': "inet:ip-address" ,
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=unicode, restriction_dict={'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='inet:ip-address', is_config=True)""" ,
            })

        self.__ip_address = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ip_address(self):
        self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=unicode , restriction_dict={
            'pattern': u'(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}) ,
                                               RestrictedClassType(base_type=unicode , restriction_dict={
                                                   'pattern': u'((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}) , ] ,
                                         is_leaf=True , yang_name="ip-address" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                         defining_module='nsd' , yang_type='inet:ip-address' , is_config=True)

    member_vnf_index_ref = __builtin__.property(_get_member_vnf_index_ref , _set_member_vnf_index_ref)
    vnfd_connection_point_ref = __builtin__.property(_get_vnfd_connection_point_ref , _set_vnfd_connection_point_ref)
    vnfd_id_ref = __builtin__.property(_get_vnfd_id_ref , _set_vnfd_id_ref)
    ip_address = __builtin__.property(_get_ip_address , _set_ip_address)

    _pyangbind_elements = {'member_vnf_index_ref': member_vnf_index_ref ,
                           'vnfd_connection_point_ref': vnfd_connection_point_ref , 'vnfd_id_ref': vnfd_id_ref ,
                           'ip_address': ip_address , }


class yc_vld_nsd__nsd_catalog_nsd_vld(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vld. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__id' , '__name' , '__short_name' , '__vendor' , '__description' , '__version' ,
    '__type' , '__root_bandwidth' , '__leaf_bandwidth' , '__provider_network' , '__mgmt_network' ,
    '__vim_network_name' , '__ip_profile_ref' , '__vnfd_connection_point_ref' ,)

    _yang_name = 'vld'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__leaf_bandwidth = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="leaf-bandwidth" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint64' ,
            is_config=True)
        self.__vnfd_connection_point_ref = YANGDynClass(
            base=YANGListType("member_vnf_index_ref vnfd_connection_point_ref" ,
                              yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vld_vnfd_connection_point_ref ,
                              yang_name="vnfd-connection-point-ref" , parent=self , is_container='list' ,
                              user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='member-vnf-index-ref vnfd-connection-point-ref' , extensions=None) ,
            is_container='list' , yang_name="vnfd-connection-point-ref" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__vendor = YANGDynClass(base=unicode , is_leaf=True , yang_name="vendor" , parent=self ,
                                     path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                     yang_type='string' , is_config=True)
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='string' , is_config=True)
        self.__short_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                         defining_module='nsd' , yang_type='string' , is_config=True)
        self.__root_bandwidth = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="root-bandwidth" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint64' ,
            is_config=True)
        self.__provider_network = YANGDynClass(base=yc_provider_network_nsd__nsd_catalog_nsd_vld_provider_network ,
                                               is_container='container' , yang_name="provider-network" , parent=self ,
                                               path_helper=self._path_helper , extmethods=self._extmethods ,
                                               register_paths=True , extensions=None ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                               defining_module='nsd' , yang_type='container' , is_config=True)
        self.__mgmt_network = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                           yang_name="mgmt-network" , parent=self , path_helper=self._path_helper ,
                                           extmethods=self._extmethods , register_paths=True ,
                                           namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                           yang_type='boolean' , is_config=True)
        self.__version = YANGDynClass(base=unicode , is_leaf=True , yang_name="version" , parent=self ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                      defining_module='nsd' , yang_type='string' , is_config=True)
        self.__ip_profile_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="ip-profile-ref" , parent=self ,
                                             choice=(u'init-params' , u'vim-network-profile') ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                             defining_module='nsd' , yang_type='leafref' , is_config=True)
        self.__vim_network_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="vim-network-name" ,
                                               parent=self , choice=(u'init-params' , u'vim-network-ref') ,
                                               path_helper=self._path_helper , extmethods=self._extmethods ,
                                               register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                               defining_module='nsd' , yang_type='string' , is_config=True)
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                            restriction_arg={u'ELAN': {} , u'ELINE': {}} , ) ,
                                   is_leaf=True , yang_name="type" , parent=self , path_helper=self._path_helper ,
                                   extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='manotypes:virtual-link-type' , is_config=True)
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                 defining_module='nsd' , yang_type='string' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'vld']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd_catalog/nsd/vld/id (string)

    YANG Description: Identifier for the VLD.
    """
        return self.__id

    def _set_id(self , v , load=False):
        """
    Setter method for id, mapped from YANG variable /nsd_catalog/nsd/vld/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the VLD.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                 defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/vld/name (string)

    YANG Description: Virtual Link Descriptor (VLD) name.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/vld/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Virtual Link Descriptor (VLD) name.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)

    def _get_short_name(self):
        """
    Getter method for short_name, mapped from YANG variable /nsd_catalog/nsd/vld/short_name (string)

    YANG Description: Short name to appear as label in the UI
    """
        return self.__short_name

    def _set_short_name(self , v , load=False):
        """
    Setter method for short_name, mapped from YANG variable /nsd_catalog/nsd/vld/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.

    YANG Description: Short name to appear as label in the UI
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """short_name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__short_name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_short_name(self):
        self.__short_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                         defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_vendor(self):
        """
    Getter method for vendor, mapped from YANG variable /nsd_catalog/nsd/vld/vendor (string)

    YANG Description: Provider of the VLD.
    """
        return self.__vendor

    def _set_vendor(self , v , load=False):
        """
    Setter method for vendor, mapped from YANG variable /nsd_catalog/nsd/vld/vendor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor() directly.

    YANG Description: Provider of the VLD.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vendor" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vendor must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__vendor = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vendor(self):
        self.__vendor = YANGDynClass(base=unicode , is_leaf=True , yang_name="vendor" , parent=self ,
                                     path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                     yang_type='string' , is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd_catalog/nsd/vld/description (string)

    YANG Description: Description of the VLD.
    """
        return self.__description

    def _set_description(self , v , load=False):
        """
    Setter method for description, mapped from YANG variable /nsd_catalog/nsd/vld/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the VLD.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__description = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_version(self):
        """
    Getter method for version, mapped from YANG variable /nsd_catalog/nsd/vld/version (string)

    YANG Description: Version of the VLD
    """
        return self.__version

    def _set_version(self , v , load=False):
        """
    Setter method for version, mapped from YANG variable /nsd_catalog/nsd/vld/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Version of the VLD
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="version" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """version must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__version = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(base=unicode , is_leaf=True , yang_name="version" , parent=self ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                      defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_type(self):
        """
    Getter method for type, mapped from YANG variable /nsd_catalog/nsd/vld/type (manotypes:virtual-link-type)
    """
        return self.__type

    def _set_type(self , v , load=False):
        """
    Setter method for type, mapped from YANG variable /nsd_catalog/nsd/vld/type (manotypes:virtual-link-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'ELAN': {} , u'ELINE': {}} , ) ,
                             is_leaf=True , yang_name="type" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='manotypes:virtual-link-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """type must be of a type compatible with manotypes:virtual-link-type""" ,
                'defined-type': "manotypes:virtual-link-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'ELAN': {}, u'ELINE': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='manotypes:virtual-link-type', is_config=True)""" ,
            })

        self.__type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                            restriction_arg={u'ELAN': {} , u'ELINE': {}} , ) ,
                                   is_leaf=True , yang_name="type" , parent=self , path_helper=self._path_helper ,
                                   extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='manotypes:virtual-link-type' , is_config=True)

    def _get_root_bandwidth(self):
        """
    Getter method for root_bandwidth, mapped from YANG variable /nsd_catalog/nsd/vld/root_bandwidth (uint64)

    YANG Description: For ELAN this is the aggregate bandwidth.
    """
        return self.__root_bandwidth

    def _set_root_bandwidth(self , v , load=False):
        """
    Setter method for root_bandwidth, mapped from YANG variable /nsd_catalog/nsd/vld/root_bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root_bandwidth() directly.

    YANG Description: For ELAN this is the aggregate bandwidth.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="root-bandwidth" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """root_bandwidth must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint64', is_config=True)""" ,
            })

        self.__root_bandwidth = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_root_bandwidth(self):
        self.__root_bandwidth = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="root-bandwidth" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint64' ,
            is_config=True)

    def _get_leaf_bandwidth(self):
        """
    Getter method for leaf_bandwidth, mapped from YANG variable /nsd_catalog/nsd/vld/leaf_bandwidth (uint64)

    YANG Description: For ELAN this is the bandwidth of branches.
    """
        return self.__leaf_bandwidth

    def _set_leaf_bandwidth(self , v , load=False):
        """
    Setter method for leaf_bandwidth, mapped from YANG variable /nsd_catalog/nsd/vld/leaf_bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leaf_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leaf_bandwidth() directly.

    YANG Description: For ELAN this is the bandwidth of branches.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="leaf-bandwidth" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """leaf_bandwidth must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="leaf-bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint64', is_config=True)""" ,
            })

        self.__leaf_bandwidth = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_leaf_bandwidth(self):
        self.__leaf_bandwidth = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="leaf-bandwidth" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint64' ,
            is_config=True)

    def _get_provider_network(self):
        """
    Getter method for provider_network, mapped from YANG variable /nsd_catalog/nsd/vld/provider_network (container)

    YANG Description: Container for the provider network.
    """
        return self.__provider_network

    def _set_provider_network(self , v , load=False):
        """
    Setter method for provider_network, mapped from YANG variable /nsd_catalog/nsd/vld/provider_network (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provider_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provider_network() directly.

    YANG Description: Container for the provider network.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_provider_network_nsd__nsd_catalog_nsd_vld_provider_network ,
                             is_container='container' , yang_name="provider-network" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """provider_network must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_provider_network_nsd__nsd_catalog_nsd_vld_provider_network, is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='container', is_config=True)""" ,
            })

        self.__provider_network = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_provider_network(self):
        self.__provider_network = YANGDynClass(base=yc_provider_network_nsd__nsd_catalog_nsd_vld_provider_network ,
                                               is_container='container' , yang_name="provider-network" , parent=self ,
                                               path_helper=self._path_helper , extmethods=self._extmethods ,
                                               register_paths=True , extensions=None ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                               defining_module='nsd' , yang_type='container' , is_config=True)

    def _get_mgmt_network(self):
        """
    Getter method for mgmt_network, mapped from YANG variable /nsd_catalog/nsd/vld/mgmt_network (boolean)

    YANG Description: Flag indicating whether this network is a VIM management network
    """
        return self.__mgmt_network

    def _set_mgmt_network(self , v , load=False):
        """
    Setter method for mgmt_network, mapped from YANG variable /nsd_catalog/nsd/vld/mgmt_network (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_network() directly.

    YANG Description: Flag indicating whether this network is a VIM management network
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="mgmt-network" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """mgmt_network must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""" ,
            })

        self.__mgmt_network = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_mgmt_network(self):
        self.__mgmt_network = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                           yang_name="mgmt-network" , parent=self , path_helper=self._path_helper ,
                                           extmethods=self._extmethods , register_paths=True ,
                                           namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                           yang_type='boolean' , is_config=True)

    def _get_vim_network_name(self):
        """
    Getter method for vim_network_name, mapped from YANG variable /nsd_catalog/nsd/vld/vim_network_name (string)

    YANG Description: Name of network in VIM account. This is used to indicate
      pre-provisioned network name in cloud account.
    """
        return self.__vim_network_name

    def _set_vim_network_name(self , v , load=False):
        """
    Setter method for vim_network_name, mapped from YANG variable /nsd_catalog/nsd/vld/vim_network_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vim_network_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vim_network_name() directly.

    YANG Description: Name of network in VIM account. This is used to indicate
      pre-provisioned network name in cloud account.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vim-network-name" , parent=self ,
                             choice=(u'init-params' , u'vim-network-ref') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vim_network_name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vim-network-name", parent=self, choice=(u'init-params', u'vim-network-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__vim_network_name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vim_network_name(self):
        self.__vim_network_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="vim-network-name" ,
                                               parent=self , choice=(u'init-params' , u'vim-network-ref') ,
                                               path_helper=self._path_helper , extmethods=self._extmethods ,
                                               register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                               defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_ip_profile_ref(self):
        """
    Getter method for ip_profile_ref, mapped from YANG variable /nsd_catalog/nsd/vld/ip_profile_ref (leafref)

    YANG Description: Named reference to IP-profile object
    """
        return self.__ip_profile_ref

    def _set_ip_profile_ref(self , v , load=False):
        """
    Setter method for ip_profile_ref, mapped from YANG variable /nsd_catalog/nsd/vld/ip_profile_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_profile_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_profile_ref() directly.

    YANG Description: Named reference to IP-profile object
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="ip-profile-ref" , parent=self ,
                             choice=(u'init-params' , u'vim-network-profile') , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ip_profile_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="ip-profile-ref", parent=self, choice=(u'init-params', u'vim-network-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__ip_profile_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ip_profile_ref(self):
        self.__ip_profile_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="ip-profile-ref" , parent=self ,
                                             choice=(u'init-params' , u'vim-network-profile') ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                             defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_vnfd_connection_point_ref(self):
        """
    Getter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref (list)

    YANG Description: A list of references to connection points.
    """
        return self.__vnfd_connection_point_ref

    def _set_vnfd_connection_point_ref(self , v , load=False):
        """
    Setter method for vnfd_connection_point_ref, mapped from YANG variable /nsd_catalog/nsd/vld/vnfd_connection_point_ref (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_connection_point_ref() directly.

    YANG Description: A list of references to connection points.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("member_vnf_index_ref vnfd_connection_point_ref" ,
                                                   yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vld_vnfd_connection_point_ref ,
                                                   yang_name="vnfd-connection-point-ref" , parent=self ,
                                                   is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper ,
                                                   yang_keys='member-vnf-index-ref vnfd-connection-point-ref' ,
                                                   extensions=None) , is_container='list' ,
                             yang_name="vnfd-connection-point-ref" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_connection_point_ref must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("member_vnf_index_ref vnfd_connection_point_ref",yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vld_vnfd_connection_point_ref, yang_name="vnfd-connection-point-ref", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref vnfd-connection-point-ref', extensions=None), is_container='list', yang_name="vnfd-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__vnfd_connection_point_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_connection_point_ref(self):
        self.__vnfd_connection_point_ref = YANGDynClass(
            base=YANGListType("member_vnf_index_ref vnfd_connection_point_ref" ,
                              yc_vnfd_connection_point_ref_nsd__nsd_catalog_nsd_vld_vnfd_connection_point_ref ,
                              yang_name="vnfd-connection-point-ref" , parent=self , is_container='list' ,
                              user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='member-vnf-index-ref vnfd-connection-point-ref' , extensions=None) ,
            is_container='list' , yang_name="vnfd-connection-point-ref" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    id = __builtin__.property(_get_id , _set_id)
    name = __builtin__.property(_get_name , _set_name)
    short_name = __builtin__.property(_get_short_name , _set_short_name)
    vendor = __builtin__.property(_get_vendor , _set_vendor)
    description = __builtin__.property(_get_description , _set_description)
    version = __builtin__.property(_get_version , _set_version)
    type = __builtin__.property(_get_type , _set_type)
    root_bandwidth = __builtin__.property(_get_root_bandwidth , _set_root_bandwidth)
    leaf_bandwidth = __builtin__.property(_get_leaf_bandwidth , _set_leaf_bandwidth)
    provider_network = __builtin__.property(_get_provider_network , _set_provider_network)
    mgmt_network = __builtin__.property(_get_mgmt_network , _set_mgmt_network)
    vim_network_name = __builtin__.property(_get_vim_network_name , _set_vim_network_name)
    ip_profile_ref = __builtin__.property(_get_ip_profile_ref , _set_ip_profile_ref)
    vnfd_connection_point_ref = __builtin__.property(_get_vnfd_connection_point_ref , _set_vnfd_connection_point_ref)

    __choices__ = {
        u'init-params': {u'vim-network-profile': [u'ip_profile_ref'] , u'vim-network-ref': [u'vim_network_name']}}
    _pyangbind_elements = {'id': id , 'name': name , 'short_name': short_name , 'vendor': vendor ,
                           'description': description , 'version': version , 'type': type ,
                           'root_bandwidth': root_bandwidth , 'leaf_bandwidth': leaf_bandwidth ,
                           'provider_network': provider_network , 'mgmt_network': mgmt_network ,
                           'vim_network_name': vim_network_name , 'ip_profile_ref': ip_profile_ref ,
                           'vnfd_connection_point_ref': vnfd_connection_point_ref , }


class yc_constituent_vnfd_nsd__nsd_catalog_nsd_constituent_vnfd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/constituent-vnfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VNFDs that are part of this
network service.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__member_vnf_index' , '__vnfd_id_ref' , '__start_by_default' ,)

    _yang_name = 'constituent-vnfd'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__member_vnf_index = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index" ,
                                               parent=self , path_helper=self._path_helper ,
                                               extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                               defining_module='nsd' , yang_type='string' , is_config=True)
        self.__start_by_default = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True ,
                                               yang_name="start-by-default" , parent=self ,
                                               path_helper=self._path_helper , extmethods=self._extmethods ,
                                               register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                               defining_module='nsd' , yang_type='boolean' , is_config=True)
        self.__vnfd_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='leafref' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'constituent-vnfd']

    def _get_member_vnf_index(self):
        """
    Getter method for member_vnf_index, mapped from YANG variable /nsd_catalog/nsd/constituent_vnfd/member_vnf_index (string)

    YANG Description: Identifier/index for the VNFD. This separate id
is required to ensure that multiple VNFs can be
part of single NS
    """
        return self.__member_vnf_index

    def _set_member_vnf_index(self , v , load=False):
        """
    Setter method for member_vnf_index, mapped from YANG variable /nsd_catalog/nsd/constituent_vnfd/member_vnf_index (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index() directly.

    YANG Description: Identifier/index for the VNFD. This separate id
is required to ensure that multiple VNFs can be
part of single NS
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="member-vnf-index" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """member_vnf_index must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="member-vnf-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__member_vnf_index = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_member_vnf_index(self):
        self.__member_vnf_index = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index" ,
                                               parent=self , path_helper=self._path_helper ,
                                               extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                               namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                               defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_vnfd_id_ref(self):
            """
    Getter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/constituent_vnfd/vnfd_id_ref (leafref)

    YANG Description: Identifier for the VNFD.
    """

    return self.__vnfd_id_ref


def _set_vnfd_id_ref(self , v , load=False):
    """
    Setter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/constituent_vnfd/vnfd_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id_ref() directly.

    YANG Description: Identifier for the VNFD.
    """
    if hasattr(v , "_utype"):
        v = v._utype(v)
    try:
        t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                         path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                         namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                         yang_type='leafref' , is_config=True)
    except (TypeError , ValueError):
        raise ValueError({
            'error-string': """vnfd_id_ref must be of a type compatible with leafref""" ,
            'defined-type': "leafref" ,
            'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
        })

    self.__vnfd_id_ref = t
    if hasattr(self , '_set'):
        self._set()


def _unset_vnfd_id_ref(self):
    self.__vnfd_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                      defining_module='nsd' , yang_type='leafref' , is_config=True)


def _get_start_by_default(self):
    """
    Getter method for start_by_default, mapped from YANG variable /nsd_catalog/nsd/constituent_vnfd/start_by_default (boolean)

    YANG Description: VNFD is started as part of the NS instantiation
    """
    return self.__start_by_default


def _set_start_by_default(self , v , load=False):
    """
    Setter method for start_by_default, mapped from YANG variable /nsd_catalog/nsd/constituent_vnfd/start_by_default (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start_by_default is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start_by_default() directly.

    YANG Description: VNFD is started as part of the NS instantiation
    """
    if hasattr(v , "_utype"):
        v = v._utype(v)
    try:
        t = YANGDynClass(v , base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="start-by-default" ,
                         parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                         defining_module='nsd' , yang_type='boolean' , is_config=True)
    except (TypeError , ValueError):
        raise ValueError({
            'error-string': """start_by_default must be of a type compatible with boolean""" ,
            'defined-type': "boolean" ,
            'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="start-by-default", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""" ,
        })

    self.__start_by_default = t
    if hasattr(self , '_set'):
        self._set()


def _unset_start_by_default(self):
    self.__start_by_default = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True ,
                                           yang_name="start-by-default" , parent=self , path_helper=self._path_helper ,
                                           extmethods=self._extmethods , register_paths=True ,
                                           namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                           yang_type='boolean' , is_config=True)


member_vnf_index = __builtin__.property(_get_member_vnf_index , _set_member_vnf_index)
vnfd_id_ref = __builtin__.property(_get_vnfd_id_ref , _set_vnfd_id_ref)
start_by_default = __builtin__.property(_get_start_by_default , _set_start_by_default)

_pyangbind_elements = {'member_vnf_index': member_vnf_index , 'vnfd_id_ref': vnfd_id_ref ,
                       'start_by_default': start_by_default , }


class yc_member_vnfd_nsd__nsd_catalog_nsd_placement_groups_member_vnfd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/placement-groups/member-vnfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VNFDs that are part of this placement group
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__member_vnf_index_ref' , '__vnfd_id_ref' ,)

    _yang_name = 'member-vnfd'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__member_vnf_index_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" ,
                                                   parent=self , path_helper=self._path_helper ,
                                                   extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='leafref' , is_config=True)
        self.__vnfd_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='leafref' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'placement-groups' , u'member-vnfd']

    def _get_member_vnf_index_ref(self):
        """
    Getter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/placement_groups/member_vnfd/member_vnf_index_ref (leafref)

    YANG Description: Member VNF index of this member VNF
    """
        return self.__member_vnf_index_ref

    def _set_member_vnf_index_ref(self , v , load=False):
        """
    Setter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/placement_groups/member_vnfd/member_vnf_index_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index_ref() directly.

    YANG Description: Member VNF index of this member VNF
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """member_vnf_index_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__member_vnf_index_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_member_vnf_index_ref(self):
        self.__member_vnf_index_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" ,
                                                   parent=self , path_helper=self._path_helper ,
                                                   extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_vnfd_id_ref(self):
        """
    Getter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/placement_groups/member_vnfd/vnfd_id_ref (leafref)

    YANG Description: Identifier for the VNFD.
    """
        return self.__vnfd_id_ref

    def _set_vnfd_id_ref(self , v , load=False):
        """
    Setter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/placement_groups/member_vnfd/vnfd_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id_ref() directly.

    YANG Description: Identifier for the VNFD.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_id_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vnfd_id_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_id_ref(self):
        self.__vnfd_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='leafref' , is_config=True)

    member_vnf_index_ref = __builtin__.property(_get_member_vnf_index_ref , _set_member_vnf_index_ref)
    vnfd_id_ref = __builtin__.property(_get_vnfd_id_ref , _set_vnfd_id_ref)

    _pyangbind_elements = {'member_vnf_index_ref': member_vnf_index_ref , 'vnfd_id_ref': vnfd_id_ref , }


class yc_placement_groups_nsd__nsd_catalog_nsd_placement_groups(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/placement-groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of placement groups at NS level
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__requirement' , '__strategy' , '__member_vnfd' ,)

    _yang_name = 'placement-groups'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__requirement = YANGDynClass(base=unicode , is_leaf=True , yang_name="requirement" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='string' , is_config=True)
        self.__member_vnfd = YANGDynClass(base=YANGListType("member_vnf_index_ref" ,
                                                            yc_member_vnfd_nsd__nsd_catalog_nsd_placement_groups_member_vnfd ,
                                                            yang_name="member-vnfd" , parent=self ,
                                                            is_container='list' , user_ordered=False ,
                                                            path_helper=self._path_helper ,
                                                            yang_keys='member-vnf-index-ref' , extensions=None) ,
                                          is_container='list' , yang_name="member-vnfd" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , extensions=None ,
                                          namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                          yang_type='list' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)
        self.__strategy = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                restriction_arg={u'COLOCATION': {} ,
                                                                                 u'ISOLATION': {}} , ) ,
                                       default=unicode("COLOCATION") , is_leaf=True , yang_name="strategy" ,
                                       parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                       defining_module='nsd' , yang_type='enumeration' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'placement-groups']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/placement_groups/name (string)

    YANG Description: Place group construct to define the compute resource placement strategy
in cloud environment
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/placement_groups/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Place group construct to define the compute resource placement strategy
in cloud environment
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_requirement(self):
        """
    Getter method for requirement, mapped from YANG variable /nsd_catalog/nsd/placement_groups/requirement (string)

    YANG Description: This is free text space used to describe the intent/rationale
behind this placement group. This is for human consumption only
    """
        return self.__requirement

    def _set_requirement(self , v , load=False):
        """
    Setter method for requirement, mapped from YANG variable /nsd_catalog/nsd/placement_groups/requirement (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_requirement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_requirement() directly.

    YANG Description: This is free text space used to describe the intent/rationale
behind this placement group. This is for human consumption only
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="requirement" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """requirement must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__requirement = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_requirement(self):
        self.__requirement = YANGDynClass(base=unicode , is_leaf=True , yang_name="requirement" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_strategy(self):
        """
    Getter method for strategy, mapped from YANG variable /nsd_catalog/nsd/placement_groups/strategy (enumeration)

    YANG Description: Strategy associated with this placement group
  Following values are possible
    - COLOCATION: Colocation strategy imply intent to share the physical
                  infrastructure (hypervisor/network) among all members
                  of this group.
    - ISOLATION: Isolation strategy imply intent to not share the physical
                 infrastructure (hypervisor/network) among the members
                 of this group.

    """
        return self.__strategy

    def _set_strategy(self , v , load=False):
        """
    Setter method for strategy, mapped from YANG variable /nsd_catalog/nsd/placement_groups/strategy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_strategy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_strategy() directly.

    YANG Description: Strategy associated with this placement group
  Following values are possible
    - COLOCATION: Colocation strategy imply intent to share the physical
                  infrastructure (hypervisor/network) among all members
                  of this group.
    - ISOLATION: Isolation strategy imply intent to not share the physical
                 infrastructure (hypervisor/network) among the members
                 of this group.

    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'COLOCATION': {} , u'ISOLATION': {}} , ) ,
                             default=unicode("COLOCATION") , is_leaf=True , yang_name="strategy" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='enumeration' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """strategy must be of a type compatible with enumeration""" ,
                'defined-type': "nsd:enumeration" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'COLOCATION': {}, u'ISOLATION': {}},), default=unicode("COLOCATION"), is_leaf=True, yang_name="strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='enumeration', is_config=True)""" ,
            })

        self.__strategy = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_strategy(self):
        self.__strategy = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                restriction_arg={u'COLOCATION': {} ,
                                                                                 u'ISOLATION': {}} , ) ,
                                       default=unicode("COLOCATION") , is_leaf=True , yang_name="strategy" ,
                                       parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                       register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                       defining_module='nsd' , yang_type='enumeration' , is_config=True)

    def _get_member_vnfd(self):
        """
    Getter method for member_vnfd, mapped from YANG variable /nsd_catalog/nsd/placement_groups/member_vnfd (list)

    YANG Description: List of VNFDs that are part of this placement group
    """
        return self.__member_vnfd

    def _set_member_vnfd(self , v , load=False):
        """
    Setter method for member_vnfd, mapped from YANG variable /nsd_catalog/nsd/placement_groups/member_vnfd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnfd() directly.

    YANG Description: List of VNFDs that are part of this placement group
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("member_vnf_index_ref" ,
                                                   yc_member_vnfd_nsd__nsd_catalog_nsd_placement_groups_member_vnfd ,
                                                   yang_name="member-vnfd" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='member-vnf-index-ref' , extensions=None) ,
                             is_container='list' , yang_name="member-vnfd" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """member_vnfd must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("member_vnf_index_ref",yc_member_vnfd_nsd__nsd_catalog_nsd_placement_groups_member_vnfd, yang_name="member-vnfd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref', extensions=None), is_container='list', yang_name="member-vnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__member_vnfd = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_member_vnfd(self):
        self.__member_vnfd = YANGDynClass(base=YANGListType("member_vnf_index_ref" ,
                                                            yc_member_vnfd_nsd__nsd_catalog_nsd_placement_groups_member_vnfd ,
                                                            yang_name="member-vnfd" , parent=self ,
                                                            is_container='list' , user_ordered=False ,
                                                            path_helper=self._path_helper ,
                                                            yang_keys='member-vnf-index-ref' , extensions=None) ,
                                          is_container='list' , yang_name="member-vnfd" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , extensions=None ,
                                          namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                          yang_type='list' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    requirement = __builtin__.property(_get_requirement , _set_requirement)
    strategy = __builtin__.property(_get_strategy , _set_strategy)
    member_vnfd = __builtin__.property(_get_member_vnfd , _set_member_vnfd)

    _pyangbind_elements = {'name': name , 'requirement': requirement , 'strategy': strategy ,
                           'member_vnfd': member_vnfd , }


class yc_vnf_dependency_nsd__nsd_catalog_nsd_vnf_dependency(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/vnf-dependency. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VNF dependencies.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__vnf_source_ref' , '__vnf_depends_on_ref' ,)

    _yang_name = 'vnf-dependency'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnf_source_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnf-source-ref" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , is_keyval=True ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                             yang_type='leafref' , is_config=True)
        self.__vnf_depends_on_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnf-depends-on-ref" ,
                                                 parent=self , path_helper=self._path_helper ,
                                                 extmethods=self._extmethods , register_paths=True ,
                                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                 defining_module='nsd' , yang_type='leafref' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'vnf-dependency']

    def _get_vnf_source_ref(self):
        """
    Getter method for vnf_source_ref, mapped from YANG variable /nsd_catalog/nsd/vnf_dependency/vnf_source_ref (leafref)
    """
        return self.__vnf_source_ref

    def _set_vnf_source_ref(self , v , load=False):
        """
    Setter method for vnf_source_ref, mapped from YANG variable /nsd_catalog/nsd/vnf_dependency/vnf_source_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_source_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_source_ref() directly.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnf-source-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnf_source_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnf-source-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vnf_source_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnf_source_ref(self):
        self.__vnf_source_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnf-source-ref" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , is_keyval=True ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                             yang_type='leafref' , is_config=True)

    def _get_vnf_depends_on_ref(self):
        """
    Getter method for vnf_depends_on_ref, mapped from YANG variable /nsd_catalog/nsd/vnf_dependency/vnf_depends_on_ref (leafref)

    YANG Description: Reference to VNF that sorce VNF depends.
    """
        return self.__vnf_depends_on_ref

    def _set_vnf_depends_on_ref(self , v , load=False):
        """
    Setter method for vnf_depends_on_ref, mapped from YANG variable /nsd_catalog/nsd/vnf_dependency/vnf_depends_on_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_depends_on_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_depends_on_ref() directly.

    YANG Description: Reference to VNF that sorce VNF depends.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnf-depends-on-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnf_depends_on_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnf-depends-on-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vnf_depends_on_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnf_depends_on_ref(self):
        self.__vnf_depends_on_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnf-depends-on-ref" ,
                                                 parent=self , path_helper=self._path_helper ,
                                                 extmethods=self._extmethods , register_paths=True ,
                                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                 defining_module='nsd' , yang_type='leafref' , is_config=True)

    vnf_source_ref = __builtin__.property(_get_vnf_source_ref , _set_vnf_source_ref)
    vnf_depends_on_ref = __builtin__.property(_get_vnf_depends_on_ref , _set_vnf_depends_on_ref)

    _pyangbind_elements = {'vnf_source_ref': vnf_source_ref , 'vnf_depends_on_ref': vnf_depends_on_ref , }


class yc_numeric_constraints_nsd__nsd_catalog_nsd_monitoring_param_numeric_constraints(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/monitoring-param/numeric-constraints. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__min_value' , '__max_value' ,)

    _yang_name = 'numeric-constraints'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__max_value = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="max-value" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint64' ,
            is_config=True)
        self.__min_value = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="min-value" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint64' ,
            is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'monitoring-param' , u'numeric-constraints']

    def _get_min_value(self):
        """
    Getter method for min_value, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/numeric_constraints/min_value (uint64)

    YANG Description: Minimum value for the parameter
    """
        return self.__min_value

    def _set_min_value(self , v , load=False):
        """
    Setter method for min_value, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/numeric_constraints/min_value (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_value() directly.

    YANG Description: Minimum value for the parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="min-value" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """min_value must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint64', is_config=True)""" ,
            })

        self.__min_value = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_min_value(self):
        self.__min_value = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="min-value" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint64' ,
            is_config=True)

    def _get_max_value(self):
        """
    Getter method for max_value, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/numeric_constraints/max_value (uint64)

    YANG Description: Maximum value for the parameter
    """
        return self.__max_value

    def _set_max_value(self , v , load=False):
        """
    Setter method for max_value, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/numeric_constraints/max_value (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_value() directly.

    YANG Description: Maximum value for the parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long ,
                                                          restriction_dict={'range': ['0..18446744073709551615']} ,
                                                          int_size=64) , is_leaf=True , yang_name="max-value" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='uint64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """max_value must be of a type compatible with uint64""" ,
                'defined-type': "uint64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint64', is_config=True)""" ,
            })

        self.__max_value = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_max_value(self):
        self.__max_value = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..18446744073709551615']} ,
                                     int_size=64) , is_leaf=True , yang_name="max-value" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint64' ,
            is_config=True)

    min_value = __builtin__.property(_get_min_value , _set_min_value)
    max_value = __builtin__.property(_get_max_value , _set_max_value)

    _pyangbind_elements = {'min_value': min_value , 'max_value': max_value , }


class yc_text_constraints_nsd__nsd_catalog_nsd_monitoring_param_text_constraints(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/monitoring-param/text-constraints. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__min_length' , '__max_length' ,)

    _yang_name = 'text-constraints'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__min_length = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="min-length" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint8' , is_config=True)
        self.__max_length = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="max-length" , parent=self , path_helper=self._path_helper , \
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint8' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'monitoring-param' , u'text-constraints']

    def _get_min_length(self):
        """
    Getter method for min_length, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/text_constraints/min_length (uint8)

    YANG Description: Minimum string length for the parameter
    """
        return self.__min_length

    def _set_min_length(self , v , load=False):
        """
    Setter method for min_length, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/text_constraints/min_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_length() directly.

    YANG Description: Minimum string length for the parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} ,
                                                          int_size=8) , is_leaf=True , yang_name="min-length" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='uint8' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """min_length must be of a type compatible with uint8""" ,
                'defined-type': "uint8" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="min-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint8', is_config=True)""" ,
            })

        self.__min_length = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_min_length(self):
        self.__min_length = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="min-length" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint8' , is_config=True)

    def _get_max_length(self):
        """
    Getter method for max_length, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/text_constraints/max_length (uint8)

    YANG Description: Maximum string length for the parameter
    """
        return self.__max_length

    def _set_max_length(self , v , load=False):
        """
    Setter method for max_length, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/text_constraints/max_length (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_length() directly.

    YANG Description: Maximum string length for the parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} ,
                                                          int_size=8) , is_leaf=True , yang_name="max-length" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='uint8' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """max_length must be of a type compatible with uint8""" ,
                'defined-type': "uint8" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint8', is_config=True)""" ,
            })

        self.__max_length = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_max_length(self):
        self.__max_length = YANGDynClass(
            base=RestrictedClassType(base_type=int , restriction_dict={'range': ['0..255']} , int_size=8) ,
            is_leaf=True , yang_name="max-length" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='uint8' , is_config=True)

    min_length = __builtin__.property(_get_min_length , _set_min_length)
    max_length = __builtin__.property(_get_max_length , _set_max_length)

    _pyangbind_elements = {'min_length': min_length , 'max_length': max_length , }


class yc_vnfd_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param_vnfd_monitoring_param(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/monitoring-param/vnfd-monitoring-param. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of VNFD monitoring params
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__vnfd_id_ref' , '__vnfd_monitoring_param_ref' , '__member_vnf_index_ref' ,)

    _yang_name = 'vnfd-monitoring-param'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__member_vnf_index_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" ,
                                                   parent=self , path_helper=self._path_helper ,
                                                   extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='leafref' , is_config=True)
        self.__vnfd_monitoring_param_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                        yang_name="vnfd-monitoring-param-ref" , parent=self ,
                                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                                        register_paths=True , is_keyval=True ,
                                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                        defining_module='nsd' , yang_type='leafref' , is_config=True)
        self.__vnfd_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='leafref' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'monitoring-param' , u'vnfd-monitoring-param']

    def _get_vnfd_id_ref(self):
        """
    Getter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/vnfd_monitoring_param/vnfd_id_ref (leafref)

    YANG Description: A reference to a VNFD. This is a leafref
    """
        return self.__vnfd_id_ref

    def _set_vnfd_id_ref(self , v , load=False):
        """
    Setter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/vnfd_monitoring_param/vnfd_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id_ref() directly.

    YANG Description: A reference to a VNFD. This is a leafref
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_id_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vnfd_id_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_id_ref(self):
        self.__vnfd_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_vnfd_monitoring_param_ref(self):
        """
    Getter method for vnfd_monitoring_param_ref, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/vnfd_monitoring_param/vnfd_monitoring_param_ref (leafref)

    YANG Description: A reference to the VNFD monitoring param
    """
        return self.__vnfd_monitoring_param_ref

    def _set_vnfd_monitoring_param_ref(self , v , load=False):
        """
    Setter method for vnfd_monitoring_param_ref, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/vnfd_monitoring_param/vnfd_monitoring_param_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_monitoring_param_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_monitoring_param_ref() directly.

    YANG Description: A reference to the VNFD monitoring param
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnfd-monitoring-param-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_monitoring_param_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnfd-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vnfd_monitoring_param_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_monitoring_param_ref(self):
        self.__vnfd_monitoring_param_ref = YANGDynClass(base=unicode , is_leaf=True ,
                                                        yang_name="vnfd-monitoring-param-ref" , parent=self ,
                                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                                        register_paths=True , is_keyval=True ,
                                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                        defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_member_vnf_index_ref(self):
        """
    Getter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/vnfd_monitoring_param/member_vnf_index_ref (leafref)

    YANG Description: Mandatory reference to member-vnf within constituent-vnfds
    """
        return self.__member_vnf_index_ref

    def _set_member_vnf_index_ref(self , v , load=False):
        """
    Setter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/vnfd_monitoring_param/member_vnf_index_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index_ref() directly.

    YANG Description: Mandatory reference to member-vnf within constituent-vnfds
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """member_vnf_index_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__member_vnf_index_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_member_vnf_index_ref(self):
        self.__member_vnf_index_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" ,
                                                   parent=self , path_helper=self._path_helper ,
                                                   extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='leafref' , is_config=True)

    vnfd_id_ref = __builtin__.property(_get_vnfd_id_ref , _set_vnfd_id_ref)
    vnfd_monitoring_param_ref = __builtin__.property(_get_vnfd_monitoring_param_ref , _set_vnfd_monitoring_param_ref)
    member_vnf_index_ref = __builtin__.property(_get_member_vnf_index_ref , _set_member_vnf_index_ref)

    _pyangbind_elements = {'vnfd_id_ref': vnfd_id_ref , 'vnfd_monitoring_param_ref': vnfd_monitoring_param_ref ,
                           'member_vnf_index_ref': member_vnf_index_ref , }


class yc_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/monitoring-param. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__id' , '__name' , '__value_type' , '__numeric_constraints' ,
                 '__text_constraints' , '__value_integer' , '__value_decimal' , '__value_string' , '__description' ,
                 '__group_tag' , '__widget_type' , '__units' , '__aggregation_type' , '__vnfd_monitoring_param' ,)

    _yang_name = 'monitoring-param'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__value_integer = YANGDynClass(base=RestrictedClassType(base_type=long , restriction_dict={
            'range': ['-9223372036854775808..9223372036854775807']} , int_size=64) , is_leaf=True ,
                                            yang_name="value-integer" , parent=self , path_helper=self._path_helper ,
                                            extmethods=self._extmethods , register_paths=True ,
                                            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                            yang_type='int64' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)
        self.__vnfd_monitoring_param = YANGDynClass(base=YANGListType("member_vnf_index_ref vnfd_monitoring_param_ref" ,
                                                                      yc_vnfd_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param_vnfd_monitoring_param ,
                                                                      yang_name="vnfd-monitoring-param" , parent=self ,
                                                                      is_container='list' , user_ordered=False ,
                                                                      path_helper=self._path_helper ,
                                                                      yang_keys='member-vnf-index-ref vnfd-monitoring-param-ref' ,
                                                                      extensions=None) , is_container='list' ,
                                                    yang_name="vnfd-monitoring-param" , parent=self ,
                                                    path_helper=self._path_helper , extmethods=self._extmethods ,
                                                    register_paths=True , extensions=None ,
                                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                    defining_module='nsd' , yang_type='list' , is_config=True)
        self.__text_constraints = YANGDynClass(
            base=yc_text_constraints_nsd__nsd_catalog_nsd_monitoring_param_text_constraints , is_container='container' ,
            yang_name="text-constraints" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='container' , is_config=True)
        self.__group_tag = YANGDynClass(base=unicode , is_leaf=True , yang_name="group-tag" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                        defining_module='nsd' , yang_type='string' , is_config=True)
        self.__value_string = YANGDynClass(base=unicode , is_leaf=True , yang_name="value-string" , parent=self ,
                                           path_helper=self._path_helper , extmethods=self._extmethods ,
                                           register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                           defining_module='nsd' , yang_type='string' , is_config=True)
        self.__widget_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                   restriction_arg={u'BAR': {} , u'COUNTER': {} ,
                                                                                    u'HISTOGRAM': {} , u'SLIDER': {} ,
                                                                                    u'GAUGE': {} , u'TEXTBOX': {}} , ) ,
                                          default=unicode("COUNTER") , is_leaf=True , yang_name="widget-type" ,
                                          parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='manotypes:widget-type' , is_config=True)
        self.__aggregation_type = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'COUNT': {} , u'AVERAGE': {} , u'MINIMUM': {} , u'SUM': {} ,
                                                      u'MAXIMUM': {}} , ) , is_leaf=True ,
            yang_name="aggregation-type" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='aggregation-type' , is_config=True)
        self.__value_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                  restriction_arg={u'INT': {} , u'DECIMAL': {} ,
                                                                                   u'STRING': {}} , ) ,
                                         default=unicode("INT") , is_leaf=True , yang_name="value-type" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                         defining_module='nsd' , yang_type='param-value-type' , is_config=True)
        self.__value_decimal = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4) , is_leaf=True ,
                                            yang_name="value-decimal" , parent=self , path_helper=self._path_helper ,
                                            extmethods=self._extmethods , register_paths=True ,
                                            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                            yang_type='decimal64' , is_config=True)
        self.__units = YANGDynClass(base=unicode , is_leaf=True , yang_name="units" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                    yang_type='string' , is_config=True)
        self.__numeric_constraints = YANGDynClass(
            base=yc_numeric_constraints_nsd__nsd_catalog_nsd_monitoring_param_numeric_constraints ,
            is_container='container' , yang_name="numeric-constraints" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='container' ,
            is_config=True)
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                 defining_module='nsd' , yang_type='string' , is_config=True)
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'monitoring-param']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/id (string)
    """
        return self.__id

    def _set_id(self , v , load=False):
        """
    Setter method for id, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=unicode , is_leaf=True , yang_name="id" , parent=self ,
                                 path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                 is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                 defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/name (string)
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)

    def _get_value_type(self):
        """
    Getter method for value_type, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/value_type (param-value-type)
    """
        return self.__value_type

    def _set_value_type(self , v , load=False):
        """
    Setter method for value_type, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/value_type (param-value-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value_type() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'INT': {} , u'DECIMAL': {} ,
                                                                           u'STRING': {}} , ) , default=unicode("INT") ,
                             is_leaf=True , yang_name="value-type" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='param-value-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """value_type must be of a type compatible with param-value-type""" ,
                'defined-type': "nsd:param-value-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'INT': {}, u'DECIMAL': {}, u'STRING': {}},), default=unicode("INT"), is_leaf=True, yang_name="value-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='param-value-type', is_config=True)""" ,
            })

        self.__value_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_value_type(self):
        self.__value_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                  restriction_arg={u'INT': {} , u'DECIMAL': {} ,
                                                                                   u'STRING': {}} , ) ,
                                         default=unicode("INT") , is_leaf=True , yang_name="value-type" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                         defining_module='nsd' , yang_type='param-value-type' , is_config=True)

    def _get_numeric_constraints(self):
        """
    Getter method for numeric_constraints, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/numeric_constraints (container)
    """
        return self.__numeric_constraints

    def _set_numeric_constraints(self , v , load=False):
        """
    Setter method for numeric_constraints, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/numeric_constraints (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numeric_constraints is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numeric_constraints() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_numeric_constraints_nsd__nsd_catalog_nsd_monitoring_param_numeric_constraints ,
                             is_container='container' , yang_name="numeric-constraints" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """numeric_constraints must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_numeric_constraints_nsd__nsd_catalog_nsd_monitoring_param_numeric_constraints, is_container='container', yang_name="numeric-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='container', is_config=True)""" ,
            })

        self.__numeric_constraints = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_numeric_constraints(self):
        self.__numeric_constraints = YANGDynClass(
            base=yc_numeric_constraints_nsd__nsd_catalog_nsd_monitoring_param_numeric_constraints ,
            is_container='container' , yang_name="numeric-constraints" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='container' ,
            is_config=True)

    def _get_text_constraints(self):
        """
    Getter method for text_constraints, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/text_constraints (container)
    """
        return self.__text_constraints

    def _set_text_constraints(self , v , load=False):
        """
    Setter method for text_constraints, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/text_constraints (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_text_constraints is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_text_constraints() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_text_constraints_nsd__nsd_catalog_nsd_monitoring_param_text_constraints ,
                             is_container='container' , yang_name="text-constraints" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """text_constraints must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_text_constraints_nsd__nsd_catalog_nsd_monitoring_param_text_constraints, is_container='container', yang_name="text-constraints", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='container', is_config=True)""" ,
            })

        self.__text_constraints = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_text_constraints(self):
        self.__text_constraints = YANGDynClass(
            base=yc_text_constraints_nsd__nsd_catalog_nsd_monitoring_param_text_constraints , is_container='container' ,
            yang_name="text-constraints" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='container' , is_config=True)

    def _get_value_integer(self):
        """
    Getter method for value_integer, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/value_integer (int64)

    YANG Description: Current value for an integer parameter
    """
        return self.__value_integer

    def _set_value_integer(self , v , load=False):
        """
    Setter method for value_integer, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/value_integer (int64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value_integer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value_integer() directly.

    YANG Description: Current value for an integer parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=long , restriction_dict={
                'range': ['-9223372036854775808..9223372036854775807']} , int_size=64) , is_leaf=True ,
                             yang_name="value-integer" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='int64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """value_integer must be of a type compatible with int64""" ,
                'defined-type': "int64" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64), is_leaf=True, yang_name="value-integer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='int64', is_config=True)""" ,
            })

        self.__value_integer = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_value_integer(self):
        self.__value_integer = YANGDynClass(base=RestrictedClassType(base_type=long , restriction_dict={
            'range': ['-9223372036854775808..9223372036854775807']} , int_size=64) , is_leaf=True ,
                                            yang_name="value-integer" , parent=self , path_helper=self._path_helper ,
                                            extmethods=self._extmethods , register_paths=True ,
                                            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                            yang_type='int64' , is_config=True)

    def _get_value_decimal(self):
        """
    Getter method for value_decimal, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/value_decimal (decimal64)

    YANG Description: Current value for a decimal parameter
    """
        return self.__value_decimal

    def _set_value_decimal(self , v , load=False):
        """
    Setter method for value_decimal, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/value_decimal (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value_decimal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value_decimal() directly.

    YANG Description: Current value for a decimal parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedPrecisionDecimalType(precision=4) , is_leaf=True ,
                             yang_name="value-decimal" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='decimal64' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """value_decimal must be of a type compatible with decimal64""" ,
                'defined-type': "decimal64" ,
                'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value-decimal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='decimal64', is_config=True)""" ,
            })

        self.__value_decimal = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_value_decimal(self):
        self.__value_decimal = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4) , is_leaf=True ,
                                            yang_name="value-decimal" , parent=self , path_helper=self._path_helper ,
                                            extmethods=self._extmethods , register_paths=True ,
                                            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                            yang_type='decimal64' , is_config=True)

    def _get_value_string(self):
        """
    Getter method for value_string, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/value_string (string)

    YANG Description: Current value for a string parameter
    """
        return self.__value_string

    def _set_value_string(self , v , load=False):
        """
    Setter method for value_string, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/value_string (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value_string is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value_string() directly.

    YANG Description: Current value for a string parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="value-string" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """value_string must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="value-string", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__value_string = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_value_string(self):
        self.__value_string = YANGDynClass(base=unicode , is_leaf=True , yang_name="value-string" , parent=self ,
                                           path_helper=self._path_helper , extmethods=self._extmethods ,
                                           register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                           defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/description (string)
    """
        return self.__description

    def _set_description(self , v , load=False):
        """
    Setter method for description, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__description = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_group_tag(self):
        """
    Getter method for group_tag, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/group_tag (string)

    YANG Description: A tag to group monitoring parameters
    """
        return self.__group_tag

    def _set_group_tag(self , v , load=False):
        """
    Setter method for group_tag, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/group_tag (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_tag() directly.

    YANG Description: A tag to group monitoring parameters
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="group-tag" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """group_tag must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="group-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__group_tag = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_group_tag(self):
        self.__group_tag = YANGDynClass(base=unicode , is_leaf=True , yang_name="group-tag" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                        defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_widget_type(self):
        """
    Getter method for widget_type, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/widget_type (manotypes:widget-type)

    YANG Description: Defines the UI Display variant of measured counters.
    """
        return self.__widget_type

    def _set_widget_type(self , v , load=False):
        """
    Setter method for widget_type, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/widget_type (manotypes:widget-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_widget_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_widget_type() directly.

    YANG Description: Defines the UI Display variant of measured counters.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'BAR': {} , u'COUNTER': {} ,
                                                                           u'HISTOGRAM': {} , u'SLIDER': {} ,
                                                                           u'GAUGE': {} , u'TEXTBOX': {}} , ) ,
                             default=unicode("COUNTER") , is_leaf=True , yang_name="widget-type" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='manotypes:widget-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """widget_type must be of a type compatible with manotypes:widget-type""" ,
                'defined-type': "manotypes:widget-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'BAR': {}, u'COUNTER': {}, u'HISTOGRAM': {}, u'SLIDER': {}, u'GAUGE': {}, u'TEXTBOX': {}},), default=unicode("COUNTER"), is_leaf=True, yang_name="widget-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='manotypes:widget-type', is_config=True)""" ,
            })

        self.__widget_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_widget_type(self):
        self.__widget_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                   restriction_arg={u'BAR': {} , u'COUNTER': {} ,
                                                                                    u'HISTOGRAM': {} , u'SLIDER': {} ,
                                                                                    u'GAUGE': {} , u'TEXTBOX': {}} , ) ,
                                          default=unicode("COUNTER") , is_leaf=True , yang_name="widget-type" ,
                                          parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='manotypes:widget-type' , is_config=True)

    def _get_units(self):
        """
    Getter method for units, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/units (string)

    YANG Description: Measured Counter Units (e.g., Packets, Kbps, Mbps, etc.)
    """
        return self.__units

    def _set_units(self , v , load=False):
        """
    Setter method for units, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/units (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_units is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_units() directly.

    YANG Description: Measured Counter Units (e.g., Packets, Kbps, Mbps, etc.)
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="units" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """units must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="units", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__units = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_units(self):
        self.__units = YANGDynClass(base=unicode , is_leaf=True , yang_name="units" , parent=self ,
                                    path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                    yang_type='string' , is_config=True)

    def _get_aggregation_type(self):
        """
    Getter method for aggregation_type, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/aggregation_type (aggregation-type)
    """
        return self.__aggregation_type

    def _set_aggregation_type(self , v , load=False):
        """
    Setter method for aggregation_type, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/aggregation_type (aggregation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggregation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggregation_type() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'COUNT': {} , u'AVERAGE': {} ,
                                                                           u'MINIMUM': {} , u'SUM': {} ,
                                                                           u'MAXIMUM': {}} , ) , is_leaf=True ,
                             yang_name="aggregation-type" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='aggregation-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """aggregation_type must be of a type compatible with aggregation-type""" ,
                'defined-type': "nsd:aggregation-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'COUNT': {}, u'AVERAGE': {}, u'MINIMUM': {}, u'SUM': {}, u'MAXIMUM': {}},), is_leaf=True, yang_name="aggregation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='aggregation-type', is_config=True)""" ,
            })

        self.__aggregation_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_aggregation_type(self):
        self.__aggregation_type = YANGDynClass(
            base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                     restriction_arg={u'COUNT': {} , u'AVERAGE': {} , u'MINIMUM': {} , u'SUM': {} ,
                                                      u'MAXIMUM': {}} , ) , is_leaf=True ,
            yang_name="aggregation-type" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='aggregation-type' , is_config=True)

    def _get_vnfd_monitoring_param(self):
        """
    Getter method for vnfd_monitoring_param, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/vnfd_monitoring_param (list)

    YANG Description: A list of VNFD monitoring params
    """
        return self.__vnfd_monitoring_param

    def _set_vnfd_monitoring_param(self , v , load=False):
        """
    Setter method for vnfd_monitoring_param, mapped from YANG variable /nsd_catalog/nsd/monitoring_param/vnfd_monitoring_param (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_monitoring_param is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_monitoring_param() directly.

    YANG Description: A list of VNFD monitoring params
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("member_vnf_index_ref vnfd_monitoring_param_ref" ,
                                                   yc_vnfd_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param_vnfd_monitoring_param ,
                                                   yang_name="vnfd-monitoring-param" , parent=self ,
                                                   is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper ,
                                                   yang_keys='member-vnf-index-ref vnfd-monitoring-param-ref' ,
                                                   extensions=None) , is_container='list' ,
                             yang_name="vnfd-monitoring-param" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_monitoring_param must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("member_vnf_index_ref vnfd_monitoring_param_ref",yc_vnfd_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param_vnfd_monitoring_param, yang_name="vnfd-monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref vnfd-monitoring-param-ref', extensions=None), is_container='list', yang_name="vnfd-monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__vnfd_monitoring_param = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_monitoring_param(self):
        self.__vnfd_monitoring_param = YANGDynClass(base=YANGListType("member_vnf_index_ref vnfd_monitoring_param_ref" ,
                                                                      yc_vnfd_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param_vnfd_monitoring_param ,
                                                                      yang_name="vnfd-monitoring-param" , parent=self ,
                                                                      is_container='list' , user_ordered=False ,
                                                                      path_helper=self._path_helper ,
                                                                      yang_keys='member-vnf-index-ref vnfd-monitoring-param-ref' ,
                                                                      extensions=None) , is_container='list' ,
                                                    yang_name="vnfd-monitoring-param" , parent=self ,
                                                    path_helper=self._path_helper , extmethods=self._extmethods ,
                                                    register_paths=True , extensions=None ,
                                                    namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                    defining_module='nsd' , yang_type='list' , is_config=True)

    id = __builtin__.property(_get_id , _set_id)
    name = __builtin__.property(_get_name , _set_name)
    value_type = __builtin__.property(_get_value_type , _set_value_type)
    numeric_constraints = __builtin__.property(_get_numeric_constraints , _set_numeric_constraints)
    text_constraints = __builtin__.property(_get_text_constraints , _set_text_constraints)
    value_integer = __builtin__.property(_get_value_integer , _set_value_integer)
    value_decimal = __builtin__.property(_get_value_decimal , _set_value_decimal)
    value_string = __builtin__.property(_get_value_string , _set_value_string)
    description = __builtin__.property(_get_description , _set_description)
    group_tag = __builtin__.property(_get_group_tag , _set_group_tag)
    widget_type = __builtin__.property(_get_widget_type , _set_widget_type)
    units = __builtin__.property(_get_units , _set_units)
    aggregation_type = __builtin__.property(_get_aggregation_type , _set_aggregation_type)
    vnfd_monitoring_param = __builtin__.property(_get_vnfd_monitoring_param , _set_vnfd_monitoring_param)

    _pyangbind_elements = {'id': id , 'name': name , 'value_type': value_type ,
                           'numeric_constraints': numeric_constraints , 'text_constraints': text_constraints ,
                           'value_integer': value_integer , 'value_decimal': value_decimal ,
                           'value_string': value_string , 'description': description , 'group_tag': group_tag ,
                           'widget_type': widget_type , 'units': units , 'aggregation_type': aggregation_type ,
                           'vnfd_monitoring_param': vnfd_monitoring_param , }


class yc_parameter_nsd__nsd_catalog_nsd_service_primitive_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/service-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters for the service primitive.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__name' , '__data_type' , '__mandatory' , '__default_value' , '__parameter_pool' ,
    '__read_only' , '__hidden' ,)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__default_value = YANGDynClass(base=unicode , is_leaf=True , yang_name="default-value" , parent=self ,
                                            path_helper=self._path_helper , extmethods=self._extmethods ,
                                            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                            defining_module='nsd' , yang_type='string' , is_config=True)
        self.__read_only = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                        yang_name="read-only" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                        yang_type='boolean' , is_config=True)
        self.__mandatory = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                        yang_name="mandatory" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                        yang_type='boolean' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                                  u'STRING': {}} , ) , is_leaf=True ,
                                        yang_name="data-type" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                        yang_type='manotypes:parameter-data-type' , is_config=True)
        self.__parameter_pool = YANGDynClass(base=unicode , is_leaf=True , yang_name="parameter-pool" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                             defining_module='nsd' , yang_type='string' , is_config=True)
        self.__hidden = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="hidden" ,
                                     parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                     register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                     defining_module='nsd' , yang_type='boolean' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'service-primitive' , u'parameter']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_data_type(self):
        """
    Getter method for data_type, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the name.
    """
        return self.__data_type

    def _set_data_type(self , v , load=False):
        """
    Setter method for data_type, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the name.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                           u'STRING': {}} , ) , is_leaf=True ,
                             yang_name="data-type" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='manotypes:parameter-data-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""" ,
                'defined-type': "manotypes:parameter-data-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='manotypes:parameter-data-type', is_config=True)""" ,
            })

        self.__data_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_data_type(self):
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                                  u'STRING': {}} , ) , is_leaf=True ,
                                        yang_name="data-type" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                        yang_type='manotypes:parameter-data-type' , is_config=True)

    def _get_mandatory(self):
        """
    Getter method for mandatory, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter/mandatory (boolean)

    YANG Description: Is this field mandatory
    """
        return self.__mandatory

    def _set_mandatory(self , v , load=False):
        """
    Setter method for mandatory, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter/mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mandatory() directly.

    YANG Description: Is this field mandatory
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="mandatory" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """mandatory must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""" ,
            })

        self.__mandatory = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_mandatory(self):
        self.__mandatory = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                        yang_name="mandatory" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                        yang_type='boolean' , is_config=True)

    def _get_default_value(self):
        """
    Getter method for default_value, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter/default_value (string)

    YANG Description: The default value for this field
    """
        return self.__default_value

    def _set_default_value(self , v , load=False):
        """
    Setter method for default_value, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter/default_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_value() directly.

    YANG Description: The default value for this field
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="default-value" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """default_value must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__default_value = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_default_value(self):
        self.__default_value = YANGDynClass(base=unicode , is_leaf=True , yang_name="default-value" , parent=self ,
                                            path_helper=self._path_helper , extmethods=self._extmethods ,
                                            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                            defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_parameter_pool(self):
        """
    Getter method for parameter_pool, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter/parameter_pool (string)

    YANG Description: NSD parameter pool name to use for this parameter
    """
        return self.__parameter_pool

    def _set_parameter_pool(self , v , load=False):
        """
    Setter method for parameter_pool, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter/parameter_pool (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter_pool() directly.

    YANG Description: NSD parameter pool name to use for this parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="parameter-pool" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """parameter_pool must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__parameter_pool = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_parameter_pool(self):
        self.__parameter_pool = YANGDynClass(base=unicode , is_leaf=True , yang_name="parameter-pool" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                             defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_read_only(self):
        """
    Getter method for read_only, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter/read_only (boolean)

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
        return self.__read_only

    def _set_read_only(self , v , load=False):
        """
    Setter method for read_only, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter/read_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_read_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_read_only() directly.

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="read-only" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """read_only must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""" ,
            })

        self.__read_only = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_read_only(self):
        self.__read_only = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                        yang_name="read-only" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                        yang_type='boolean' , is_config=True)

    def _get_hidden(self):
        """
    Getter method for hidden, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter/hidden (boolean)

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
        return self.__hidden

    def _set_hidden(self , v , load=False):
        """
    Setter method for hidden, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter/hidden (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hidden is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hidden() directly.

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="hidden" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """hidden must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""" ,
            })

        self.__hidden = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_hidden(self):
        self.__hidden = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="hidden" ,
                                     parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                     register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                     defining_module='nsd' , yang_type='boolean' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    data_type = __builtin__.property(_get_data_type , _set_data_type)
    mandatory = __builtin__.property(_get_mandatory , _set_mandatory)
    default_value = __builtin__.property(_get_default_value , _set_default_value)
    parameter_pool = __builtin__.property(_get_parameter_pool , _set_parameter_pool)
    read_only = __builtin__.property(_get_read_only , _set_read_only)
    hidden = __builtin__.property(_get_hidden , _set_hidden)

    _pyangbind_elements = {'name': name , 'data_type': data_type , 'mandatory': mandatory ,
                           'default_value': default_value , 'parameter_pool': parameter_pool , 'read_only': read_only ,
                           'hidden': hidden , }


class yc_parameter_nsd__nsd_catalog_nsd_service_primitive_parameter_group_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/service-primitive/parameter-group/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters for the service primitive.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__name' , '__data_type' , '__mandatory' , '__default_value' , '__parameter_pool' ,
    '__read_only' , '__hidden' ,)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__default_value = YANGDynClass(base=unicode , is_leaf=True , yang_name="default-value" , parent=self ,
                                            path_helper=self._path_helper , extmethods=self._extmethods ,
                                            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                            defining_module='nsd' , yang_type='string' , is_config=True)
        self.__read_only = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                        yang_name="read-only" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                        yang_type='boolean' , is_config=True)
        self.__mandatory = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                        yang_name="mandatory" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                        yang_type='boolean' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                                  u'STRING': {}} , ) , is_leaf=True ,
                                        yang_name="data-type" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                        yang_type='manotypes:parameter-data-type' , is_config=True)
        self.__parameter_pool = YANGDynClass(base=unicode , is_leaf=True , yang_name="parameter-pool" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                             defining_module='nsd' , yang_type='string' , is_config=True)
        self.__hidden = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="hidden" ,
                                     parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                     register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                     defining_module='nsd' , yang_type='boolean' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'service-primitive' , u'parameter-group' , u'parameter']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/parameter/name (string)

    YANG Description: Name of the parameter.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_data_type(self):
        """
    Getter method for data_type, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/parameter/data_type (manotypes:parameter-data-type)

    YANG Description: Data type associated with the name.
    """
        return self.__data_type

    def _set_data_type(self , v , load=False):
        """
    Setter method for data_type, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/parameter/data_type (manotypes:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the name.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                          restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                           u'STRING': {}} , ) , is_leaf=True ,
                             yang_name="data-type" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='manotypes:parameter-data-type' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """data_type must be of a type compatible with manotypes:parameter-data-type""" ,
                'defined-type': "manotypes:parameter-data-type" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode,                                     restriction_type="dict_key",                                     restriction_arg={u'INTEGER': {}, u'BOOLEAN': {}, u'STRING': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='manotypes:parameter-data-type', is_config=True)""" ,
            })

        self.__data_type = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_data_type(self):
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_type="dict_key" ,
                                                                 restriction_arg={u'INTEGER': {} , u'BOOLEAN': {} ,
                                                                                  u'STRING': {}} , ) , is_leaf=True ,
                                        yang_name="data-type" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                        yang_type='manotypes:parameter-data-type' , is_config=True)

    def _get_mandatory(self):
        """
    Getter method for mandatory, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/parameter/mandatory (boolean)

    YANG Description: Is this field mandatory
    """
        return self.__mandatory

    def _set_mandatory(self , v , load=False):
        """
    Setter method for mandatory, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/parameter/mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mandatory() directly.

    YANG Description: Is this field mandatory
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="mandatory" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """mandatory must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""" ,
            })

        self.__mandatory = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_mandatory(self):
        self.__mandatory = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                        yang_name="mandatory" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                        yang_type='boolean' , is_config=True)

    def _get_default_value(self):
        """
    Getter method for default_value, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/parameter/default_value (string)

    YANG Description: The default value for this field
    """
        return self.__default_value

    def _set_default_value(self , v , load=False):
        """
    Setter method for default_value, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/parameter/default_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_value() directly.

    YANG Description: The default value for this field
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="default-value" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """default_value must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__default_value = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_default_value(self):
        self.__default_value = YANGDynClass(base=unicode , is_leaf=True , yang_name="default-value" , parent=self ,
                                            path_helper=self._path_helper , extmethods=self._extmethods ,
                                            register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                            defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_parameter_pool(self):
        """
    Getter method for parameter_pool, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/parameter/parameter_pool (string)

    YANG Description: NSD parameter pool name to use for this parameter
    """
        return self.__parameter_pool

    def _set_parameter_pool(self , v , load=False):
        """
    Setter method for parameter_pool, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/parameter/parameter_pool (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter_pool() directly.

    YANG Description: NSD parameter pool name to use for this parameter
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="parameter-pool" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """parameter_pool must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__parameter_pool = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_parameter_pool(self):
        self.__parameter_pool = YANGDynClass(base=unicode , is_leaf=True , yang_name="parameter-pool" , parent=self ,
                                             path_helper=self._path_helper , extmethods=self._extmethods ,
                                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                             defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_read_only(self):
        """
    Getter method for read_only, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/parameter/read_only (boolean)

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
        return self.__read_only

    def _set_read_only(self , v , load=False):
        """
    Setter method for read_only, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/parameter/read_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_read_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_read_only() directly.

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="read-only" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """read_only must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""" ,
            })

        self.__read_only = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_read_only(self):
        self.__read_only = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True ,
                                        yang_name="read-only" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                        yang_type='boolean' , is_config=True)

    def _get_hidden(self):
        """
    Getter method for hidden, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/parameter/hidden (boolean)

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
        return self.__hidden

    def _set_hidden(self , v , load=False):
        """
    Setter method for hidden, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/parameter/hidden (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hidden is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hidden() directly.

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="hidden" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """hidden must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""" ,
            })

        self.__hidden = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_hidden(self):
        self.__hidden = YANGDynClass(base=YANGBool , default=YANGBool("false") , is_leaf=True , yang_name="hidden" ,
                                     parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                                     register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                     defining_module='nsd' , yang_type='boolean' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    data_type = __builtin__.property(_get_data_type , _set_data_type)
    mandatory = __builtin__.property(_get_mandatory , _set_mandatory)
    default_value = __builtin__.property(_get_default_value , _set_default_value)
    parameter_pool = __builtin__.property(_get_parameter_pool , _set_parameter_pool)
    read_only = __builtin__.property(_get_read_only , _set_read_only)
    hidden = __builtin__.property(_get_hidden , _set_hidden)

    _pyangbind_elements = {'name': name , 'data_type': data_type , 'mandatory': mandatory ,
                           'default_value': default_value , 'parameter_pool': parameter_pool , 'read_only': read_only ,
                           'hidden': hidden , }


class yc_parameter_group_nsd__nsd_catalog_nsd_service_primitive_parameter_group(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/service-primitive/parameter-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Grouping of parameters which are logically grouped in UI
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__name' , '__parameter' , '__mandatory' ,)

    _yang_name = 'parameter-group'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__mandatory = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True ,
                                        yang_name="mandatory" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                        yang_type='boolean' , is_config=True)
        self.__parameter = YANGDynClass(
            base=YANGListType("name" , yc_parameter_nsd__nsd_catalog_nsd_service_primitive_parameter_group_parameter ,
                              yang_name="parameter" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="parameter" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'service-primitive' , u'parameter-group']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/name (string)

    YANG Description: Name of the parameter group
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter group
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/parameter (list)

    YANG Description: List of parameters for the service primitive.
    """
        return self.__parameter

    def _set_parameter(self , v , load=False):
        """
    Setter method for parameter, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters for the service primitive.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" ,
                                                   yc_parameter_nsd__nsd_catalog_nsd_service_primitive_parameter_group_parameter ,
                                                   yang_name="parameter" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="parameter" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_nsd__nsd_catalog_nsd_service_primitive_parameter_group_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__parameter = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(
            base=YANGListType("name" , yc_parameter_nsd__nsd_catalog_nsd_service_primitive_parameter_group_parameter ,
                              yang_name="parameter" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="parameter" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    def _get_mandatory(self):
        """
    Getter method for mandatory, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/mandatory (boolean)

    YANG Description: Is this parameter group mandatory
    """
        return self.__mandatory

    def _set_mandatory(self , v , load=False):
        """
    Setter method for mandatory, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group/mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mandatory() directly.

    YANG Description: Is this parameter group mandatory
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGBool , default=YANGBool("true") , is_leaf=True , yang_name="mandatory" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='boolean' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """mandatory must be of a type compatible with boolean""" ,
                'defined-type': "boolean" ,
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='boolean', is_config=True)""" ,
            })

        self.__mandatory = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_mandatory(self):
        self.__mandatory = YANGDynClass(base=YANGBool , default=YANGBool("true") , is_leaf=True ,
                                        yang_name="mandatory" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                        yang_type='boolean' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    parameter = __builtin__.property(_get_parameter , _set_parameter)
    mandatory = __builtin__.property(_get_mandatory , _set_mandatory)

    _pyangbind_elements = {'name': name , 'parameter': parameter , 'mandatory': mandatory , }


class yc_primitive_nsd__nsd_catalog_nsd_service_primitive_vnf_primitive_group_primitive(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/service-primitive/vnf-primitive-group/primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__index' , '__name' ,)

    _yang_name = 'primitive'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__index = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="index" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , is_keyval=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint32' ,
            is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'service-primitive' , u'vnf-primitive-group' , u'primitive']

    def _get_index(self):
        """
    Getter method for index, mapped from YANG variable /nsd_catalog/nsd/service_primitive/vnf_primitive_group/primitive/index (uint32)

    YANG Description: Index of this primitive
    """
        return self.__index

    def _set_index(self , v , load=False):
        """
    Setter method for index, mapped from YANG variable /nsd_catalog/nsd/service_primitive/vnf_primitive_group/primitive/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of this primitive
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} ,
                                                      int_size=32) , is_leaf=True , yang_name="index" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='uint32' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """index must be of a type compatible with uint32""" ,
                'defined-type': "uint32" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='uint32', is_config=True)""" ,
            })

        self.__index = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_index(self):
        self.__index = YANGDynClass(
            base=RestrictedClassType(base_type=long , restriction_dict={'range': ['0..4294967295']} , int_size=32) ,
            is_leaf=True , yang_name="index" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , is_keyval=True ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='uint32' ,
            is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/service_primitive/vnf_primitive_group/primitive/name (string)

    YANG Description: Name of the primitive in the VNF primitive
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/service_primitive/vnf_primitive_group/primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the primitive in the VNF primitive
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)

    index = __builtin__.property(_get_index , _set_index)
    name = __builtin__.property(_get_name , _set_name)

    _pyangbind_elements = {'index': index , 'name': name , }


class yc_vnf_primitive_group_nsd__nsd_catalog_nsd_service_primitive_vnf_primitive_group(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/service-primitive/vnf-primitive-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of service primitives grouped by VNF.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__member_vnf_index_ref' , '__vnfd_id_ref' , '__vnfd_name' , '__primitive' ,)

    _yang_name = 'vnf-primitive-group'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnfd_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-name" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                        defining_module='nsd' , yang_type='leafref' , is_config=True)
        self.__member_vnf_index_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" ,
                                                   parent=self , path_helper=self._path_helper ,
                                                   extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='leafref' , is_config=True)
        self.__primitive = YANGDynClass(base=YANGListType("index" ,
                                                          yc_primitive_nsd__nsd_catalog_nsd_service_primitive_vnf_primitive_group_primitive ,
                                                          yang_name="primitive" , parent=self , is_container='list' ,
                                                          user_ordered=False , path_helper=self._path_helper ,
                                                          yang_keys='index' , extensions=None) , is_container='list' ,
                                        yang_name="primitive" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True , extensions=None ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                        yang_type='list' , is_config=True)
        self.__vnfd_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='leafref' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'service-primitive' , u'vnf-primitive-group']

    def _get_member_vnf_index_ref(self):
        """
    Getter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/service_primitive/vnf_primitive_group/member_vnf_index_ref (leafref)

    YANG Description: Reference to member-vnf within constituent-vnfds
    """
        return self.__member_vnf_index_ref

    def _set_member_vnf_index_ref(self , v , load=False):
        """
    Setter method for member_vnf_index_ref, mapped from YANG variable /nsd_catalog/nsd/service_primitive/vnf_primitive_group/member_vnf_index_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_vnf_index_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_vnf_index_ref() directly.

    YANG Description: Reference to member-vnf within constituent-vnfds
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """member_vnf_index_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="member-vnf-index-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__member_vnf_index_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_member_vnf_index_ref(self):
        self.__member_vnf_index_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="member-vnf-index-ref" ,
                                                   parent=self , path_helper=self._path_helper ,
                                                   extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                   defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_vnfd_id_ref(self):
        """
    Getter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/service_primitive/vnf_primitive_group/vnfd_id_ref (leafref)

    YANG Description: A reference to a VNFD. This is a leafref
    """
        return self.__vnfd_id_ref

    def _set_vnfd_id_ref(self , v , load=False):
        """
    Setter method for vnfd_id_ref, mapped from YANG variable /nsd_catalog/nsd/service_primitive/vnf_primitive_group/vnfd_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id_ref() directly.

    YANG Description: A reference to a VNFD. This is a leafref
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_id_ref must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnfd-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vnfd_id_ref = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_id_ref(self):
        self.__vnfd_id_ref = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-id-ref" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_vnfd_name(self):
        """
    Getter method for vnfd_name, mapped from YANG variable /nsd_catalog/nsd/service_primitive/vnf_primitive_group/vnfd_name (leafref)

    YANG Description: Name of the VNFD
    """
        return self.__vnfd_name

    def _set_vnfd_name(self , v , load=False):
        """
    Setter method for vnfd_name, mapped from YANG variable /nsd_catalog/nsd/service_primitive/vnf_primitive_group/vnfd_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_name() directly.

    YANG Description: Name of the VNFD
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vnfd-name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='leafref' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnfd_name must be of a type compatible with leafref""" ,
                'defined-type': "leafref" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vnfd-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='leafref', is_config=True)""" ,
            })

        self.__vnfd_name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnfd_name(self):
        self.__vnfd_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="vnfd-name" , parent=self ,
                                        path_helper=self._path_helper , extmethods=self._extmethods ,
                                        register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                        defining_module='nsd' , yang_type='leafref' , is_config=True)

    def _get_primitive(self):
        """
    Getter method for primitive, mapped from YANG variable /nsd_catalog/nsd/service_primitive/vnf_primitive_group/primitive (list)
    """
        return self.__primitive

    def _set_primitive(self , v , load=False):
        """
    Setter method for primitive, mapped from YANG variable /nsd_catalog/nsd/service_primitive/vnf_primitive_group/primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primitive() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("index" ,
                                                   yc_primitive_nsd__nsd_catalog_nsd_service_primitive_vnf_primitive_group_primitive ,
                                                   yang_name="primitive" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='index' , extensions=None) , is_container='list' ,
                             yang_name="primitive" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """primitive must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("index",yc_primitive_nsd__nsd_catalog_nsd_service_primitive_vnf_primitive_group_primitive, yang_name="primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__primitive = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_primitive(self):
        self.__primitive = YANGDynClass(base=YANGListType("index" ,
                                                          yc_primitive_nsd__nsd_catalog_nsd_service_primitive_vnf_primitive_group_primitive ,
                                                          yang_name="primitive" , parent=self , is_container='list' ,
                                                          user_ordered=False , path_helper=self._path_helper ,
                                                          yang_keys='index' , extensions=None) , is_container='list' ,
                                        yang_name="primitive" , parent=self , path_helper=self._path_helper ,
                                        extmethods=self._extmethods , register_paths=True , extensions=None ,
                                        namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                        yang_type='list' , is_config=True)

    member_vnf_index_ref = __builtin__.property(_get_member_vnf_index_ref , _set_member_vnf_index_ref)
    vnfd_id_ref = __builtin__.property(_get_vnfd_id_ref , _set_vnfd_id_ref)
    vnfd_name = __builtin__.property(_get_vnfd_name , _set_vnfd_name)
    primitive = __builtin__.property(_get_primitive , _set_primitive)

    _pyangbind_elements = {'member_vnf_index_ref': member_vnf_index_ref , 'vnfd_id_ref': vnfd_id_ref ,
                           'vnfd_name': vnfd_name , 'primitive': primitive , }


class yc_service_primitive_nsd__nsd_catalog_nsd_service_primitive(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd/service-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Network service level service primitives.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__name' , '__parameter' , '__parameter_group' , '__vnf_primitive_group' ,
    '__user_defined_script' ,)

    _yang_name = 'service-primitive'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__user_defined_script = YANGDynClass(base=unicode , is_leaf=True , yang_name="user-defined-script" ,
                                                  parent=self , path_helper=self._path_helper ,
                                                  extmethods=self._extmethods , register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                  defining_module='nsd' , yang_type='string' , is_config=True)
        self.__parameter = YANGDynClass(
            base=YANGListType("name" , yc_parameter_nsd__nsd_catalog_nsd_service_primitive_parameter ,
                              yang_name="parameter" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="parameter" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)
        self.__parameter_group = YANGDynClass(
            base=YANGListType("name" , yc_parameter_group_nsd__nsd_catalog_nsd_service_primitive_parameter_group ,
                              yang_name="parameter-group" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="parameter-group" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__vnf_primitive_group = YANGDynClass(base=YANGListType("member_vnf_index_ref" ,
                                                                    yc_vnf_primitive_group_nsd__nsd_catalog_nsd_service_primitive_vnf_primitive_group ,
                                                                    yang_name="vnf-primitive-group" , parent=self ,
                                                                    is_container='list' , user_ordered=False ,
                                                                    path_helper=self._path_helper ,
                                                                    yang_keys='member-vnf-index-ref' ,
                                                                    extensions=None) , is_container='list' ,
                                                  yang_name="vnf-primitive-group" , parent=self ,
                                                  path_helper=self._path_helper , extmethods=self._extmethods ,
                                                  register_paths=True , extensions=None ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                  defining_module='nsd' , yang_type='list' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd' , u'service-primitive']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/service_primitive/name (string)

    YANG Description: Name of the service primitive.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/service_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the service primitive.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   is_keyval=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                   defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter (list)

    YANG Description: List of parameters for the service primitive.
    """
        return self.__parameter

    def _set_parameter(self , v , load=False):
        """
    Setter method for parameter, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters for the service primitive.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=YANGListType("name" , yc_parameter_nsd__nsd_catalog_nsd_service_primitive_parameter ,
                                               yang_name="parameter" , parent=self , is_container='list' ,
                                               user_ordered=False , path_helper=self._path_helper , yang_keys='name' ,
                                               extensions=None) , is_container='list' , yang_name="parameter" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_nsd__nsd_catalog_nsd_service_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__parameter = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(
            base=YANGListType("name" , yc_parameter_nsd__nsd_catalog_nsd_service_primitive_parameter ,
                              yang_name="parameter" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="parameter" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    def _get_parameter_group(self):
        """
    Getter method for parameter_group, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group (list)

    YANG Description: Grouping of parameters which are logically grouped in UI
    """
        return self.__parameter_group

    def _set_parameter_group(self , v , load=False):
        """
    Setter method for parameter_group, mapped from YANG variable /nsd_catalog/nsd/service_primitive/parameter_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter_group() directly.

    YANG Description: Grouping of parameters which are logically grouped in UI
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" ,
                                                   yc_parameter_group_nsd__nsd_catalog_nsd_service_primitive_parameter_group ,
                                                   yang_name="parameter-group" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="parameter-group" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """parameter_group must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_group_nsd__nsd_catalog_nsd_service_primitive_parameter_group, yang_name="parameter-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__parameter_group = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_parameter_group(self):
        self.__parameter_group = YANGDynClass(
            base=YANGListType("name" , yc_parameter_group_nsd__nsd_catalog_nsd_service_primitive_parameter_group ,
                              yang_name="parameter-group" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="parameter-group" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    def _get_vnf_primitive_group(self):
        """
    Getter method for vnf_primitive_group, mapped from YANG variable /nsd_catalog/nsd/service_primitive/vnf_primitive_group (list)

    YANG Description: List of service primitives grouped by VNF.
    """
        return self.__vnf_primitive_group

    def _set_vnf_primitive_group(self , v , load=False):
        """
    Setter method for vnf_primitive_group, mapped from YANG variable /nsd_catalog/nsd/service_primitive/vnf_primitive_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_primitive_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_primitive_group() directly.

    YANG Description: List of service primitives grouped by VNF.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("member_vnf_index_ref" ,
                                                   yc_vnf_primitive_group_nsd__nsd_catalog_nsd_service_primitive_vnf_primitive_group ,
                                                   yang_name="vnf-primitive-group" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='member-vnf-index-ref' , extensions=None) ,
                             is_container='list' , yang_name="vnf-primitive-group" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnf_primitive_group must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("member_vnf_index_ref",yc_vnf_primitive_group_nsd__nsd_catalog_nsd_service_primitive_vnf_primitive_group, yang_name="vnf-primitive-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index-ref', extensions=None), is_container='list', yang_name="vnf-primitive-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__vnf_primitive_group = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnf_primitive_group(self):
        self.__vnf_primitive_group = YANGDynClass(base=YANGListType("member_vnf_index_ref" ,
                                                                    yc_vnf_primitive_group_nsd__nsd_catalog_nsd_service_primitive_vnf_primitive_group ,
                                                                    yang_name="vnf-primitive-group" , parent=self ,
                                                                    is_container='list' , user_ordered=False ,
                                                                    path_helper=self._path_helper ,
                                                                    yang_keys='member-vnf-index-ref' ,
                                                                    extensions=None) , is_container='list' ,
                                                  yang_name="vnf-primitive-group" , parent=self ,
                                                  path_helper=self._path_helper , extmethods=self._extmethods ,
                                                  register_paths=True , extensions=None ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                  defining_module='nsd' , yang_type='list' , is_config=True)

    def _get_user_defined_script(self):
        """
    Getter method for user_defined_script, mapped from YANG variable /nsd_catalog/nsd/service_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
        return self.__user_defined_script

    def _set_user_defined_script(self , v , load=False):
        """
    Setter method for user_defined_script, mapped from YANG variable /nsd_catalog/nsd/service_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="user-defined-script" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """user_defined_script must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__user_defined_script = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_user_defined_script(self):
        self.__user_defined_script = YANGDynClass(base=unicode , is_leaf=True , yang_name="user-defined-script" ,
                                                  parent=self , path_helper=self._path_helper ,
                                                  extmethods=self._extmethods , register_paths=True ,
                                                  namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                                  defining_module='nsd' , yang_type='string' , is_config=True)

    name = __builtin__.property(_get_name , _set_name)
    parameter = __builtin__.property(_get_parameter , _set_parameter)
    parameter_group = __builtin__.property(_get_parameter_group , _set_parameter_group)
    vnf_primitive_group = __builtin__.property(_get_vnf_primitive_group , _set_vnf_primitive_group)
    user_defined_script = __builtin__.property(_get_user_defined_script , _set_user_defined_script)

    _pyangbind_elements = {'name': name , 'parameter': parameter , 'parameter_group': parameter_group ,
                           'vnf_primitive_group': vnf_primitive_group , 'user_defined_script': user_defined_script , }


class yc_nsd_nsd__nsd_catalog_nsd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog/nsd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
    '_path_helper' , '_extmethods' , '__id' , '__name' , '__short_name' , '__vendor' , '__logo' , '__description' ,
    '__version' , '__connection_point' , '__scaling_group_descriptor' , '__vnffgd' , '__ip_profiles' ,
    '__initial_service_primitive' , '__terminate_service_primitive' , '__input_parameter_xpath' , '__parameter_pool' ,
    '__key_pair' , '__user' , '__vld' , '__constituent_vnfd' , '__placement_groups' , '__vnf_dependency' ,
    '__monitoring_param' , '__service_primitive' ,)

    _yang_name = 'nsd'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__terminate_service_primitive = YANGDynClass(
            base=YANGListType("seq" , yc_terminate_service_primitive_nsd__nsd_catalog_nsd_terminate_service_primitive ,
                              yang_name="terminate-service-primitive" , parent=self , is_container='list' ,
                              user_ordered=False , path_helper=self._path_helper , yang_keys='seq' , extensions=None) ,
            is_container='list' , yang_name="terminate-service-primitive" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__placement_groups = YANGDynClass(
            base=YANGListType("name" , yc_placement_groups_nsd__nsd_catalog_nsd_placement_groups ,
                              yang_name="placement-groups" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="placement-groups" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__constituent_vnfd = YANGDynClass(
            base=YANGListType("member_vnf_index" , yc_constituent_vnfd_nsd__nsd_catalog_nsd_constituent_vnfd ,
                              yang_name="constituent-vnfd" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='member-vnf-index' , extensions=None) ,
            is_container='list' , yang_name="constituent-vnfd" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__vnf_dependency = YANGDynClass(
            base=YANGListType("vnf_source_ref" , yc_vnf_dependency_nsd__nsd_catalog_nsd_vnf_dependency ,
                              yang_name="vnf-dependency" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='vnf-source-ref' , extensions=None) ,
            is_container='list' , yang_name="vnf-dependency" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__logo = YANGDynClass(base=unicode , is_leaf=True , yang_name="logo" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)
        self.__id = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_dict={'length': [u'1..63']}) ,
                                 is_leaf=True , yang_name="id" , parent=self , path_helper=self._path_helper ,
                                 extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                 yang_type='string' , is_config=True)
        self.__version = YANGDynClass(base=unicode , is_leaf=True , yang_name="version" , parent=self ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                      defining_module='nsd' , yang_type='string' , is_config=True)
        self.__key_pair = YANGDynClass(
            base=YANGListType("name" , yc_key_pair_nsd__nsd_catalog_nsd_key_pair , yang_name="key-pair" , parent=self ,
                              is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='name' , extensions=None) , is_container='list' , yang_name="key-pair" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='list' , is_config=True)
        self.__vnffgd = YANGDynClass(
            base=YANGListType("id" , yc_vnffgd_nsd__nsd_catalog_nsd_vnffgd , yang_name="vnffgd" , parent=self ,
                              is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='id' , extensions=None) , is_container='list' , yang_name="vnffgd" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='list' , is_config=True)
        self.__input_parameter_xpath = YANGDynClass(
            base=YANGListType("xpath" , yc_input_parameter_xpath_nsd__nsd_catalog_nsd_input_parameter_xpath ,
                              yang_name="input-parameter-xpath" , parent=self , is_container='list' ,
                              user_ordered=False , path_helper=self._path_helper , yang_keys='xpath' ,
                              extensions=None) , is_container='list' , yang_name="input-parameter-xpath" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__initial_service_primitive = YANGDynClass(
            base=YANGListType("seq" , yc_initial_service_primitive_nsd__nsd_catalog_nsd_initial_service_primitive ,
                              yang_name="initial-service-primitive" , parent=self , is_container='list' ,
                              user_ordered=False , path_helper=self._path_helper , yang_keys='seq' , extensions=None) ,
            is_container='list' , yang_name="initial-service-primitive" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__vendor = YANGDynClass(base=unicode , is_leaf=True , yang_name="vendor" , parent=self ,
                                     path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                     yang_type='string' , is_config=True)
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='string' , is_config=True)
        self.__short_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                         defining_module='nsd' , yang_type='string' , is_config=True)
        self.__connection_point = YANGDynClass(
            base=YANGListType("name" , yc_connection_point_nsd__nsd_catalog_nsd_connection_point ,
                              yang_name="connection-point" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="connection-point" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__vld = YANGDynClass(
            base=YANGListType("id" , yc_vld_nsd__nsd_catalog_nsd_vld , yang_name="vld" , parent=self ,
                              is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='id' , extensions=None) , is_container='list' , yang_name="vld" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__monitoring_param = YANGDynClass(
            base=YANGListType("id" , yc_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param ,
                              yang_name="monitoring-param" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='id' , extensions=None) , is_container='list' ,
            yang_name="monitoring-param" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='list' , is_config=True)
        self.__user = YANGDynClass(
            base=YANGListType("name" , yc_user_nsd__nsd_catalog_nsd_user , yang_name="user" , parent=self ,
                              is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='name' , extensions=None) , is_container='list' , yang_name="user" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='list' , is_config=True)
        self.__ip_profiles = YANGDynClass(
            base=YANGListType("name" , yc_ip_profiles_nsd__nsd_catalog_nsd_ip_profiles , yang_name="ip-profiles" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='name' , extensions=None) , is_container='list' , yang_name="ip-profiles" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='list' , is_config=True)
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)
        self.__parameter_pool = YANGDynClass(
            base=YANGListType("name" , yc_parameter_pool_nsd__nsd_catalog_nsd_parameter_pool ,
                              yang_name="parameter-pool" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="parameter-pool" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__scaling_group_descriptor = YANGDynClass(
            base=YANGListType("name" , yc_scaling_group_descriptor_nsd__nsd_catalog_nsd_scaling_group_descriptor ,
                              yang_name="scaling-group-descriptor" , parent=self , is_container='list' ,
                              user_ordered=False , path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="scaling-group-descriptor" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__service_primitive = YANGDynClass(
            base=YANGListType("name" , yc_service_primitive_nsd__nsd_catalog_nsd_service_primitive ,
                              yang_name="service-primitive" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="service-primitive" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog' , u'nsd']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd_catalog/nsd/id (string)

    YANG Description: Identifier for the NSD.
    """
        return self.__id

    def _set_id(self , v , load=False):
        """
    Setter method for id, mapped from YANG variable /nsd_catalog/nsd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier for the NSD.
    """
        parent = getattr(self , "_parent" , None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=RestrictedClassType(base_type=unicode , restriction_dict={'length': [u'1..63']}) ,
                             is_leaf=True , yang_name="id" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=unicode, restriction_dict={'length': [u'1..63']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__id = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=RestrictedClassType(base_type=unicode , restriction_dict={'length': [u'1..63']}) ,
                                 is_leaf=True , yang_name="id" , parent=self , path_helper=self._path_helper ,
                                 extmethods=self._extmethods , register_paths=True , is_keyval=True ,
                                 namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                 yang_type='string' , is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd_catalog/nsd/name (string)

    YANG Description: NSD name.
    """
        return self.__name

    def _set_name(self , v , load=False):
        """
    Setter method for name, mapped from YANG variable /nsd_catalog/nsd/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: NSD name.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=unicode , is_leaf=True , yang_name="name" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)

    def _get_short_name(self):
        """
    Getter method for short_name, mapped from YANG variable /nsd_catalog/nsd/short_name (string)

    YANG Description: Short name to appear as label in the UI
    """
        return self.__short_name

    def _set_short_name(self , v , load=False):
        """
    Setter method for short_name, mapped from YANG variable /nsd_catalog/nsd/short_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_short_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_short_name() directly.

    YANG Description: Short name to appear as label in the UI
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """short_name must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="short-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__short_name = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_short_name(self):
        self.__short_name = YANGDynClass(base=unicode , is_leaf=True , yang_name="short-name" , parent=self ,
                                         path_helper=self._path_helper , extmethods=self._extmethods ,
                                         register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                         defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_vendor(self):
        """
    Getter method for vendor, mapped from YANG variable /nsd_catalog/nsd/vendor (string)

    YANG Description: Vendor of the NSD.
    """
        return self.__vendor

    def _set_vendor(self , v , load=False):
        """
    Setter method for vendor, mapped from YANG variable /nsd_catalog/nsd/vendor (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vendor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vendor() directly.

    YANG Description: Vendor of the NSD.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="vendor" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vendor must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="vendor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__vendor = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vendor(self):
        self.__vendor = YANGDynClass(base=unicode , is_leaf=True , yang_name="vendor" , parent=self ,
                                     path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                     namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                     yang_type='string' , is_config=True)

    def _get_logo(self):
        """
    Getter method for logo, mapped from YANG variable /nsd_catalog/nsd/logo (string)

    YANG Description: File path for  the vendor specific logo. For example icons/mylogo.png.
The logo  should be part of the network service
    """
        return self.__logo

    def _set_logo(self , v , load=False):
        """
    Setter method for logo, mapped from YANG variable /nsd_catalog/nsd/logo (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logo is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logo() directly.

    YANG Description: File path for  the vendor specific logo. For example icons/mylogo.png.
The logo  should be part of the network service
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="logo" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """logo must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="logo", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__logo = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_logo(self):
        self.__logo = YANGDynClass(base=unicode , is_leaf=True , yang_name="logo" , parent=self ,
                                   path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                                   namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                   yang_type='string' , is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd_catalog/nsd/description (string)

    YANG Description: Description of the NSD.
    """
        return self.__description

    def _set_description(self , v , load=False):
        """
    Setter method for description, mapped from YANG variable /nsd_catalog/nsd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the NSD.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__description = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=unicode , is_leaf=True , yang_name="description" , parent=self ,
                                          path_helper=self._path_helper , extmethods=self._extmethods ,
                                          register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                          defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_version(self):
        """
    Getter method for version, mapped from YANG variable /nsd_catalog/nsd/version (string)

    YANG Description: Version of the NSD
    """
        return self.__version

    def _set_version(self , v , load=False):
        """
    Setter method for version, mapped from YANG variable /nsd_catalog/nsd/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Version of the NSD
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , is_leaf=True , yang_name="version" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """version must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__version = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(base=unicode , is_leaf=True , yang_name="version" , parent=self ,
                                      path_helper=self._path_helper , extmethods=self._extmethods ,
                                      register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                                      defining_module='nsd' , yang_type='string' , is_config=True)

    def _get_connection_point(self):
        """
    Getter method for connection_point, mapped from YANG variable /nsd_catalog/nsd/connection_point (list)

    YANG Description: List for external connection points.
Each NS has one or more external connection
points. As the name implies that external
connection points are used for connecting
the NS to other NS or to external networks.
Each NS exposes these connection points to
the orchestrator. The orchestrator can
construct network service chains by
connecting the connection points between
different NS.
    """
        return self.__connection_point

    def _set_connection_point(self , v , load=False):
        """
    Setter method for connection_point, mapped from YANG variable /nsd_catalog/nsd/connection_point (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connection_point is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connection_point() directly.

    YANG Description: List for external connection points.
Each NS has one or more external connection
points. As the name implies that external
connection points are used for connecting
the NS to other NS or to external networks.
Each NS exposes these connection points to
the orchestrator. The orchestrator can
construct network service chains by
connecting the connection points between
different NS.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" , yc_connection_point_nsd__nsd_catalog_nsd_connection_point ,
                                                   yang_name="connection-point" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="connection-point" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """connection_point must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_connection_point_nsd__nsd_catalog_nsd_connection_point, yang_name="connection-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="connection-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__connection_point = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_connection_point(self):
        self.__connection_point = YANGDynClass(
            base=YANGListType("name" , yc_connection_point_nsd__nsd_catalog_nsd_connection_point ,
                              yang_name="connection-point" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="connection-point" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    def _get_scaling_group_descriptor(self):
        """
    Getter method for scaling_group_descriptor, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor (list)

    YANG Description: scaling group descriptor within this network service.
The scaling group defines a group of VNFs,
and the ratio of VNFs in the network service
that is used as target for scaling action
    """
        return self.__scaling_group_descriptor

    def _set_scaling_group_descriptor(self , v , load=False):
        """
    Setter method for scaling_group_descriptor, mapped from YANG variable /nsd_catalog/nsd/scaling_group_descriptor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_group_descriptor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_group_descriptor() directly.

    YANG Description: scaling group descriptor within this network service.
The scaling group defines a group of VNFs,
and the ratio of VNFs in the network service
that is used as target for scaling action
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" ,
                                                   yc_scaling_group_descriptor_nsd__nsd_catalog_nsd_scaling_group_descriptor ,
                                                   yang_name="scaling-group-descriptor" , parent=self ,
                                                   is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
                             is_container='list' , yang_name="scaling-group-descriptor" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """scaling_group_descriptor must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_scaling_group_descriptor_nsd__nsd_catalog_nsd_scaling_group_descriptor, yang_name="scaling-group-descriptor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-group-descriptor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__scaling_group_descriptor = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_scaling_group_descriptor(self):
        self.__scaling_group_descriptor = YANGDynClass(
            base=YANGListType("name" , yc_scaling_group_descriptor_nsd__nsd_catalog_nsd_scaling_group_descriptor ,
                              yang_name="scaling-group-descriptor" , parent=self , is_container='list' ,
                              user_ordered=False , path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="scaling-group-descriptor" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    def _get_vnffgd(self):
        """
    Getter method for vnffgd, mapped from YANG variable /nsd_catalog/nsd/vnffgd (list)

    YANG Description: List of VNF Forwarding Graph Descriptors (VNFFGD).
    """
        return self.__vnffgd

    def _set_vnffgd(self , v , load=False):
        """
    Setter method for vnffgd, mapped from YANG variable /nsd_catalog/nsd/vnffgd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnffgd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnffgd() directly.

    YANG Description: List of VNF Forwarding Graph Descriptors (VNFFGD).
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("id" , yc_vnffgd_nsd__nsd_catalog_nsd_vnffgd , yang_name="vnffgd" ,
                                                   parent=self , is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='id' , extensions=None) ,
                             is_container='list' , yang_name="vnffgd" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnffgd must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_vnffgd_nsd__nsd_catalog_nsd_vnffgd, yang_name="vnffgd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vnffgd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__vnffgd = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnffgd(self):
        self.__vnffgd = YANGDynClass(
            base=YANGListType("id" , yc_vnffgd_nsd__nsd_catalog_nsd_vnffgd , yang_name="vnffgd" , parent=self ,
                              is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='id' , extensions=None) , is_container='list' , yang_name="vnffgd" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='list' , is_config=True)

    def _get_ip_profiles(self):
        """
    Getter method for ip_profiles, mapped from YANG variable /nsd_catalog/nsd/ip_profiles (list)

    YANG Description: List of IP Profiles.
  IP Profile describes the IP characteristics for the Virtual-Link
    """
        return self.__ip_profiles

    def _set_ip_profiles(self , v , load=False):
        """
    Setter method for ip_profiles, mapped from YANG variable /nsd_catalog/nsd/ip_profiles (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_profiles is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_profiles() directly.

    YANG Description: List of IP Profiles.
  IP Profile describes the IP characteristics for the Virtual-Link
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" , yc_ip_profiles_nsd__nsd_catalog_nsd_ip_profiles ,
                                                   yang_name="ip-profiles" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="ip-profiles" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """ip_profiles must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_ip_profiles_nsd__nsd_catalog_nsd_ip_profiles, yang_name="ip-profiles", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="ip-profiles", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__ip_profiles = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_ip_profiles(self):
        self.__ip_profiles = YANGDynClass(
            base=YANGListType("name" , yc_ip_profiles_nsd__nsd_catalog_nsd_ip_profiles , yang_name="ip-profiles" ,
                              parent=self , is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='name' , extensions=None) , is_container='list' , yang_name="ip-profiles" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='list' , is_config=True)

    def _get_initial_service_primitive(self):
        """
    Getter method for initial_service_primitive, mapped from YANG variable /nsd_catalog/nsd/initial_service_primitive (list)

    YANG Description: Initial set of service primitives for NSD.
    """
        return self.__initial_service_primitive

    def _set_initial_service_primitive(self , v , load=False):
        """
    Setter method for initial_service_primitive, mapped from YANG variable /nsd_catalog/nsd/initial_service_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_initial_service_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_initial_service_primitive() directly.

    YANG Description: Initial set of service primitives for NSD.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("seq" ,
                                                   yc_initial_service_primitive_nsd__nsd_catalog_nsd_initial_service_primitive ,
                                                   yang_name="initial-service-primitive" , parent=self ,
                                                   is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='seq' , extensions=None) ,
                             is_container='list' , yang_name="initial-service-primitive" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """initial_service_primitive must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("seq",yc_initial_service_primitive_nsd__nsd_catalog_nsd_initial_service_primitive, yang_name="initial-service-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-service-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__initial_service_primitive = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_initial_service_primitive(self):
        self.__initial_service_primitive = YANGDynClass(
            base=YANGListType("seq" , yc_initial_service_primitive_nsd__nsd_catalog_nsd_initial_service_primitive ,
                              yang_name="initial-service-primitive" , parent=self , is_container='list' ,
                              user_ordered=False , path_helper=self._path_helper , yang_keys='seq' , extensions=None) ,
            is_container='list' , yang_name="initial-service-primitive" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    def _get_terminate_service_primitive(self):
        """
    Getter method for terminate_service_primitive, mapped from YANG variable /nsd_catalog/nsd/terminate_service_primitive (list)

    YANG Description: Set of service primitives during
termination for NSD.
    """
        return self.__terminate_service_primitive

    def _set_terminate_service_primitive(self , v , load=False):
        """
    Setter method for terminate_service_primitive, mapped from YANG variable /nsd_catalog/nsd/terminate_service_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminate_service_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminate_service_primitive() directly.

    YANG Description: Set of service primitives during
termination for NSD.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("seq" ,
                                                   yc_terminate_service_primitive_nsd__nsd_catalog_nsd_terminate_service_primitive ,
                                                   yang_name="terminate-service-primitive" , parent=self ,
                                                   is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='seq' , extensions=None) ,
                             is_container='list' , yang_name="terminate-service-primitive" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """terminate_service_primitive must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("seq",yc_terminate_service_primitive_nsd__nsd_catalog_nsd_terminate_service_primitive, yang_name="terminate-service-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-service-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__terminate_service_primitive = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_terminate_service_primitive(self):
        self.__terminate_service_primitive = YANGDynClass(
            base=YANGListType("seq" , yc_terminate_service_primitive_nsd__nsd_catalog_nsd_terminate_service_primitive ,
                              yang_name="terminate-service-primitive" , parent=self , is_container='list' ,
                              user_ordered=False , path_helper=self._path_helper , yang_keys='seq' , extensions=None) ,
            is_container='list' , yang_name="terminate-service-primitive" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    def _get_input_parameter_xpath(self):
        """
    Getter method for input_parameter_xpath, mapped from YANG variable /nsd_catalog/nsd/input_parameter_xpath (list)

    YANG Description: List of xpaths to parameters inside the NSD
the can be customized during the instantiation.
    """
        return self.__input_parameter_xpath

    def _set_input_parameter_xpath(self , v , load=False):
        """
    Setter method for input_parameter_xpath, mapped from YANG variable /nsd_catalog/nsd/input_parameter_xpath (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_parameter_xpath is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_parameter_xpath() directly.

    YANG Description: List of xpaths to parameters inside the NSD
the can be customized during the instantiation.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("xpath" ,
                                                   yc_input_parameter_xpath_nsd__nsd_catalog_nsd_input_parameter_xpath ,
                                                   yang_name="input-parameter-xpath" , parent=self ,
                                                   is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='xpath' ,
                                                   extensions=None) , is_container='list' ,
                             yang_name="input-parameter-xpath" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """input_parameter_xpath must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("xpath",yc_input_parameter_xpath_nsd__nsd_catalog_nsd_input_parameter_xpath, yang_name="input-parameter-xpath", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='xpath', extensions=None), is_container='list', yang_name="input-parameter-xpath", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__input_parameter_xpath = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_input_parameter_xpath(self):
        self.__input_parameter_xpath = YANGDynClass(
            base=YANGListType("xpath" , yc_input_parameter_xpath_nsd__nsd_catalog_nsd_input_parameter_xpath ,
                              yang_name="input-parameter-xpath" , parent=self , is_container='list' ,
                              user_ordered=False , path_helper=self._path_helper , yang_keys='xpath' ,
                              extensions=None) , is_container='list' , yang_name="input-parameter-xpath" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    def _get_parameter_pool(self):
        """
    Getter method for parameter_pool, mapped from YANG variable /nsd_catalog/nsd/parameter_pool (list)

    YANG Description: Pool of parameter values which must be
pulled from during configuration
    """
        return self.__parameter_pool

    def _set_parameter_pool(self , v , load=False):
        """
    Setter method for parameter_pool, mapped from YANG variable /nsd_catalog/nsd/parameter_pool (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter_pool() directly.

    YANG Description: Pool of parameter values which must be
pulled from during configuration
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" , yc_parameter_pool_nsd__nsd_catalog_nsd_parameter_pool ,
                                                   yang_name="parameter-pool" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="parameter-pool" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """parameter_pool must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_pool_nsd__nsd_catalog_nsd_parameter_pool, yang_name="parameter-pool", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__parameter_pool = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_parameter_pool(self):
        self.__parameter_pool = YANGDynClass(
            base=YANGListType("name" , yc_parameter_pool_nsd__nsd_catalog_nsd_parameter_pool ,
                              yang_name="parameter-pool" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="parameter-pool" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    def _get_key_pair(self):
        """
    Getter method for key_pair, mapped from YANG variable /nsd_catalog/nsd/key_pair (list)

    YANG Description: Used to configure the list of public keys to be injected as part
of ns instantiation
    """
        return self.__key_pair

    def _set_key_pair(self , v , load=False):
        """
    Setter method for key_pair, mapped from YANG variable /nsd_catalog/nsd/key_pair (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_pair is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_pair() directly.

    YANG Description: Used to configure the list of public keys to be injected as part
of ns instantiation
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" , yc_key_pair_nsd__nsd_catalog_nsd_key_pair ,
                                                   yang_name="key-pair" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="key-pair" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """key_pair must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_key_pair_nsd__nsd_catalog_nsd_key_pair, yang_name="key-pair", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="key-pair", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__key_pair = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_key_pair(self):
        self.__key_pair = YANGDynClass(
            base=YANGListType("name" , yc_key_pair_nsd__nsd_catalog_nsd_key_pair , yang_name="key-pair" , parent=self ,
                              is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='name' , extensions=None) , is_container='list' , yang_name="key-pair" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='list' , is_config=True)

    def _get_user(self):
        """
    Getter method for user, mapped from YANG variable /nsd_catalog/nsd/user (list)

    YANG Description: List of users to be added through cloud-config
    """
        return self.__user

    def _set_user(self , v , load=False):
        """
    Setter method for user, mapped from YANG variable /nsd_catalog/nsd/user (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user() directly.

    YANG Description: List of users to be added through cloud-config
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" , yc_user_nsd__nsd_catalog_nsd_user , yang_name="user" ,
                                                   parent=self , is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
                             is_container='list' , yang_name="user" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """user must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_user_nsd__nsd_catalog_nsd_user, yang_name="user", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__user = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_user(self):
        self.__user = YANGDynClass(
            base=YANGListType("name" , yc_user_nsd__nsd_catalog_nsd_user , yang_name="user" , parent=self ,
                              is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='name' , extensions=None) , is_container='list' , yang_name="user" ,
            parent=self , path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
            extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
            yang_type='list' , is_config=True)

    def _get_vld(self):
        """
    Getter method for vld, mapped from YANG variable /nsd_catalog/nsd/vld (list)
    """
        return self.__vld

    def _set_vld(self , v , load=False):
        """
    Setter method for vld, mapped from YANG variable /nsd_catalog/nsd/vld (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vld is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vld() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=YANGListType("id" , yc_vld_nsd__nsd_catalog_nsd_vld , yang_name="vld" , parent=self ,
                                               is_container='list' , user_ordered=False ,
                                               path_helper=self._path_helper , yang_keys='id' , extensions=None) ,
                             is_container='list' , yang_name="vld" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vld must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_vld_nsd__nsd_catalog_nsd_vld, yang_name="vld", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vld", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__vld = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vld(self):
        self.__vld = YANGDynClass(
            base=YANGListType("id" , yc_vld_nsd__nsd_catalog_nsd_vld , yang_name="vld" , parent=self ,
                              is_container='list' , user_ordered=False , path_helper=self._path_helper ,
                              yang_keys='id' , extensions=None) , is_container='list' , yang_name="vld" , parent=self ,
            path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    def _get_constituent_vnfd(self):
        """
    Getter method for constituent_vnfd, mapped from YANG variable /nsd_catalog/nsd/constituent_vnfd (list)

    YANG Description: List of VNFDs that are part of this
network service.
    """
        return self.__constituent_vnfd

    def _set_constituent_vnfd(self , v , load=False):
        """
    Setter method for constituent_vnfd, mapped from YANG variable /nsd_catalog/nsd/constituent_vnfd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_constituent_vnfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_constituent_vnfd() directly.

    YANG Description: List of VNFDs that are part of this
network service.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("member_vnf_index" ,
                                                   yc_constituent_vnfd_nsd__nsd_catalog_nsd_constituent_vnfd ,
                                                   yang_name="constituent-vnfd" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='member-vnf-index' , extensions=None) ,
                             is_container='list' , yang_name="constituent-vnfd" , parent=self ,
                             path_helper=self._path_helper , extmethods=self._extmethods , register_paths=True ,
                             extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """constituent_vnfd must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("member_vnf_index",yc_constituent_vnfd_nsd__nsd_catalog_nsd_constituent_vnfd, yang_name="constituent-vnfd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='member-vnf-index', extensions=None), is_container='list', yang_name="constituent-vnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__constituent_vnfd = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_constituent_vnfd(self):
        self.__constituent_vnfd = YANGDynClass(
            base=YANGListType("member_vnf_index" , yc_constituent_vnfd_nsd__nsd_catalog_nsd_constituent_vnfd ,
                              yang_name="constituent-vnfd" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='member-vnf-index' , extensions=None) ,
            is_container='list' , yang_name="constituent-vnfd" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    def _get_placement_groups(self):
        """
    Getter method for placement_groups, mapped from YANG variable /nsd_catalog/nsd/placement_groups (list)

    YANG Description: List of placement groups at NS level
    """
        return self.__placement_groups

    def _set_placement_groups(self , v , load=False):
        """
    Setter method for placement_groups, mapped from YANG variable /nsd_catalog/nsd/placement_groups (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_placement_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_placement_groups() directly.

    YANG Description: List of placement groups at NS level
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("name" , yc_placement_groups_nsd__nsd_catalog_nsd_placement_groups ,
                                                   yang_name="placement-groups" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='name' , extensions=None) , is_container='list' ,
                             yang_name="placement-groups" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """placement_groups must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_placement_groups_nsd__nsd_catalog_nsd_placement_groups, yang_name="placement-groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="placement-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__placement_groups = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_placement_groups(self):
        self.__placement_groups = YANGDynClass(
            base=YANGListType("name" , yc_placement_groups_nsd__nsd_catalog_nsd_placement_groups ,
                              yang_name="placement-groups" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="placement-groups" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    def _get_vnf_dependency(self):
        """
    Getter method for vnf_dependency, mapped from YANG variable /nsd_catalog/nsd/vnf_dependency (list)

    YANG Description: List of VNF dependencies.
    """
        return self.__vnf_dependency

    def _set_vnf_dependency(self , v , load=False):
        """
    Setter method for vnf_dependency, mapped from YANG variable /nsd_catalog/nsd/vnf_dependency (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_dependency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_dependency() directly.

    YANG Description: List of VNF dependencies.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("vnf_source_ref" ,
                                                   yc_vnf_dependency_nsd__nsd_catalog_nsd_vnf_dependency ,
                                                   yang_name="vnf-dependency" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper ,
                                                   yang_keys='vnf-source-ref' , extensions=None) , is_container='list' ,
                             yang_name="vnf-dependency" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """vnf_dependency must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("vnf_source_ref",yc_vnf_dependency_nsd__nsd_catalog_nsd_vnf_dependency, yang_name="vnf-dependency", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vnf-source-ref', extensions=None), is_container='list', yang_name="vnf-dependency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__vnf_dependency = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_vnf_dependency(self):
        self.__vnf_dependency = YANGDynClass(
            base=YANGListType("vnf_source_ref" , yc_vnf_dependency_nsd__nsd_catalog_nsd_vnf_dependency ,
                              yang_name="vnf-dependency" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='vnf-source-ref' , extensions=None) ,
            is_container='list' , yang_name="vnf-dependency" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    def _get_monitoring_param(self):
        """
    Getter method for monitoring_param, mapped from YANG variable /nsd_catalog/nsd/monitoring_param (list)
    """
        return self.__monitoring_param

    def _set_monitoring_param(self , v , load=False):
        """
    Setter method for monitoring_param, mapped from YANG variable /nsd_catalog/nsd/monitoring_param (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitoring_param is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitoring_param() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("id" , yc_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param ,
                                                   yang_name="monitoring-param" , parent=self , is_container='list' ,
                                                   user_ordered=False , path_helper=self._path_helper , yang_keys='id' ,
                                                   extensions=None) , is_container='list' ,
                             yang_name="monitoring-param" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """monitoring_param must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param, yang_name="monitoring-param", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-param", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__monitoring_param = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_monitoring_param(self):
        self.__monitoring_param = YANGDynClass(
            base=YANGListType("id" , yc_monitoring_param_nsd__nsd_catalog_nsd_monitoring_param ,
                              yang_name="monitoring-param" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='id' , extensions=None) , is_container='list' ,
            yang_name="monitoring-param" , parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
            register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
            defining_module='nsd' , yang_type='list' , is_config=True)

    def _get_service_primitive(self):
        """
    Getter method for service_primitive, mapped from YANG variable /nsd_catalog/nsd/service_primitive (list)

    YANG Description: Network service level service primitives.
    """
        return self.__service_primitive

    def _set_service_primitive(self , v , load=False):
        """
    Setter method for service_primitive, mapped from YANG variable /nsd_catalog/nsd/service_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_primitive() directly.

    YANG Description: Network service level service primitives.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v ,
                             base=YANGListType("name" , yc_service_primitive_nsd__nsd_catalog_nsd_service_primitive ,
                                               yang_name="service-primitive" , parent=self , is_container='list' ,
                                               user_ordered=False , path_helper=self._path_helper , yang_keys='name' ,
                                               extensions=None) , is_container='list' , yang_name="service-primitive" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , extensions=None , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """service_primitive must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_service_primitive_nsd__nsd_catalog_nsd_service_primitive, yang_name="service-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__service_primitive = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_service_primitive(self):
        self.__service_primitive = YANGDynClass(
            base=YANGListType("name" , yc_service_primitive_nsd__nsd_catalog_nsd_service_primitive ,
                              yang_name="service-primitive" , parent=self , is_container='list' , user_ordered=False ,
                              path_helper=self._path_helper , yang_keys='name' , extensions=None) ,
            is_container='list' , yang_name="service-primitive" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    id = __builtin__.property(_get_id , _set_id)
    name = __builtin__.property(_get_name , _set_name)
    short_name = __builtin__.property(_get_short_name , _set_short_name)
    vendor = __builtin__.property(_get_vendor , _set_vendor)
    logo = __builtin__.property(_get_logo , _set_logo)
    description = __builtin__.property(_get_description , _set_description)
    version = __builtin__.property(_get_version , _set_version)
    connection_point = __builtin__.property(_get_connection_point , _set_connection_point)
    scaling_group_descriptor = __builtin__.property(_get_scaling_group_descriptor , _set_scaling_group_descriptor)
    vnffgd = __builtin__.property(_get_vnffgd , _set_vnffgd)
    ip_profiles = __builtin__.property(_get_ip_profiles , _set_ip_profiles)
    initial_service_primitive = __builtin__.property(_get_initial_service_primitive , _set_initial_service_primitive)
    terminate_service_primitive = __builtin__.property(_get_terminate_service_primitive ,
                                                       _set_terminate_service_primitive)
    input_parameter_xpath = __builtin__.property(_get_input_parameter_xpath , _set_input_parameter_xpath)
    parameter_pool = __builtin__.property(_get_parameter_pool , _set_parameter_pool)
    key_pair = __builtin__.property(_get_key_pair , _set_key_pair)
    user = __builtin__.property(_get_user , _set_user)
    vld = __builtin__.property(_get_vld , _set_vld)
    constituent_vnfd = __builtin__.property(_get_constituent_vnfd , _set_constituent_vnfd)
    placement_groups = __builtin__.property(_get_placement_groups , _set_placement_groups)
    vnf_dependency = __builtin__.property(_get_vnf_dependency , _set_vnf_dependency)
    monitoring_param = __builtin__.property(_get_monitoring_param , _set_monitoring_param)
    service_primitive = __builtin__.property(_get_service_primitive , _set_service_primitive)

    _pyangbind_elements = {'id': id , 'name': name , 'short_name': short_name , 'vendor': vendor , 'logo': logo ,
                           'description': description , 'version': version , 'connection_point': connection_point ,
                           'scaling_group_descriptor': scaling_group_descriptor , 'vnffgd': vnffgd ,
                           'ip_profiles': ip_profiles , 'initial_service_primitive': initial_service_primitive ,
                           'terminate_service_primitive': terminate_service_primitive ,
                           'input_parameter_xpath': input_parameter_xpath , 'parameter_pool': parameter_pool ,
                           'key_pair': key_pair , 'user': user , 'vld': vld , 'constituent_vnfd': constituent_vnfd ,
                           'placement_groups': placement_groups , 'vnf_dependency': vnf_dependency ,
                           'monitoring_param': monitoring_param , 'service_primitive': service_primitive , }


class yc_nsd_catalog_nsd__nsd_catalog(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd-catalog. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__schema_version' , '__nsd' ,)

    _yang_name = 'nsd-catalog'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__nsd = YANGDynClass(
            base=YANGListType("id" , yc_nsd_nsd__nsd_catalog_nsd , yang_name="nsd" , parent=self , is_container='list' ,
                              user_ordered=False , path_helper=self._path_helper , yang_keys='id' , extensions=None) ,
            is_container='list' , yang_name="nsd" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)
        self.__schema_version = YANGDynClass(base=unicode , default=unicode("v3.0") , is_leaf=True ,
                                             yang_name="schema-version" , parent=self , path_helper=self._path_helper ,
                                             extmethods=self._extmethods , register_paths=True ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                             yang_type='string' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return [u'nsd-catalog']

    def _get_schema_version(self):
        """
    Getter method for schema_version, mapped from YANG variable /nsd_catalog/schema_version (string)

    YANG Description: Schema version for the NSD. If unspecified, it assumes v3.0
    """
        return self.__schema_version

    def _set_schema_version(self , v , load=False):
        """
    Setter method for schema_version, mapped from YANG variable /nsd_catalog/schema_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_schema_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_schema_version() directly.

    YANG Description: Schema version for the NSD. If unspecified, it assumes v3.0
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=unicode , default=unicode("v3.0") , is_leaf=True , yang_name="schema-version" ,
                             parent=self , path_helper=self._path_helper , extmethods=self._extmethods ,
                             register_paths=True , namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' ,
                             defining_module='nsd' , yang_type='string' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """schema_version must be of a type compatible with string""" ,
                'defined-type': "string" ,
                'generated-type': """YANGDynClass(base=unicode, default=unicode("v3.0"), is_leaf=True, yang_name="schema-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='string', is_config=True)""" ,
            })

        self.__schema_version = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_schema_version(self):
        self.__schema_version = YANGDynClass(base=unicode , default=unicode("v3.0") , is_leaf=True ,
                                             yang_name="schema-version" , parent=self , path_helper=self._path_helper ,
                                             extmethods=self._extmethods , register_paths=True ,
                                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                             yang_type='string' , is_config=True)

    def _get_nsd(self):
        """
    Getter method for nsd, mapped from YANG variable /nsd_catalog/nsd (list)
    """
        return self.__nsd

    def _set_nsd(self , v , load=False):
        """
    Setter method for nsd, mapped from YANG variable /nsd_catalog/nsd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=YANGListType("id" , yc_nsd_nsd__nsd_catalog_nsd , yang_name="nsd" , parent=self ,
                                                   is_container='list' , user_ordered=False ,
                                                   path_helper=self._path_helper , yang_keys='id' , extensions=None) ,
                             is_container='list' , yang_name="nsd" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='list' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """nsd must be of a type compatible with list""" ,
                'defined-type': "list" ,
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_nsd_nsd__nsd_catalog_nsd, yang_name="nsd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nsd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='list', is_config=True)""" ,
            })

        self.__nsd = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_nsd(self):
        self.__nsd = YANGDynClass(
            base=YANGListType("id" , yc_nsd_nsd__nsd_catalog_nsd , yang_name="nsd" , parent=self , is_container='list' ,
                              user_ordered=False , path_helper=self._path_helper , yang_keys='id' , extensions=None) ,
            is_container='list' , yang_name="nsd" , parent=self , path_helper=self._path_helper ,
            extmethods=self._extmethods , register_paths=True , extensions=None ,
            namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' , yang_type='list' ,
            is_config=True)

    schema_version = __builtin__.property(_get_schema_version , _set_schema_version)
    nsd = __builtin__.property(_get_nsd , _set_nsd)

    _pyangbind_elements = {'schema_version': schema_version , 'nsd': nsd , }


class nsd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd - based on the path /nsd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper' , '_extmethods' , '__nsd_catalog' ,)

    _yang_name = 'nsd'

    _pybind_generated_by = 'container'

    def __init__(self , *args , **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__nsd_catalog = YANGDynClass(base=yc_nsd_catalog_nsd__nsd_catalog , is_container='container' ,
                                          yang_name="nsd-catalog" , parent=self , path_helper=self._path_helper ,
                                          extmethods=self._extmethods , register_paths=True , extensions=None ,
                                          namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                          yang_type='container' , is_config=True)

        load = kwargs.pop("load" , None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0] , e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0] , e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self , "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0] , e))
                else:
                    setmethod(getattr(args[0] , e) , load=load)

    def _path(self):
        if hasattr(self , "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return []

    def _get_nsd_catalog(self):
        """
    Getter method for nsd_catalog, mapped from YANG variable /nsd_catalog (container)
    """
        return self.__nsd_catalog

    def _set_nsd_catalog(self , v , load=False):
        """
    Setter method for nsd_catalog, mapped from YANG variable /nsd_catalog (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd_catalog is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd_catalog() directly.
    """
        if hasattr(v , "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v , base=yc_nsd_catalog_nsd__nsd_catalog , is_container='container' ,
                             yang_name="nsd-catalog" , parent=self , path_helper=self._path_helper ,
                             extmethods=self._extmethods , register_paths=True , extensions=None ,
                             namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                             yang_type='container' , is_config=True)
        except (TypeError , ValueError):
            raise ValueError({
                'error-string': """nsd_catalog must be of a type compatible with container""" ,
                'defined-type': "container" ,
                'generated-type': """YANGDynClass(base=yc_nsd_catalog_nsd__nsd_catalog, is_container='container', yang_name="nsd-catalog", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd', defining_module='nsd', yang_type='container', is_config=True)""" ,
            })

        self.__nsd_catalog = t
        if hasattr(self , '_set'):
            self._set()

    def _unset_nsd_catalog(self):
        self.__nsd_catalog = YANGDynClass(base=yc_nsd_catalog_nsd__nsd_catalog , is_container='container' ,
                                          yang_name="nsd-catalog" , parent=self , path_helper=self._path_helper ,
                                          extmethods=self._extmethods , register_paths=True , extensions=None ,
                                          namespace='urn:ietf:params:xml:ns:yang:nfvo:nsd' , defining_module='nsd' ,
                                          yang_type='container' , is_config=True)

    nsd_catalog = __builtin__.property(_get_nsd_catalog , _set_nsd_catalog)

    _pyangbind_elements = {'nsd_catalog': nsd_catalog , }


class vnfd_base(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vnfd-base - based on the path /vnfd-base. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class nsd_base(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module nsd-base - based on the path /nsd-base. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}