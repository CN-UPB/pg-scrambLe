\chapter{Work Packages}
\label{ch:WP}

\section{Translator}
\paragraph{}
In a hierarchical architecture involving different MANOs, there is a need of conversion of network descriptors to schemas of respective MANO. Service Descriptor Translator (SDT) serves the purpose of translating network descriptors, namely NSDs and VNFDs from schema of SONATA Pishahang to that of OSM and vice versa.
\paragraph{}
In a scenario, where a parent MANO, say Pishahang decides to deploy one of the network services in its lower hierarchy MANO, say OSM, the NSD and VNFD(s) need to be converted to the descriptor schema of OSM. In such an event, the Scramble plugin calls the translator service and sends the descriptors to the SDT, where the translation of the descriptors takes place and the translated descriptors are sent to Adaptor utility for deployment in appropriate MANO. Figure \ref{fig:service-descriptor-translator} gives a high level view of Translator.
\paragraph{}
Scramble plug-in installed within the parent MANO forwards the network descriptors with service request to Scramble Main-Engine. Main-Engine checks the service request and sends the network descriptors to Translator along with the information of destination schema. On receiving the network descriptors, SDT translates the same to requested schema and calls the validator function to validate the translated network descriptors. Once validation is complete, the translated descriptors will be sent to Adaptor for deployment. 




\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{"figures/Translator"}
	\caption{Transltor}
	\label{fig:service-descriptor-translator}
\end{figure}

\subsection{Architecture \& Work flow}
\subsection{Usage}
The Translator engine consists of the following modules:
\begin{enumerate}
	\item descriptorReader
	\item descriptorWriter
	\item utilities
	\item translator
	\item validator
	
\end{enumerate}

\subsubsection{descriptorReader}

This module is responsible to read a json/dictionary input (NSD/VNFD) and iterate over the keys and return a generator of an object to the calling program. This generator can be transformed to any python data structure for ease of use and navigation. 

The input to this module is a json or dictionary object.

\begin{lstlisting}[language=Python]
from descriptorReader import read_dict

pishahang = pishahang_descriptor ## the descriptor as a json or dict object

### reading a dict/ json content into a pandas dataframe
reader = read_dict()

pishahang_dataset = pd.DataFrame(
reader.dict_parser(pishahang,'root', 1, '0|preroot|0'), 
columns=['parent_level', 'parent_key', 'level', 'key', 'value', 'lineage'])


pishahang_dataset.sort_values(ascending=True, by=['level', 'parent_key'],inplace=True)
pishahang_dataset.fillna('NULL', inplace=True)
pishahang_dataset.reset_index(drop=True,inplace=True)

\end{lstlisting}
\subsubsection{descriptorWriter}

This module is responsible to read a python pandas Dataframe input and output a nested json/dictionary maintaining the nested structure in the dictionary.

\begin{lstlisting}[language=Python]
from descriptorWriter import write_dict

### writing from a pandas dataframe to a dict/json object
writer = write_dict()
pishahang_descriptor = writer.translate(pishahang_dataset.sort_values(by='lineage'))

\end{lstlisting}

\subsubsection{utilities}

This module is responsible for transforming the keys and map the corresponding values between sonata and osm descriptors. The module includes the 4 functions for translating between sonata and OSM descriptors. 
\begin{enumerate}
	\item translate\_to\_osm\_nsd()
	\item translate\_to\_osm\_vnfd()
	\item translate\_to\_sonata\_nsd()
	\item translate\_to\_sonata\_vnfd()
\end{enumerate}

\subsubsection{translator}

This is the interface where the actual translation request comes in. After a tranlsation request is received along with a descriptor, it calls the above modules translate and validate the descriptors (NSD/VNFD).

This following function translates OSM descriptor to Pishahang.
\begin{lstlisting}[language=Python]
import pymongo
from validate import validator
from utilities import setup

def toSonata(received_file):

	client = pymongo.MongoClient("mongodb://mongo:27017")
	setup_obj = setup(client)
	validate_obj = validator()
	
	if 'vnfd:vnfd-catalog' in received_file:
	
	## mongoDB document object to store the translated vnfd
	doc = setup_obj.db_descriptors["translated_vnfd"]
	
	## getting a translated sonata vnfd
	translated = setup_obj.translate_to_sonata_vnfd(received_file)
	
	## validating the translated descriptor which returns a "True"/ "False" string
	check = validate_obj.sonata_vnfd_validate(translated)
	
	if check == "True":
	## insert into mongoDB as a Document
	temp = doc.insert_one(translated)
	translated_ref = temp.inserted_id
	
	elif 'nsd:nsd-catalog' in received_file:
	
	## mongoDB document object to store the translated nsd
	doc = setup_obj.db_descriptors["translated_nsd"]
	
	## getting a translated sonata nsd
	translated = setup_obj.translate_to_sonata_nsd(received_file)
	
	## validating the translated descriptor which returns a "True"/ "False" string
	check = validate_obj.sonata_nsd_validate(translated)
	
	if check == "True"
	## insert into mongoDB as a Document
	temp = doc.insert_one(translated)
	translated_ref = temp.inserted_id
	
	return {"descriptor":translated ,"VALIDATE STATUS" :check}
\end{lstlisting}

\pagebreak

The following function translates Pishahang descriptor to OSM.
\begin{lstlisting}[language=Python]
import pymongo
from validate import validator
from utilities import setup

def toOsm(received_file):

	client = pymongo.MongoClient("mongodb://mongo:27017")
	setup_obj = setup(client)
	validate_obj = validator()
	
	if 'network_functions' in received_file:
	
	## mongoDB document object to store the translated nsd
	doc = setup_obj.db_descriptors["translated_nsd"]
	
	## getting a translated osm nsd
	translated = setup_obj.translate_to_osm_nsd(received_file)
	
	## validating the translated descriptor which returns a "True"/ "False" string
	check= validate_obj.osm_validator(translated)
	
	if check == "True":
	## insert into mongoDB as a Document
	temp = doc.insert_one(translated)
	translated_ref = temp.inserted_id
	
	elif 'virtual_deployment_units' in received_file:
	
	## mongoDB document object to store the translated vnfd
	doc = setup_obj.db_descriptors["translated_vnfd"]
	
	## getting a translated osm vnfd
	translated = setup_obj.translate_to_osm_vnfd(received_file)
	
	## validating the translated vnfd which returns a "True"/ "False" string
	check= validate_obj.osm_validator(translated)
	
	if check == "True":
	## insert into mongoDB as a Document
	temp = doc.insert_one(translated)
	translated_ref = temp.inserted_id
	
	return {"descriptor":translated ,"VALIDATE STATUS" :check}
\end{lstlisting}

\subsubsection{validator}

The validator validates the descriptors presented for translation. It differentiates between OSM, Pishahang and Sonata descriptors and also between NSD's and VNFD's. The sonata descriptor validation is mainly based on schema, implemented using python library jsonschema.draft4validator, this library helps by proving the complete path of the error which comes very handy while debugging. The Validation for OSM is slightly complex than that compared to sonata validator, OSM validator can be divided into two parts. the first part validates the descriptors using schema with the same setup as that of sonata and the second part uses python object class for validation, this is done to replicate the validation method used by OSM hence to make sure that any descriptor that is validated by translator will be accepted by OSM.

\subsection{Challenges}

\subsection{Future scope of this work package}

Translator engine currently doesnot support the following:
\begin{enumerate}
	\item Forwarding Graph
	\item Juju charms in OSM
	\item Monitoring Parameters
\end{enumerate}

\subsubsection{Juju charms in OSM}
MANOs provide programmable and flexible management and orchestration of VNFs. OSM provides this flexibility through juju charms and Pishahang provides this through SSM/FSM (a container based solution). Because of these technological differences, direct translation between juju charms in OSM, and SSM (Service Specific Manager) and FSM (Function Specific Manager) in Pishahang is not possible. 

As an alternative, it is possible to add charms functionality to Pishahang so that a descriptor containing juju charms can be deployed in both Pishahang and OSM with direct translation. This can be achieved by adding or modifying below things in Pishahang.
\begin{enumerate}
	\item Modify packaging and unpackaging techniques in Pishahang to accept charm package along with descriptors
	\item Add additional keys in descriptors to mention charm name, actions and vnf index similar to OSM
	\item Update Pishahang installation code to install juju and charm programs and tools
	\item Create an interface to execute actions on VNFs
	\item Create new container or component to perform actions on specified VNFs
	\item Manage removal or deletion of charms after life cycle of Network Service 
\end{enumerate} 

\newpage

\section{Splitter}
Splitter helps in splitting a Network Service (NS) into multiple sub Network services which can be deployed and instantiated individually on Internet Service Providers (ISPs) located over a vast geographical region spanning multiple domains and are orchestrated by different MANO frameworks. Splitter calls Service Descriptor Transltor if there is a need to translate the NS if it is to be deployed on a different MANO framework.

In this work package, a Service Descriptor Splitter (SDS) is implemented which splits the NSD of a network service. SDS takes
NSD as an input that contains all the information elements which can be extracted to generate separate NSDs. In the proposed approach, the service graph is extracted from the input NSD
and is split into subgraphs that result in a separate NSD which includes a set of elements such as VNFs, Virtual Links (VLs), forwarding graphs of VNFs etc, according to the specific MANO
framework.
\subsection{Architecture \& Work flow}
Service Descriptor Splitter consists of following functional items which 
\begin{itemize}
	\item The total number of NFs mentioned in all the set matches the number of NFs defined in the NSD.
	\item There are no invalid NFs in the sets received.
\end{itemize}

After validation the actual splitting starts. We have created classes for different sections of a NSD which encapsulate all the attributes and its values into a single unit which makes it very easy to process. Once the objects are set they are passed to different splitting functions based on there type. We have two different processing units for OSM and SONATA. Following are some functions responsible for splitting the NSD.

\begin{itemize}
	\item \textbf{Set General information: }This function copies all the general information from the main NSD to the sub NSDs. Information includes Vendor, author, Version, Descripton etc.
	\item \textbf{Split Network Functions: }This function splits the Network functions from NSD to sub sets according to the request parameter received. 
	\item \textbf{Split Virtual Links: }When a NSD is splitted into different parts, its topology changes. Change in topology results in changing of Virtual Links. For example if A, B and C are three Nfs and we are splitting them in such a way so that A and B remain in one NSD and C in separate NSD. A virtual link between B and C now does not make sense. So this link should be broken down and B’s output should be connected to the external end point which was connected to C’s input earlier. This function splits these kind of Virtual Links.
	\item \textbf{Split Forwarding Graph: }As explained in the above section, once the topology changes, the respective Forwarding graph also changes. Split forwarding graph pulls out the set of connection points and newly created virtual links and sets them in the sub NSDs.
\end{itemize} 

Once the Splitting is done, create file is responsible for creating YAML files depending on the number of sub NSDs created. These files are saved in the file system which can be downloaded or moved forward to the adopter for deployment purpose. Following figure \ref{fig:splitter} graphically represents the splitting architecture.



\subsection{Usage}

SDS is implemented as a micro-service which can be used independently from Translator or Wrapper by making a post call to the SDS. Following code snippet describes how to call SDS using POST call.

\begin{lstlisting}[caption=POST call to SDS, label=lis:postSDS]

splitter_url=http://$HOST:8003/Main_splitter/split

# Body: descriptor contains NSD, vnfid_set contains set of VNF ids
nsd = { 'descriptor' : descriptor, 'sets': vnfid_set}

LOG.info("Calling Scramble Splitter..." )
response  = requests.post(splitter_url,
                          data=json.dumps(nsd_to_split))

print(response)

\end{lstlisting}

Following are some of the important functions which helps SDS in splitting the NSD with respective code snippet.

\subsubsection{Basic Python classes for NSD Schema}
\subsubsection{Splitting} "splitsonata" calls the splitting function one by one to split the list of objects created out of NSD. Following code snippet shows the sequence of function calls.

\begin{lstlisting}[caption=Sequence of function calls, label=lis:functioncalls]

    def split_sonata(self):
        if self.validate() is not False:
            self.create_new_function_sets()
            self.set_connection_point_refs_for_virtual_functions()
            self.split_network_function()
            self.set_connection_points()
            self.split_virtual_links()
            self.split_forwarding_path()
            self.set_general_information()
            return self.create_files()
        else:
            print("Validation Failed!!")

\end{lstlisting}

\subsubsection{Validate} Validate method validates the request coming from the MANOs. For example, if MANO is requesting a NSD to be split into three parts but the original NSD contains just two VNFs then the SDS will throw validation error.

\begin{lstlisting}[caption=Splitting Request Validation, label=lis:validation]

    def validate(self):
        size = 0
        list_network_function = []
        for network_function_set in self.network_function_sets:
            size = size + len(network_function_set)
            for network_function in network_function_set:
                list_network_function.append(network_function)

        if size != len(self.utilityFunctions.list_nf):
            return False
        if len(list_network_function) != len(set(list_network_function)):
            return False

\end{lstlisting}

\subsubsection{Split Network Functions}
\todo[inline]{Content to be added}
\subsubsection{Split Forwarding Graph}

\todo[inline]{Content to be added}
\subsection{Challenges}
The NSD schema of Pishahang and OSM contains a lot of elements. However the challenge we faced was choosing which elements to include for splitting. We tackled it by including mandatory elements and few optional elements from the schema which were present in the input NSD.
\subsection{Future scope of Service Descriptor Splitter}
SDS can currently split NSD of Pishahang and OSM. SDS is built in such a way that it can be implemented for MANO frameworks as well. To implement SDS for a new MANO framework one can refer the implementation of either Pishahang or OSM. First step would be to create basic python classes from the NSD schema of the MANO framework then writing the utility functions to pull the information from the NSD file and store it in the objects of the basic python classes. Lastly writing splitting functions to actually split the list of objects in two or more parts.

Also, the current implementation considers all mandatory elements and a few optional elements from a NSD schema for splitting which can be extended to include other fields (Provided they are present in the input NSD for splitting).

Current implementation of SDS can split a forwarding graph of a NSD (Pishahang) with just three VNFs. Splitting of a forwarding graph is implemented by keeping future implementation for more than three VNFs in mind (Refer Splitting of Forwarding graph section)

\include{adaptor-arch}

