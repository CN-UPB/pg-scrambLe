\chapter{Work Packages}
\label{ch:WP}

\section{Translator}
\paragraph{}
In a hierarchical architecture involving different MANOs, there is a need of conversion of network descriptors to schemas of respective MANO. Service Descriptor Translator (SDT) serves the purpose of translating network descriptors, namely NSDs and VNFDs from schema of SONATA Pishahang to that of OSM and vice versa.
\paragraph{}
In a scenario, where a parent MANO, say Pishahang decides to deploy one of the network services in its lower hierarchy MANO, say OSM, the NSD and VNFD(s) need to be converted to the descriptor schema of OSM. In such an event, the Scramble plugin calls the translator service and sends the descriptors to the SDT, where the translation of the descriptors takes place and the translated descriptors are sent to Adaptor utility for deployment in appropriate MANO. Figure \ref{fig:service-descriptor-translator} gives a high level view of Translator.
\paragraph{}
Scramble plug-in installed within the parent MANO forwards the network descriptors with service request to Scramble Main-Engine. Main-Engine checks the service request and sends the network descriptors to Translator along with the information of destination schema. On receiving the network descriptors, SDT translates the same to requested schema and calls the validator function to validate the translated network descriptors. Once validation is complete, the translated descriptors will be sent to Adaptor for deployment. 




\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{"figures/Service Descriptor Translator"}
	\caption{}
	\label{fig:service-descriptor-translator}
\end{figure}

\subsection{Architecture \& Work flow}
\subsection{usage}
The Translator engine consists of the following modules:
\begin{enumerate}
	\item descriptorReader
	\item descriptorWriter
	\item utilities
	\item translator
	\item validator
	
\end{enumerate}

\subsubsection{descriptorReader}

This module is responsible to read a json/dictionary input (NSD/VNFD) and iterate over the keys and return a generator of an object to the calling program. This generator can be transformed to any python data structure for ease of use and navigation. 

The input to this module is a json or dictionary object.

\begin{lstlisting}[language=Python]
from descriptorReader import read_dict

pishahang = pishahang_descriptor ## the descriptor as a json or dict object

### reading a dict/ json content into a pandas dataframe
reader = read_dict()

pishahang_dataset = pd.DataFrame(
reader.dict_parser(pishahang,'root', 1, '0|preroot|0'), 
columns=['parent_level', 'parent_key', 'level', 'key', 'value', 'lineage'])


pishahang_dataset.sort_values(ascending=True, by=['level', 'parent_key'],inplace=True)
pishahang_dataset.fillna('NULL', inplace=True)
pishahang_dataset.reset_index(drop=True,inplace=True)

\end{lstlisting}
\subsubsection{descriptorWriter}

This module is responsible to read a python pandas Dataframe input and output a nested json/dictionary maintaining the nested structure in the dictionary.

\begin{lstlisting}[language=Python]
from descriptorWriter import write_dict

### writing from a pandas dataframe to a dict/json object
writer = write_dict()
pishahang_descriptor = writer.translate(pishahang_dataset.sort_values(by='lineage'))

\end{lstlisting}

\subsubsection{utilities}

This module is responsible for transforming the keys and map the corresponding values between sonata and osm descriptors. The module includes the 4 functions for translating between sonata and OSM descriptors. 
\begin{enumerate}
	\item translate\_to\_osm\_nsd()
	\item translate\_to\_osm\_vnfd()
	\item translate\_to\_sonata\_nsd()
	\item translate\_to\_sonata\_vnfd()
\end{enumerate}

\subsubsection{translator}

This is the interface where the actual translation request comes in. After a tranlsation request is received along with a descriptor, it calls the above modules translate and validate the descriptors (NSD/VNFD).

This following function translates OSM descriptor to sonata.
\begin{lstlisting}[language=Python]
import pymongo
from validate import validator
from utilities import setup

def toSonata(received_file):

	client = pymongo.MongoClient("mongodb://mongo:27017")
	setup_obj = setup(client)
	validate_obj = validator()
	
	if 'vnfd:vnfd-catalog' in received_file:
	
	## mongoDB document object to store the translated vnfd
	doc = setup_obj.db_descriptors["translated_vnfd"]
	
	## getting a translated sonata vnfd
	translated = setup_obj.translate_to_sonata_vnfd(received_file)
	
	## validating the translated descriptor which returns a "True"/ "False" string
	check = validate_obj.sonata_vnfd_validate(translated)
	
	if check == "True":
	## insert into mongoDB as a Document
	temp = doc.insert_one(translated)
	translated_ref = temp.inserted_id
	
	elif 'nsd:nsd-catalog' in received_file:
	
	## mongoDB document object to store the translated nsd
	doc = setup_obj.db_descriptors["translated_nsd"]
	
	## getting a translated sonata nsd
	translated = setup_obj.translate_to_sonata_nsd(received_file)
	
	## validating the translated descriptor which returns a "True"/ "False" string
	check = validate_obj.sonata_nsd_validate(translated)
	
	if check == "True"
	## insert into mongoDB as a Document
	temp = doc.insert_one(translated)
	translated_ref = temp.inserted_id
	
	return {"descriptor":translated ,"VALIDATE STATUS" :check}
\end{lstlisting}

The following function translates sonata descriptor to OSM.
\begin{lstlisting}[language=Python]
import pymongo
from validate import validator
from utilities import setup

def toOsm(received_file):

	client = pymongo.MongoClient("mongodb://mongo:27017")
	setup_obj = setup(client)
	validate_obj = validator()
	
	if 'network_functions' in received_file:
	
	## mongoDB document object to store the translated nsd
	doc = setup_obj.db_descriptors["translated_nsd"]
	
	## getting a translated osm nsd
	translated = setup_obj.translate_to_osm_nsd(received_file)
	
	## validating the translated descriptor which returns a "True"/ "False" string
	check= validate_obj.osm_validator(translated)
	
	if check == "True":
	## insert into mongoDB as a Document
	temp = doc.insert_one(translated)
	translated_ref = temp.inserted_id
	
	elif 'virtual_deployment_units' in received_file:
	
	## mongoDB document object to store the translated vnfd
	doc = setup_obj.db_descriptors["translated_vnfd"]
	
	## getting a translated osm vnfd
	translated = setup_obj.translate_to_osm_vnfd(received_file)
	
	## validating the translated vnfd which returns a "True"/ "False" string
	check= validate_obj.osm_validator(translated)
	
	if check == "True":
	## insert into mongoDB as a Document
	temp = doc.insert_one(translated)
	translated_ref = temp.inserted_id
	
	return {"descriptor":translated ,"VALIDATE STATUS" :check}
\end{lstlisting}

\subsubsection{validator}

\subsection{challenges}

\subsection{Future scope of this work package}

Translator engine currently doesnot support the following:
\begin{enumerate}
	\item Forwarding Graph
	\item Juju charms in OSM
	\item Monitoring Parameters
\end{enumerate}

\subsection{challenges}
\subsection{Future scope of this work package}

\section{Splitter}
Communication between MANO frameworks and Scramble happens through plug-ins. Plug-ins will have some random logic to generate a multiple set of Network Functions into which a Network Service needs to be divided. The multiple set of NFs is then forwarded to Gateway micro-service along with the NS file which just receives the request and forward it to the Main-Engine. The Main Engine acts as an interface to all three utilities including Splitter. Main engine is responsible for interoperability and communication between all utilities. All three utilities are containerized using docker for easy distribution and scaling. Once the Splitter receives the request for splitting along with the parameters it splits the NSD into sub NSDs.
\subsection{Architecture \& Work flow}
Before actual splitting of NSD, Splitter first validates if the the multiple set it received is valid or not. Following things are validated by the splitter.
\begin{itemize}
	\item The total number of NFs mentioned in all the set matches the number of NFs defined in the NSD.
	\item There are no invalid NFs in the sets received.
\end{itemize}

After validation the actual splitting starts. We have created classes for different sections of a NSD which encapsulate all the attributes and its values into a single unit which makes it very easy to process. Once the objects are set they are passed to different splitting functions based on there type. We have two different processing units for OSM and SONATA. Following are some functions responsible for splitting the NSD.

\begin{itemize}
	\item \textbf{Set General information: }This function copies all the general information from the main NSD to the sub NSDs. Information includes Vendor, author, Version, Descripton etc.
	\item \textbf{Split Network Functions: }This function splits the Network functions from NSD to sub sets according to the request parameter received. 
	\item \textbf{Split Virtual Links: }When a NSD is splitted into different parts, its topology changes. Change in topology results in changing of Virtual Links. For example if A, B and C are three Nfs and we are splitting them in such a way so that A and B remain in one NSD and C in separate NSD. A virtual link between B and C now does not make sense. So this link should be broken down and B’s output should be connected to the external end point which was connected to C’s input earlier. This function splits these kind of Virtual Links.
	\item \textbf{Split Forwarding Graph: }As explained in the above section, once the topology changes, the respective Forwarding graph also changes. Split forwarding graph pulls out the set of connection points and newly created virtual links and sets them in the sub NSDs.
\end{itemize} 

Once the Splitting is done, create file is responsible for creating YAML files depending on the number of sub NSDs created. These files are saved in the file system which can be downloaded or moved forward to the adopter for deployment purpose. Following figure \ref{fig:splitter} graphically represents the splitting architecture.

\begin{figure} [h]
	\centering
	\includegraphics[width=0.5\linewidth]{figures/splitter}
	\caption{Scramble Architecture}
	\label{fig:splitter}
\end{figure}
\subsection{usage}

+ code snippets and explanations

\subsection{challenges}
\subsection{Future scope of this work package}

\include{adaptor-arch}

